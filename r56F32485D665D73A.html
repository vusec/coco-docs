<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class MemorySSAWalker: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="page56F32485D665D73A"><span>class MemorySSAWalker</span></a></li></ul></nav><main class="content"><h1>class MemorySSAWalker</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class MemorySSAWalker { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>This is the generic walker interface for walkers of MemorySSA. Walkers are used to be able to further disambiguate the def-use chains MemorySSA gives you, or otherwise produce better info than MemorySSA gives you. In particular, while the def-use chains provide basic information, and are guaranteed to give, for example, the nearest may-aliasing MemoryDef for a MemoryUse as AliasAnalysis considers it, a user mant want better or other information. In particular, they may want to use SCEV info to further disambiguate memory accesses, or they may want the nearest dominating may-aliasing MemoryDef for a call or a store. This API enables a standardized interface to getting and using that info.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSA.h#L995">llvm/include/llvm/Analysis/MemorySSA.h:995</a></p><h2>Member Variables</h2><dl><dt class="is-family-code" id="var_MSSA">protected  <a href="r044AD4CD5978B88B.html">llvm::MemorySSA</a>* <b>MSSA</b></dt></dl><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#59951D1F751DD694"><b>MemorySSAWalker</b></a>(llvm::MemorySSA *)</li><li class="is-family-code">public llvm::MemoryAccess *  <a href="#8CADBA15B1B0D8A3"><b>getClobberingMemoryAccess</b></a>(const llvm::Instruction * I)</li><li class="is-family-code">public virtual llvm::MemoryAccess *  <a href="#A7432874D6C0407C"><b>getClobberingMemoryAccess</b></a>(llvm::MemoryAccess *)</li><li class="is-family-code">public virtual llvm::MemoryAccess *  <a href="#617CBD681B0FD500"><b>getClobberingMemoryAccess</b></a>(llvm::MemoryAccess *, const llvm::MemoryLocation &amp;)</li><li class="is-family-code">public virtual void  <a href="#52C61FAB75A93A44"><b>invalidateInfo</b></a>(llvm::MemoryAccess *)</li><li class="is-family-code">public virtual  <a href="#11D052B9DE48F323"><b>~MemorySSAWalker</b></a>()</li></ul><h2>Methods</h2><h3 id="59951D1F751DD694"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#59951D1F751DD694">¶</a><code class="hdoc-function-code language-cpp">MemorySSAWalker(<a href="r044AD4CD5978B88B.html">llvm::MemorySSA</a>*)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSA.h#L997">llvm/include/llvm/Analysis/MemorySSA.h:997</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r044AD4CD5978B88B.html">llvm::MemorySSA</a>*<b> </b></dt></dl><h3 id="8CADBA15B1B0D8A3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8CADBA15B1B0D8A3">¶</a><code class="hdoc-function-code language-cpp"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>* getClobberingMemoryAccess(
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I)</code></pre></h3><h4>Description</h4><p>Given a memory Mod/Ref/ModRef&apos;ing instruction, calling this will give you the nearest dominating MemoryAccess that Mod&apos;s the location the instruction accesses (by skipping any def which AA can prove does not alias the location(s) accessed by the instruction given). Note that this will return a single access, and it must dominate the Instruction, so if an operand of a MemoryPhi node Mod&apos;s the instruction, this will return the MemoryPhi, not the operand. This means that given: if (a) { 1 = MemoryDef(liveOnEntry) store %a } else { 2 = MemoryDef(liveOnEntry) store %b } 3 = MemoryPhi(2, 1) MemoryUse(3) load %a calling this API on load(%a) will return the MemoryPhi, not the MemoryDef in the if (a) branch.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSA.h#L1024">llvm/include/llvm/Analysis/MemorySSA.h:1024</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt></dl><h3 id="A7432874D6C0407C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A7432874D6C0407C">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*
getClobberingMemoryAccess(<a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*)</code></pre></h3><h4>Description</h4><p>Does the same thing as getClobberingMemoryAccess(const Instruction *I), but takes a MemoryAccess instead of an Instruction.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSA.h#L1032">llvm/include/llvm/Analysis/MemorySSA.h:1032</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*<b> </b></dt></dl><h3 id="617CBD681B0FD500"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#617CBD681B0FD500">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*
getClobberingMemoryAccess(
    <a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*,
    const <a href="r745B89E904927615.html">llvm::MemoryLocation</a>&amp;)</code></pre></h3><h4>Description</h4><p>Given a potentially clobbering memory access and a new location, calling this will give you the nearest dominating clobbering MemoryAccess (by skipping non-aliasing def links). This version of the function is mainly used to disambiguate phi translated pointers, where the value of a pointer may have changed from the initial memory access. Note that this expects to be handed either a MemoryUse, or an already potentially clobbering access. Unlike the above API, if given a MemoryDef that clobbers the pointer as the starting access, it will return that MemoryDef, whereas the above would return the clobber starting from the use side of  the memory def.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSA.h#L1045">llvm/include/llvm/Analysis/MemorySSA.h:1045</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*<b> </b></dt><dt class="is-family-code">const <a href="r745B89E904927615.html">llvm::MemoryLocation</a>&amp;<b> </b></dt></dl><h3 id="52C61FAB75A93A44"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#52C61FAB75A93A44">¶</a><code class="hdoc-function-code language-cpp">virtual void invalidateInfo(<a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*)</code></pre></h3><h4>Description</h4><p>Given a memory access, invalidate anything this walker knows about that access. This API is used by walkers that store information to perform basic cache invalidation.  This will be called by MemorySSA at appropriate times for the walker it uses or returns.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSA.h#L1053">llvm/include/llvm/Analysis/MemorySSA.h:1053</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*<b> </b></dt></dl><h3 id="11D052B9DE48F323"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#11D052B9DE48F323">¶</a><code class="hdoc-function-code language-cpp">virtual ~MemorySSAWalker()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSA.h#L998">llvm/include/llvm/Analysis/MemorySSA.h:998</a></p></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>