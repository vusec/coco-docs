<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class TargetInstrInfo: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="pageFA5623F5DD11136D"><span>class TargetInstrInfo</span></a></li></ul></nav><main class="content"><h1>class TargetInstrInfo</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class TargetInstrInfo : public MCInstrInfo { /* full declaration omitted */ };</code></pre><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L89">llvm/include/llvm/CodeGen/TargetInstrInfo.h:89</a></p><p>Inherits from: <a href="r65A96B8C52695A9B.html">MCInstrInfo</a></p><h2>Member Variables</h2><dl><dt class="is-family-code" id="var_CommuteAnyOperandIndex">public static  const unsigned int <b>CommuteAnyOperandIndex</b> = ~0U</dt></dl><h2>Method Overview</h2><ul><li class="is-family-code">public virtual llvm::ScheduleHazardRecognizer *  <a href="#E9AFC72F338A3584"><b>CreateTargetHazardRecognizer</b></a>(const llvm::TargetSubtargetInfo * STI, const llvm::ScheduleDAG * DAG) const</li><li class="is-family-code">public virtual llvm::ScheduleHazardRecognizer *  <a href="#31609634480EBF0A"><b>CreateTargetMIHazardRecognizer</b></a>(const llvm::InstrItineraryData *, const llvm::ScheduleDAGMI * DAG) const</li><li class="is-family-code">public virtual llvm::ScheduleHazardRecognizer *  <a href="#F4F4887A2594A895"><b>CreateTargetPostRAHazardRecognizer</b></a>(const llvm::InstrItineraryData *, const llvm::ScheduleDAG * DAG) const</li><li class="is-family-code">public virtual llvm::ScheduleHazardRecognizer *  <a href="#2454B4B69B801FE9"><b>CreateTargetPostRAHazardRecognizer</b></a>(const llvm::MachineFunction &amp; MF) const</li><li class="is-family-code">public virtual llvm::DFAPacketizer *  <a href="#2BF9ED515D968EA2"><b>CreateTargetScheduleState</b></a>(const llvm::TargetSubtargetInfo &amp;) const</li><li class="is-family-code">public virtual bool  <a href="#C131D716D7C1CB58"><b>DefinesPredicate</b></a>(llvm::MachineInstr &amp; MI, int &amp; Pred) const</li><li class="is-family-code">public virtual bool  <a href="#A977666A499CF712"><b>FoldImmediate</b></a>(llvm::MachineInstr &amp; UseMI, llvm::MachineInstr &amp; DefMI, unsigned int Reg, llvm::MachineRegisterInfo * MRI) const</li><li class="is-family-code">public virtual bool  <a href="#8EF90C3D00B29DCE"><b>PredicateInstruction</b></a>(llvm::MachineInstr &amp; MI, ArrayRef&lt;llvm::MachineOperand&gt; Pred) const</li><li class="is-family-code">public virtual void  <a href="#2218D2853A9A8B43"><b>ReplaceTailWithBranchTo</b></a>(int Tail, llvm::MachineBasicBlock * NewDest) const</li><li class="is-family-code">public virtual bool  <a href="#89F1F5D34BA2F8D7"><b>SubsumesPredicate</b></a>(ArrayRef&lt;llvm::MachineOperand&gt; Pred1, ArrayRef&lt;llvm::MachineOperand&gt; Pred2) const</li><li class="is-family-code">public  <a href="#55CBDA42161177C6"><b>TargetInstrInfo</b></a>(const llvm::TargetInstrInfo &amp;)</li><li class="is-family-code">public  <a href="#A774B86A50931980"><b>TargetInstrInfo</b></a>(unsigned int CFSetupOpcode = ~0U, unsigned int CFDestroyOpcode = ~0U, unsigned int CatchRetOpcode = ~0U, unsigned int ReturnOpcode = ~0U)</li><li class="is-family-code">public virtual bool  <a href="#2DC3707A092F0BDA"><b>analyzeBranch</b></a>(llvm::MachineBasicBlock &amp; MBB, llvm::MachineBasicBlock *&amp; TBB, llvm::MachineBasicBlock *&amp; FBB, SmallVectorImpl&lt;llvm::MachineOperand&gt; &amp; Cond, bool AllowModify = false) const</li><li class="is-family-code">public virtual bool  <a href="#6CD96E525D637854"><b>analyzeBranchPredicate</b></a>(llvm::MachineBasicBlock &amp; MBB, llvm::TargetInstrInfo::MachineBranchPredicate &amp; MBP, bool AllowModify = false) const</li><li class="is-family-code">public virtual bool  <a href="#9732B57964C1DE70"><b>analyzeCompare</b></a>(const llvm::MachineInstr &amp; MI, unsigned int &amp; SrcReg, unsigned int &amp; SrcReg2, int &amp; Mask, int &amp; Value) const</li><li class="is-family-code">public virtual bool  <a href="#72CCE00073B9DAAA"><b>analyzeLoop</b></a>(llvm::MachineLoop &amp; L, llvm::MachineInstr *&amp; IndVarInst, llvm::MachineInstr *&amp; CmpInst) const</li><li class="is-family-code">public int  <a href="#688C9FAAA20876F1"><b>analyzeLoopForPipelining</b></a>(llvm::MachineBasicBlock * LoopBB) const</li><li class="is-family-code">public virtual bool  <a href="#FE8DFA115E916C53"><b>analyzeSelect</b></a>(const llvm::MachineInstr &amp; MI, SmallVectorImpl&lt;llvm::MachineOperand&gt; &amp; Cond, unsigned int &amp; TrueOp, unsigned int &amp; FalseOp, bool &amp; Optimizable) const</li><li class="is-family-code">public virtual bool  <a href="#7B0DD320D1985F4B"><b>areLoadsFromSameBasePtr</b></a>(llvm::SDNode * Load1, llvm::SDNode * Load2, int64_t &amp; Offset1, int64_t &amp; Offset2) const</li><li class="is-family-code">public virtual bool  <a href="#5CD3C12F1E65BCDE"><b>areMemAccessesTriviallyDisjoint</b></a>(const llvm::MachineInstr &amp; MIa, const llvm::MachineInstr &amp; MIb) const</li><li class="is-family-code">public virtual void  <a href="#D3BC8004D343B60A"><b>breakPartialRegDependency</b></a>(llvm::MachineInstr &amp; MI, unsigned int OpNum, const llvm::TargetRegisterInfo * TRI) const</li><li class="is-family-code">public virtual void  <a href="#827B83E7077E980E"><b>buildOutlinedFrame</b></a>(llvm::MachineBasicBlock &amp; MBB, llvm::MachineFunction &amp; MF, const outliner::OutlinedFunction &amp; OF) const</li><li class="is-family-code">public virtual bool  <a href="#F3CD13F18D678A66"><b>canCopyGluedNodeDuringSchedule</b></a>(llvm::SDNode * N) const</li><li class="is-family-code">public virtual bool  <a href="#EAC1A48AA4EFE248"><b>canInsertSelect</b></a>(const llvm::MachineBasicBlock &amp; MBB, ArrayRef&lt;llvm::MachineOperand&gt; Cond, unsigned int TrueReg, unsigned int FalseReg, int &amp; CondCycles, int &amp; TrueCycles, int &amp; FalseCycles) const</li><li class="is-family-code">public virtual bool  <a href="#8FDCDBB0CFD42200"><b>canMakeTailCallConditional</b></a>(SmallVectorImpl&lt;llvm::MachineOperand&gt; &amp; Cond, const llvm::MachineInstr &amp; TailCall) const</li><li class="is-family-code">public llvm::MachineInstr *  <a href="#1D219BCF5692A36C"><b>commuteInstruction</b></a>(llvm::MachineInstr &amp; MI, bool NewMI = false, unsigned int OpIdx1 = CommuteAnyOperandIndex, unsigned int OpIdx2 = CommuteAnyOperandIndex) const</li><li class="is-family-code">protected virtual llvm::MachineInstr *  <a href="#F7BE81CE558C77DB"><b>commuteInstructionImpl</b></a>(llvm::MachineInstr &amp; MI, bool NewMI, unsigned int OpIdx1, unsigned int OpIdx2) const</li><li class="is-family-code">public int  <a href="#C35E1148B6A1F806"><b>computeDefOperandLatency</b></a>(const llvm::InstrItineraryData * ItinData, const llvm::MachineInstr &amp; DefMI) const</li><li class="is-family-code">public virtual llvm::MachineInstr *  <a href="#34CC180829DB25BB"><b>convertToThreeAddress</b></a>(int &amp; MFI, llvm::MachineInstr &amp; MI, llvm::LiveVariables * LV) const</li><li class="is-family-code">public virtual void  <a href="#95777755E686A14A"><b>copyPhysReg</b></a>(llvm::MachineBasicBlock &amp; MBB, int MI, const llvm::DebugLoc &amp; DL, llvm::MCRegister DestReg, llvm::MCRegister SrcReg, bool KillSrc) const</li><li class="is-family-code">public virtual llvm::MachineInstr *  <a href="#16963D4A3661C4CA"><b>createPHIDestinationCopy</b></a>(llvm::MachineBasicBlock &amp; MBB, int InsPt, const llvm::DebugLoc &amp; DL, llvm::Register Src, llvm::Register Dst) const</li><li class="is-family-code">public virtual llvm::MachineInstr *  <a href="#9C51FE7425E4B7DD"><b>createPHISourceCopy</b></a>(llvm::MachineBasicBlock &amp; MBB, int InsPt, const llvm::DebugLoc &amp; DL, llvm::Register Src, unsigned int SrcSubReg, llvm::Register Dst) const</li><li class="is-family-code">public virtual std::pair&lt;unsigned int, unsigned int&gt;  <a href="#A6065D41930440D8"><b>decomposeMachineOperandsTargetFlags</b></a>(unsigned int) const</li><li class="is-family-code">public unsigned int  <a href="#AD412D7808494342"><b>defaultDefLatency</b></a>(const llvm::MCSchedModel &amp; SchedModel, const llvm::MachineInstr &amp; DefMI) const</li><li class="is-family-code">public virtual Optional&lt;llvm::ParamLoadedValue&gt;  <a href="#4BCDE131FB1681A8"><b>describeLoadedValue</b></a>(const llvm::MachineInstr &amp; MI, llvm::Register Reg) const</li><li class="is-family-code">public virtual llvm::MachineInstr &amp;  <a href="#4FCC85ABC3157B35"><b>duplicate</b></a>(llvm::MachineBasicBlock &amp; MBB, int InsertBefore, const llvm::MachineInstr &amp; Orig) const</li><li class="is-family-code">public virtual bool  <a href="#04DE5F39A52DE6DE"><b>expandPostRAPseudo</b></a>(llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual unsigned int  <a href="#F8758553A1A8BFEB"><b>extraSizeToPredicateInstructions</b></a>(const llvm::MachineFunction &amp; MF, unsigned int NumInsts) const</li><li class="is-family-code">public virtual bool  <a href="#1E918D0F0F2FC7A2"><b>findCommutedOpIndices</b></a>(const llvm::MachineInstr &amp; MI, unsigned int &amp; SrcOpIdx1, unsigned int &amp; SrcOpIdx2) const</li><li class="is-family-code">protected static bool  <a href="#1595B568FAE49E7D"><b>fixCommutedOpIndices</b></a>(unsigned int &amp; ResultIdx1, unsigned int &amp; ResultIdx2, unsigned int CommutableOpIdx1, unsigned int CommutableOpIdx2)</li><li class="is-family-code">public llvm::MachineInstr *  <a href="#BBAF36E5A0CF1355"><b>foldMemoryOperand</b></a>(llvm::MachineInstr &amp; MI, ArrayRef&lt;unsigned int&gt; Ops, llvm::MachineInstr &amp; LoadMI, llvm::LiveIntervals * LIS = nullptr) const</li><li class="is-family-code">public llvm::MachineInstr *  <a href="#F329546B8B19E196"><b>foldMemoryOperand</b></a>(llvm::MachineInstr &amp; MI, ArrayRef&lt;unsigned int&gt; Ops, int FI, llvm::LiveIntervals * LIS = nullptr, llvm::VirtRegMap * VRM = nullptr) const</li><li class="is-family-code">protected virtual llvm::MachineInstr *  <a href="#5729AB6B8A4BB851"><b>foldMemoryOperandImpl</b></a>(llvm::MachineFunction &amp; MF, llvm::MachineInstr &amp; MI, ArrayRef&lt;unsigned int&gt; Ops, int InsertPt, llvm::MachineInstr &amp; LoadMI, llvm::LiveIntervals * LIS = nullptr) const</li><li class="is-family-code">protected virtual llvm::MachineInstr *  <a href="#07A95581B7809154"><b>foldMemoryOperandImpl</b></a>(llvm::MachineFunction &amp; MF, llvm::MachineInstr &amp; MI, ArrayRef&lt;unsigned int&gt; Ops, int InsertPt, int FrameIndex, llvm::LiveIntervals * LIS = nullptr, llvm::VirtRegMap * VRM = nullptr) const</li><li class="is-family-code">public virtual void  <a href="#0868CC2E00132239"><b>genAlternativeCodeSequence</b></a>(llvm::MachineInstr &amp; Root, llvm::MachineCombinerPattern Pattern, SmallVectorImpl&lt;llvm::MachineInstr *&gt; &amp; InsInstrs, SmallVectorImpl&lt;llvm::MachineInstr *&gt; &amp; DelInstrs, int &amp; InstIdxForVirtReg) const</li><li class="is-family-code">public virtual unsigned int  <a href="#78B41549F895C144"><b>getAddressSpaceForPseudoSourceKind</b></a>(unsigned int Kind) const</li><li class="is-family-code">public virtual bool  <a href="#0CDFFC1289883C67"><b>getBaseAndOffsetPosition</b></a>(const llvm::MachineInstr &amp; MI, unsigned int &amp; BasePos, unsigned int &amp; OffsetPos) const</li><li class="is-family-code">public virtual llvm::MachineBasicBlock *  <a href="#BF23A524296B6D82"><b>getBranchDestBlock</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public unsigned int  <a href="#8D8FA1B3A4919DFB"><b>getCallFrameDestroyOpcode</b></a>() const</li><li class="is-family-code">public unsigned int  <a href="#EE1B48518EEAB9FF"><b>getCallFrameSetupOpcode</b></a>() const</li><li class="is-family-code">public unsigned int  <a href="#DFF7DC95DAF3EF01"><b>getCatchReturnOpcode</b></a>() const</li><li class="is-family-code">public virtual std::pair&lt;uint16_t, uint16_t&gt;  <a href="#F466F42F72B98829"><b>getExecutionDomain</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public bool  <a href="#71FBB04B4195E5B5"><b>getExtractSubregInputs</b></a>(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, llvm::TargetInstrInfo::RegSubRegPairAndIdx &amp; InputReg) const</li><li class="is-family-code">protected virtual bool  <a href="#CCC87852C39F598C"><b>getExtractSubregLikeInputs</b></a>(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, llvm::TargetInstrInfo::RegSubRegPairAndIdx &amp; InputReg) const</li><li class="is-family-code">public int64_t  <a href="#737355150B529623"><b>getFrameSize</b></a>(const llvm::MachineInstr &amp; I) const</li><li class="is-family-code">public int64_t  <a href="#B15EA38325F98524"><b>getFrameTotalSize</b></a>(const llvm::MachineInstr &amp; I) const</li><li class="is-family-code">public virtual bool  <a href="#D41E19802902458E"><b>getIncrementValue</b></a>(const llvm::MachineInstr &amp; MI, int &amp; Value) const</li><li class="is-family-code">public virtual unsigned int  <a href="#A27A0FAADBB654AD"><b>getInlineAsmLength</b></a>(const char * Str, const llvm::MCAsmInfo &amp; MAI, const llvm::TargetSubtargetInfo * STI = nullptr) const</li><li class="is-family-code">public bool  <a href="#7D66956C93F360A0"><b>getInsertSubregInputs</b></a>(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, llvm::TargetInstrInfo::RegSubRegPair &amp; BaseReg, llvm::TargetInstrInfo::RegSubRegPairAndIdx &amp; InsertedReg) const</li><li class="is-family-code">protected virtual bool  <a href="#07406C48B7ED5EF4"><b>getInsertSubregLikeInputs</b></a>(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, llvm::TargetInstrInfo::RegSubRegPair &amp; BaseReg, llvm::TargetInstrInfo::RegSubRegPairAndIdx &amp; InsertedReg) const</li><li class="is-family-code">public virtual unsigned int  <a href="#B3BDA923334B5283"><b>getInstSizeInBytes</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual unsigned int  <a href="#440C82515D87CAFC"><b>getInstrLatency</b></a>(const llvm::InstrItineraryData * ItinData, const llvm::MachineInstr &amp; MI, unsigned int * PredCost = nullptr) const</li><li class="is-family-code">public virtual int  <a href="#3A4DC868F0B43753"><b>getInstrLatency</b></a>(const llvm::InstrItineraryData * ItinData, llvm::SDNode * Node) const</li><li class="is-family-code">public virtual const llvm::MIRFormatter *  <a href="#FBCACBA3371172D0"><b>getMIRFormatter</b></a>() const</li><li class="is-family-code">public virtual unsigned int  <a href="#F1B899D044721D3E"><b>getMachineCSELookAheadLimit</b></a>() const</li><li class="is-family-code">public virtual bool  <a href="#0486985A226663CA"><b>getMachineCombinerPatterns</b></a>(llvm::MachineInstr &amp; Root, SmallVectorImpl&lt;llvm::MachineCombinerPattern&gt; &amp; Patterns) const</li><li class="is-family-code">public virtual bool  <a href="#BE4189A1FB31753D"><b>getMemOperandWithOffset</b></a>(const llvm::MachineInstr &amp; MI, const llvm::MachineOperand *&amp; BaseOp, int64_t &amp; Offset, const llvm::TargetRegisterInfo * TRI) const</li><li class="is-family-code">public virtual void  <a href="#C12B7C57636E43BA"><b>getNoop</b></a>(llvm::MCInst &amp; NopInst) const</li><li class="is-family-code">public virtual unsigned int  <a href="#FAD534F460F14502"><b>getNumMicroOps</b></a>(const llvm::InstrItineraryData * ItinData, const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual unsigned int  <a href="#95D7C13E25D7B874"><b>getOpcodeAfterMemoryUnfold</b></a>(unsigned int Opc, bool UnfoldLoad, bool UnfoldStore, unsigned int * LoadRegIndex = nullptr) const</li><li class="is-family-code">public virtual int  <a href="#58955C5CDD7FABED"><b>getOperandLatency</b></a>(const llvm::InstrItineraryData * ItinData, llvm::SDNode * DefNode, unsigned int DefIdx, llvm::SDNode * UseNode, unsigned int UseIdx) const</li><li class="is-family-code">public virtual int  <a href="#5CB3036539192235"><b>getOperandLatency</b></a>(const llvm::InstrItineraryData * ItinData, const llvm::MachineInstr &amp; DefMI, unsigned int DefIdx, const llvm::MachineInstr &amp; UseMI, unsigned int UseIdx) const</li><li class="is-family-code">public virtual outliner::OutlinedFunction  <a href="#04C10D86D580FAC0"><b>getOutliningCandidateInfo</b></a>(int &amp; RepeatedSequenceLocs) const</li><li class="is-family-code">public virtual outliner::InstrType  <a href="#BBA0BEE47AEE6FF9"><b>getOutliningType</b></a>(int &amp; MIT, unsigned int Flags) const</li><li class="is-family-code">public virtual unsigned int  <a href="#E48CBABF3E31BAD2"><b>getPartialRegUpdateClearance</b></a>(const llvm::MachineInstr &amp; MI, unsigned int OpNum, const llvm::TargetRegisterInfo * TRI) const</li><li class="is-family-code">public virtual unsigned int  <a href="#2ACAA758A0A057CD"><b>getPredicationCost</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual const llvm::TargetRegisterClass *  <a href="#088E134B3ADD7490"><b>getRegClass</b></a>(const llvm::MCInstrDesc &amp; MCID, unsigned int OpNum, const llvm::TargetRegisterInfo * TRI, const llvm::MachineFunction &amp; MF) const</li><li class="is-family-code">public bool  <a href="#5FDE3BA1711EA907"><b>getRegSequenceInputs</b></a>(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, SmallVectorImpl&lt;llvm::TargetInstrInfo::RegSubRegPairAndIdx&gt; &amp; InputRegs) const</li><li class="is-family-code">protected virtual bool  <a href="#9C926D4CDD130F6E"><b>getRegSequenceLikeInputs</b></a>(const llvm::MachineInstr &amp; MI, unsigned int DefIdx, SmallVectorImpl&lt;llvm::TargetInstrInfo::RegSubRegPairAndIdx&gt; &amp; InputRegs) const</li><li class="is-family-code">public unsigned int  <a href="#F8FD39E1F547492C"><b>getReturnOpcode</b></a>() const</li><li class="is-family-code">public virtual int  <a href="#02E02C3D94B232AB"><b>getSPAdjust</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual ArrayRef&lt;std::pair&lt;unsigned int, const char *&gt;&gt;  <a href="#11B56A028A9171F9"><b>getSerializableBitmaskMachineOperandTargetFlags</b></a>() const</li><li class="is-family-code">public virtual ArrayRef&lt;std::pair&lt;unsigned int, const char *&gt;&gt;  <a href="#1BE40696F7360515"><b>getSerializableDirectMachineOperandTargetFlags</b></a>() const</li><li class="is-family-code">public virtual ArrayRef&lt;std::pair&lt;MachineMemOperand::Flags, const char *&gt;&gt;  <a href="#02E8973675BC192E"><b>getSerializableMachineMemOperandTargetFlags</b></a>() const</li><li class="is-family-code">public virtual ArrayRef&lt;std::pair&lt;int, const char *&gt;&gt;  <a href="#23549D14B4BCC5B7"><b>getSerializableTargetIndices</b></a>() const</li><li class="is-family-code">public virtual bool  <a href="#C9F80918FBA60C48"><b>getStackSlotRange</b></a>(const llvm::TargetRegisterClass * RC, unsigned int SubIdx, unsigned int &amp; Size, unsigned int &amp; Offset, const llvm::MachineFunction &amp; MF) const</li><li class="is-family-code">public virtual unsigned int  <a href="#A3292AE5F14F3540"><b>getUndefRegClearance</b></a>(const llvm::MachineInstr &amp; MI, unsigned int &amp; OpNum, const llvm::TargetRegisterInfo * TRI) const</li><li class="is-family-code">public virtual bool  <a href="#4DB5D03BB33238F4"><b>hasHighOperandLatency</b></a>(const llvm::TargetSchedModel &amp; SchedModel, const llvm::MachineRegisterInfo * MRI, const llvm::MachineInstr &amp; DefMI, unsigned int DefIdx, const llvm::MachineInstr &amp; UseMI, unsigned int UseIdx) const</li><li class="is-family-code">public virtual bool  <a href="#7B51A8438FF51DF0"><b>hasLoadFromStackSlot</b></a>(const llvm::MachineInstr &amp; MI, SmallVectorImpl&lt;const llvm::MachineMemOperand *&gt; &amp; Accesses) const</li><li class="is-family-code">public virtual bool  <a href="#02BEC6B34B685DA1"><b>hasLowDefLatency</b></a>(const llvm::TargetSchedModel &amp; SchedModel, const llvm::MachineInstr &amp; DefMI, unsigned int DefIdx) const</li><li class="is-family-code">public virtual bool  <a href="#34A133FA5F300714"><b>hasReassociableOperands</b></a>(const llvm::MachineInstr &amp; Inst, const llvm::MachineBasicBlock * MBB) const</li><li class="is-family-code">public bool  <a href="#E7EFC5D4EBBFE62F"><b>hasReassociableSibling</b></a>(const llvm::MachineInstr &amp; Inst, bool &amp; Commuted) const</li><li class="is-family-code">public virtual bool  <a href="#2CDEBA900645A049"><b>hasStoreToStackSlot</b></a>(const llvm::MachineInstr &amp; MI, SmallVectorImpl&lt;const llvm::MachineMemOperand *&gt; &amp; Accesses) const</li><li class="is-family-code">public virtual unsigned int  <a href="#CA789FEED214030A"><b>insertBranch</b></a>(llvm::MachineBasicBlock &amp; MBB, llvm::MachineBasicBlock * TBB, llvm::MachineBasicBlock * FBB, ArrayRef&lt;llvm::MachineOperand&gt; Cond, const llvm::DebugLoc &amp; DL, int * BytesAdded = nullptr) const</li><li class="is-family-code">public virtual unsigned int  <a href="#67CA814328F7D03C"><b>insertIndirectBranch</b></a>(llvm::MachineBasicBlock &amp; MBB, llvm::MachineBasicBlock &amp; NewDestBB, const llvm::DebugLoc &amp; DL, int64_t BrOffset = 0, llvm::RegScavenger * RS = nullptr) const</li><li class="is-family-code">public virtual void  <a href="#69A68CA61E8EFEDA"><b>insertNoop</b></a>(llvm::MachineBasicBlock &amp; MBB, int MI) const</li><li class="is-family-code">public int  <a href="#43F75ACD3A729BF2"><b>insertOutlinedCall</b></a>(llvm::Module &amp; M, llvm::MachineBasicBlock &amp; MBB, int &amp; It, llvm::MachineFunction &amp; MF, const outliner::Candidate &amp; C) const</li><li class="is-family-code">public virtual void  <a href="#A2DBFB771E35EE77"><b>insertSelect</b></a>(llvm::MachineBasicBlock &amp; MBB, int I, const llvm::DebugLoc &amp; DL, unsigned int DstReg, ArrayRef&lt;llvm::MachineOperand&gt; Cond, unsigned int TrueReg, unsigned int FalseReg) const</li><li class="is-family-code">public unsigned int  <a href="#5BF6A403732F9E48"><b>insertUnconditionalBranch</b></a>(llvm::MachineBasicBlock &amp; MBB, llvm::MachineBasicBlock * DestBB, const llvm::DebugLoc &amp; DL, int * BytesAdded = nullptr) const</li><li class="is-family-code">public virtual Optional&lt;llvm::RegImmPair&gt;  <a href="#3861EB94F8630AB9"><b>isAddImmediate</b></a>(const llvm::MachineInstr &amp; MI, llvm::Register Reg) const</li><li class="is-family-code">public virtual bool  <a href="#3232171CBBD775BD"><b>isAsCheapAsAMove</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual bool  <a href="#412FD42980A7B41B"><b>isAssociativeAndCommutative</b></a>(const llvm::MachineInstr &amp; Inst) const</li><li class="is-family-code">public virtual bool  <a href="#2E2EDA367D60085F"><b>isBasicBlockPrologue</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual bool  <a href="#A35464F7CF907939"><b>isBranchOffsetInRange</b></a>(unsigned int BranchOpc, int64_t BrOffset) const</li><li class="is-family-code">public virtual bool  <a href="#2712BA9E376F8345"><b>isCoalescableExtInstr</b></a>(const llvm::MachineInstr &amp; MI, unsigned int &amp; SrcReg, unsigned int &amp; DstReg, unsigned int &amp; SubIdx) const</li><li class="is-family-code">public Optional&lt;llvm::DestSourcePair&gt;  <a href="#B3515D7F854265AD"><b>isCopyInstr</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual Optional&lt;llvm::DestSourcePair&gt;  <a href="#1DD9EFC24BA68A6A"><b>isCopyInstrImpl</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public bool  <a href="#A2815F1AAF82C118"><b>isFrameInstr</b></a>(const llvm::MachineInstr &amp; I) const</li><li class="is-family-code">public bool  <a href="#A34E738CCB7F9FB7"><b>isFrameSetup</b></a>(const llvm::MachineInstr &amp; I) const</li><li class="is-family-code">public virtual bool  <a href="#39494BDC471857C2"><b>isFunctionSafeToOutlineFrom</b></a>(llvm::MachineFunction &amp; MF, bool OutlineFromLinkOnceODRs) const</li><li class="is-family-code">public static bool  <a href="#3C3DEEFBDEF0A0B1"><b>isGenericOpcode</b></a>(unsigned int Opc)</li><li class="is-family-code">public virtual bool  <a href="#720FBB13C96ADA4B"><b>isHighLatencyDef</b></a>(int opc) const</li><li class="is-family-code">public virtual bool  <a href="#78DEA6C80ACB7E51"><b>isLegalToSplitMBBAt</b></a>(llvm::MachineBasicBlock &amp; MBB, int MBBI) const</li><li class="is-family-code">public virtual unsigned int  <a href="#61FDF85A255190F3"><b>isLoadFromStackSlot</b></a>(const llvm::MachineInstr &amp; MI, int &amp; FrameIndex, unsigned int &amp; MemBytes) const</li><li class="is-family-code">public virtual unsigned int  <a href="#EFC9DF8CFA3CAA6C"><b>isLoadFromStackSlot</b></a>(const llvm::MachineInstr &amp; MI, int &amp; FrameIndex) const</li><li class="is-family-code">public virtual unsigned int  <a href="#0AF9934A7046A0B8"><b>isLoadFromStackSlotPostFE</b></a>(const llvm::MachineInstr &amp; MI, int &amp; FrameIndex) const</li><li class="is-family-code">public virtual bool  <a href="#F6E2ADBBE15A581C"><b>isMBBSafeToOutlineFrom</b></a>(llvm::MachineBasicBlock &amp; MBB, unsigned int &amp; Flags) const</li><li class="is-family-code">public virtual bool  <a href="#1BEB8CC6EF9CA174"><b>isPostIncrement</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual bool  <a href="#A452979E29A19E70"><b>isPredicable</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual bool  <a href="#D7CC28C1F0C34E42"><b>isPredicated</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual bool  <a href="#3C393ACFC667A80B"><b>isProfitableToDupForIfCvt</b></a>(llvm::MachineBasicBlock &amp; MBB, unsigned int NumCycles, llvm::BranchProbability Probability) const</li><li class="is-family-code">public virtual bool  <a href="#82EB17706607A0DA"><b>isProfitableToIfCvt</b></a>(llvm::MachineBasicBlock &amp; TMBB, unsigned int NumTCycles, unsigned int ExtraTCycles, llvm::MachineBasicBlock &amp; FMBB, unsigned int NumFCycles, unsigned int ExtraFCycles, llvm::BranchProbability Probability) const</li><li class="is-family-code">public virtual bool  <a href="#4EF37B4D256FE48F"><b>isProfitableToIfCvt</b></a>(llvm::MachineBasicBlock &amp; MBB, unsigned int NumCycles, unsigned int ExtraPredCycles, llvm::BranchProbability Probability) const</li><li class="is-family-code">public virtual bool  <a href="#69707669F8B1E522"><b>isProfitableToUnpredicate</b></a>(llvm::MachineBasicBlock &amp; TMBB, llvm::MachineBasicBlock &amp; FMBB) const</li><li class="is-family-code">protected virtual bool  <a href="#5D29B991C911C424"><b>isReallyTriviallyReMaterializable</b></a>(const llvm::MachineInstr &amp; MI, llvm::AAResults * AA) const</li><li class="is-family-code">public bool  <a href="#845600387FF4F0F6"><b>isReassociationCandidate</b></a>(const llvm::MachineInstr &amp; Inst, bool &amp; Commuted) const</li><li class="is-family-code">public virtual bool  <a href="#28A083E1BB7F9E58"><b>isSafeToMoveRegClassDefs</b></a>(const llvm::TargetRegisterClass * RC) const</li><li class="is-family-code">public virtual bool  <a href="#CD76F1CD0A15A606"><b>isSchedulingBoundary</b></a>(const llvm::MachineInstr &amp; MI, const llvm::MachineBasicBlock * MBB, const llvm::MachineFunction &amp; MF) const</li><li class="is-family-code">public virtual bool  <a href="#108290D748F19234"><b>isStackSlotCopy</b></a>(const llvm::MachineInstr &amp; MI, int &amp; DestFrameIndex, int &amp; SrcFrameIndex) const</li><li class="is-family-code">public virtual unsigned int  <a href="#B6864846FBABE401"><b>isStoreToStackSlot</b></a>(const llvm::MachineInstr &amp; MI, int &amp; FrameIndex) const</li><li class="is-family-code">public virtual unsigned int  <a href="#DF78E311B8892E9E"><b>isStoreToStackSlot</b></a>(const llvm::MachineInstr &amp; MI, int &amp; FrameIndex, unsigned int &amp; MemBytes) const</li><li class="is-family-code">public virtual unsigned int  <a href="#A5F321273A8795DB"><b>isStoreToStackSlotPostFE</b></a>(const llvm::MachineInstr &amp; MI, int &amp; FrameIndex) const</li><li class="is-family-code">public virtual bool  <a href="#436A6DC1A6686B7A"><b>isSubregFoldable</b></a>() const</li><li class="is-family-code">public virtual bool  <a href="#CB59E662B7976B9C"><b>isTailCall</b></a>(const llvm::MachineInstr &amp; Inst) const</li><li class="is-family-code">public virtual bool  <a href="#BB234CAFABCCAC24"><b>isThroughputPattern</b></a>(llvm::MachineCombinerPattern Pattern) const</li><li class="is-family-code">public bool  <a href="#9884D56C1D5EB578"><b>isTriviallyReMaterializable</b></a>(const llvm::MachineInstr &amp; MI, llvm::AAResults * AA = nullptr) const</li><li class="is-family-code">public virtual bool  <a href="#FB34BCE69F06B726"><b>isUnconditionalTailCall</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual bool  <a href="#F9BD9157F61450EE"><b>isUnpredicatedTerminator</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public bool  <a href="#587E15A8AB58BA68"><b>isZeroCost</b></a>(unsigned int Opcode) const</li><li class="is-family-code">public virtual void  <a href="#6BE91B61D3471895"><b>loadRegFromStackSlot</b></a>(llvm::MachineBasicBlock &amp; MBB, int MI, unsigned int DestReg, int FrameIndex, const llvm::TargetRegisterClass * RC, const llvm::TargetRegisterInfo * TRI) const</li><li class="is-family-code">public virtual bool  <a href="#5A17DCC74B008804"><b>optimizeCompareInstr</b></a>(llvm::MachineInstr &amp; CmpInstr, unsigned int SrcReg, unsigned int SrcReg2, int Mask, int Value, const llvm::MachineRegisterInfo * MRI) const</li><li class="is-family-code">public virtual bool  <a href="#CEF2B8E58A8F69C8"><b>optimizeCondBranch</b></a>(llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual llvm::MachineInstr *  <a href="#51C3305A6CAA115E"><b>optimizeLoadInstr</b></a>(llvm::MachineInstr &amp; MI, const llvm::MachineRegisterInfo * MRI, unsigned int &amp; FoldAsLoadDefReg, llvm::MachineInstr *&amp; DefMI) const</li><li class="is-family-code">public virtual llvm::MachineInstr *  <a href="#19FD5141C97110BD"><b>optimizeSelect</b></a>(llvm::MachineInstr &amp; MI, SmallPtrSetImpl&lt;llvm::MachineInstr *&gt; &amp; NewMIs, bool PreferFalse = false) const</li><li class="is-family-code">public virtual unsigned int  <a href="#5BCD95A111E6F6EF"><b>predictBranchSizeForIfCvt</b></a>(llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual bool  <a href="#55BBB7BB2BAF9DE4"><b>produceSameValue</b></a>(const llvm::MachineInstr &amp; MI0, const llvm::MachineInstr &amp; MI1, const llvm::MachineRegisterInfo * MRI = nullptr) const</li><li class="is-family-code">public virtual void  <a href="#F96BB8DC8D042DD6"><b>reMaterialize</b></a>(llvm::MachineBasicBlock &amp; MBB, int MI, unsigned int DestReg, unsigned int SubIdx, const llvm::MachineInstr &amp; Orig, const llvm::TargetRegisterInfo &amp; TRI) const</li><li class="is-family-code">public void  <a href="#094E51BE5D0B8B59"><b>reassociateOps</b></a>(llvm::MachineInstr &amp; Root, llvm::MachineInstr &amp; Prev, llvm::MachineCombinerPattern Pattern, SmallVectorImpl&lt;llvm::MachineInstr *&gt; &amp; InsInstrs, SmallVectorImpl&lt;llvm::MachineInstr *&gt; &amp; DelInstrs, int &amp; InstrIdxForVirtReg) const</li><li class="is-family-code">public virtual unsigned int  <a href="#712201E081C61EE5"><b>reduceLoopCount</b></a>(llvm::MachineBasicBlock &amp; MBB, llvm::MachineBasicBlock &amp; PreHeader, llvm::MachineInstr * IndVar, llvm::MachineInstr &amp; Cmp, SmallVectorImpl&lt;llvm::MachineOperand&gt; &amp; Cond, SmallVectorImpl&lt;llvm::MachineInstr *&gt; &amp; PrevInsts, unsigned int Iter, unsigned int MaxIter) const</li><li class="is-family-code">public virtual unsigned int  <a href="#3525798E1DB67EDE"><b>removeBranch</b></a>(llvm::MachineBasicBlock &amp; MBB, int * BytesRemoved = nullptr) const</li><li class="is-family-code">public virtual void  <a href="#82207AFE66DF2EEC"><b>replaceBranchWithTailCall</b></a>(llvm::MachineBasicBlock &amp; MBB, SmallVectorImpl&lt;llvm::MachineOperand&gt; &amp; Cond, const llvm::MachineInstr &amp; TailCall) const</li><li class="is-family-code">public virtual bool  <a href="#2562758428C9B63C"><b>reverseBranchCondition</b></a>(SmallVectorImpl&lt;llvm::MachineOperand&gt; &amp; Cond) const</li><li class="is-family-code">public virtual void  <a href="#5314B0E9B12F16AA"><b>setExecutionDomain</b></a>(llvm::MachineInstr &amp; MI, unsigned int Domain) const</li><li class="is-family-code">public virtual void  <a href="#1DADDCAD5FA23945"><b>setSpecialOperandAttr</b></a>(llvm::MachineInstr &amp; OldMI1, llvm::MachineInstr &amp; OldMI2, llvm::MachineInstr &amp; NewMI1, llvm::MachineInstr &amp; NewMI2) const</li><li class="is-family-code">public virtual bool  <a href="#E269B153F00E9FC8"><b>shouldClusterMemOps</b></a>(const llvm::MachineOperand &amp; BaseOp1, const llvm::MachineOperand &amp; BaseOp2, unsigned int NumLoads) const</li><li class="is-family-code">public virtual bool  <a href="#C8E3F9918BA5DF66"><b>shouldOutlineFromFunctionByDefault</b></a>(llvm::MachineFunction &amp; MF) const</li><li class="is-family-code">public virtual bool  <a href="#360C971A7677695D"><b>shouldScheduleLoadsNear</b></a>(llvm::SDNode * Load1, llvm::SDNode * Load2, int64_t Offset1, int64_t Offset2, unsigned int NumLoads) const</li><li class="is-family-code">public virtual bool  <a href="#0F86CF0DF7834FA7"><b>shouldSink</b></a>(const llvm::MachineInstr &amp; MI) const</li><li class="is-family-code">public virtual void  <a href="#764DD008317DEEC6"><b>storeRegToStackSlot</b></a>(llvm::MachineBasicBlock &amp; MBB, int MI, unsigned int SrcReg, bool isKill, int FrameIndex, const llvm::TargetRegisterClass * RC, const llvm::TargetRegisterInfo * TRI) const</li><li class="is-family-code">public virtual bool  <a href="#657051E19623F4F2"><b>unfoldMemoryOperand</b></a>(llvm::MachineFunction &amp; MF, llvm::MachineInstr &amp; MI, unsigned int Reg, bool UnfoldLoad, bool UnfoldStore, SmallVectorImpl&lt;llvm::MachineInstr *&gt; &amp; NewMIs) const</li><li class="is-family-code">public virtual bool  <a href="#B84420458F720982"><b>unfoldMemoryOperand</b></a>(llvm::SelectionDAG &amp; DAG, llvm::SDNode * N, SmallVectorImpl&lt;llvm::SDNode *&gt; &amp; NewNodes) const</li><li class="is-family-code">public virtual bool  <a href="#F218AAFF83B81408"><b>useMachineCombiner</b></a>() const</li><li class="is-family-code">public bool  <a href="#392FB1B512BB83EE"><b>usePreRAHazardRecognizer</b></a>() const</li><li class="is-family-code">public virtual bool  <a href="#D8E081888EA140E8"><b>verifyInstruction</b></a>(const llvm::MachineInstr &amp; MI, llvm::StringRef &amp; ErrInfo) const</li><li class="is-family-code">public virtual  <a href="#C8F51E588850B315"><b>~TargetInstrInfo</b></a>()</li></ul><p>Inherited from <a href="r65A96B8C52695A9B.html">MCInstrInfo</a>:</p><ul><li class="is-family-code"><a href="r65A96B8C52695A9B.html#2FCB15979E0BE8E8">public <b>InitMCInstrInfo</b></a></li><li class="is-family-code"><a href="r65A96B8C52695A9B.html#37CB564080E68BDD">public <b>get</b></a></li><li class="is-family-code"><a href="r65A96B8C52695A9B.html#09496FCE3D2A2E98">public <b>getName</b></a></li><li class="is-family-code"><a href="r65A96B8C52695A9B.html#D5BE0C1480D1CB1C">public <b>getNumOpcodes</b></a></li></ul><h2>Methods</h2><h3 id="E9AFC72F338A3584"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E9AFC72F338A3584">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rE07F240057278813.html">llvm::ScheduleHazardRecognizer</a>*
CreateTargetHazardRecognizer(
    const <a href="rB76DF6D82BF57FB2.html">llvm::TargetSubtargetInfo</a>* STI,
    const <a href="r16AE015C49DE23F4.html">llvm::ScheduleDAG</a>* DAG) const</code></pre></h3><h4>Description</h4><p>Allocate and return a hazard recognizer to use for this target when scheduling the machine instructions before register allocation.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1367">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1367</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rB76DF6D82BF57FB2.html">llvm::TargetSubtargetInfo</a>*<b> STI</b></dt><dt class="is-family-code">const <a href="r16AE015C49DE23F4.html">llvm::ScheduleDAG</a>*<b> DAG</b></dt></dl><h3 id="31609634480EBF0A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#31609634480EBF0A">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rE07F240057278813.html">llvm::ScheduleHazardRecognizer</a>*
CreateTargetMIHazardRecognizer(
    const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*,
    const <a href="r22E8932FFD82C1CD.html">llvm::ScheduleDAGMI</a>* DAG) const</code></pre></h3><h4>Description</h4><p>Allocate and return a hazard recognizer to use for this target when scheduling the machine instructions before register allocation.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1373">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1373</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*<b> </b></dt><dt class="is-family-code">const <a href="r22E8932FFD82C1CD.html">llvm::ScheduleDAGMI</a>*<b> DAG</b></dt></dl><h3 id="F4F4887A2594A895"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F4F4887A2594A895">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rE07F240057278813.html">llvm::ScheduleHazardRecognizer</a>*
CreateTargetPostRAHazardRecognizer(
    const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*,
    const <a href="r16AE015C49DE23F4.html">llvm::ScheduleDAG</a>* DAG) const</code></pre></h3><h4>Description</h4><p>Allocate and return a hazard recognizer to use for this target when scheduling the machine instructions after register allocation.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1379">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1379</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*<b> </b></dt><dt class="is-family-code">const <a href="r16AE015C49DE23F4.html">llvm::ScheduleDAG</a>*<b> DAG</b></dt></dl><h3 id="2454B4B69B801FE9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2454B4B69B801FE9">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rE07F240057278813.html">llvm::ScheduleHazardRecognizer</a>*
CreateTargetPostRAHazardRecognizer(
    const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF) const</code></pre></h3><h4>Description</h4><p>Allocate and return a hazard recognizer to use for by non-scheduling passes.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1385">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1385</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt></dl><h3 id="2BF9ED515D968EA2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2BF9ED515D968EA2">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r736FB4FC9962E850.html">llvm::DFAPacketizer</a>*
CreateTargetScheduleState(
    const <a href="rB76DF6D82BF57FB2.html">llvm::TargetSubtargetInfo</a>&amp;) const</code></pre></h3><h4>Description</h4><p>Create machine specific model for scheduling.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1634">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1634</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rB76DF6D82BF57FB2.html">llvm::TargetSubtargetInfo</a>&amp;<b> </b></dt></dl><h3 id="C131D716D7C1CB58"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C131D716D7C1CB58">¶</a><code class="hdoc-function-code language-cpp">virtual bool DefinesPredicate(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    int&amp; Pred) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1334">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1334</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">int&amp;<b> Pred</b></dt></dl><h3 id="A977666A499CF712"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A977666A499CF712">¶</a><code class="hdoc-function-code language-cpp">virtual bool FoldImmediate(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; UseMI,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; DefMI,
    unsigned int Reg,
    <a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>* MRI) const</code></pre></h3><h4>Description</h4><p>&apos;Reg&apos; is known to be defined by a move immediate instruction, try to fold the immediate into the use instruction. If MRI-&gt;hasOneNonDBGUse(Reg) is true, and this function returns true, then the caller may assume that DefMI has been erased from its parent block. The caller may assume that it will not be erased by this function otherwise.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1432">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1432</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> UseMI</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> DefMI</b></dt><dt class="is-family-code">unsigned int<b> Reg</b></dt><dt class="is-family-code"><a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>*<b> MRI</b></dt></dl><h3 id="8EF90C3D00B29DCE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8EF90C3D00B29DCE">¶</a><code class="hdoc-function-code language-cpp">virtual bool PredicateInstruction(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt; Pred) const</code></pre></h3><h4>Description</h4><p>Convert the instruction into a predicated instruction. It returns true if the operation was successful.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1321">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1321</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt;<b> Pred</b></dt></dl><h3 id="2218D2853A9A8B43"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2218D2853A9A8B43">¶</a><code class="hdoc-function-code language-cpp">virtual void ReplaceTailWithBranchTo(
    int Tail,
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>* NewDest) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L752">llvm/include/llvm/CodeGen/TargetInstrInfo.h:752</a></p><h4>Parameters</h4><dl><dt class="is-family-code">int<b> Tail</b></dt><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>*<b> NewDest</b></dt></dl><h3 id="89F1F5D34BA2F8D7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#89F1F5D34BA2F8D7">¶</a><code class="hdoc-function-code language-cpp">virtual bool SubsumesPredicate(
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt; Pred1,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt; Pred2) const</code></pre></h3><h4>Description</h4><p>Returns true if the first specified predicate subsumes the second, e.g. GE subsumes GT.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1326">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1326</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt;<b> Pred1</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt;<b> Pred2</b></dt></dl><h3 id="55CBDA42161177C6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#55CBDA42161177C6">¶</a><code class="hdoc-function-code language-cpp">TargetInstrInfo(const <a href="rFA5623F5DD11136D.html">llvm::TargetInstrInfo</a>&amp;)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L96">llvm/include/llvm/CodeGen/TargetInstrInfo.h:96</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rFA5623F5DD11136D.html">llvm::TargetInstrInfo</a>&amp;<b> </b></dt></dl><h3 id="A774B86A50931980"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A774B86A50931980">¶</a><code class="hdoc-function-code language-cpp">TargetInstrInfo(
    unsigned int CFSetupOpcode = ~0U,
    unsigned int CFDestroyOpcode = ~0U,
    unsigned int CatchRetOpcode = ~0U,
    unsigned int ReturnOpcode = ~0U)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L91">llvm/include/llvm/CodeGen/TargetInstrInfo.h:91</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> CFSetupOpcode</b> = ~0U</dt><dt class="is-family-code">unsigned int<b> CFDestroyOpcode</b> = ~0U</dt><dt class="is-family-code">unsigned int<b> CatchRetOpcode</b> = ~0U</dt><dt class="is-family-code">unsigned int<b> ReturnOpcode</b> = ~0U</dt></dl><h3 id="2DC3707A092F0BDA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2DC3707A092F0BDA">¶</a><code class="hdoc-function-code language-cpp">virtual bool analyzeBranch(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    llvm::MachineBasicBlock*&amp; TBB,
    llvm::MachineBasicBlock*&amp; FBB,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp; Cond,
    bool AllowModify = false) const</code></pre></h3><h4>Description</h4><p>Analyze the branching code at the end of MBB, returning true if it cannot be understood (e.g. it&apos;s a switch dispatch or isn&apos;t implemented for a target).  Upon success, this returns false and returns with the following information in various cases: 1. If this block ends with no branches (it just falls through to its succ) just return false, leaving TBB/FBB null. 2. If this block ends with only an unconditional branch, it sets TBB to be the destination block. 3. If this block ends with a conditional branch and it falls through to a successor block, it sets TBB to be the branch destination block and a list of operands that evaluate the condition. These operands can be passed to other TargetInstrInfo methods to create new branches. 4. If this block ends with a conditional branch followed by an unconditional branch, it returns the &apos;true&apos; destination in TBB, the &apos;false&apos; destination in FBB, and a list of operands that evaluate the condition.  These operands can be passed to other TargetInstrInfo methods to create new branches. Note that removeBranch and insertBranch must be implemented to support cases where this method returns success. If AllowModify is true, then this routine is allowed to modify the basic block (e.g. delete instructions after the unconditional branch). The CFG information in MBB.Predecessors and MBB.Successors must be valid before calling this function.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L598">llvm/include/llvm/CodeGen/TargetInstrInfo.h:598</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">llvm::MachineBasicBlock*&amp;<b> TBB</b></dt><dt class="is-family-code">llvm::MachineBasicBlock*&amp;<b> FBB</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp;<b> Cond</b></dt><dt class="is-family-code">bool<b> AllowModify</b> = false</dt></dl><h3 id="6CD96E525D637854"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6CD96E525D637854">¶</a><code class="hdoc-function-code language-cpp">virtual bool analyzeBranchPredicate(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    <a href="r1581BE37A6EE3820.html">llvm::TargetInstrInfo::MachineBranchPredicate</a>&amp;
        MBP,
    bool AllowModify = false) const</code></pre></h3><h4>Description</h4><p>Analyze the branching code at the end of MBB and parse it into the MachineBranchPredicate structure if possible.  Returns false on success and true on failure. If AllowModify is true, then this routine is allowed to modify the basic block (e.g. delete instructions after the unconditional branch).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L640">llvm/include/llvm/CodeGen/TargetInstrInfo.h:640</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code"><a href="r1581BE37A6EE3820.html">llvm::TargetInstrInfo::MachineBranchPredicate</a>&amp;<b> MBP</b></dt><dt class="is-family-code">bool<b> AllowModify</b> = false</dt></dl><h3 id="9732B57964C1DE70"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9732B57964C1DE70">¶</a><code class="hdoc-function-code language-cpp">virtual bool analyzeCompare(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int&amp; SrcReg,
    unsigned int&amp; SrcReg2,
    int&amp; Mask,
    int&amp; Value) const</code></pre></h3><h4>Description</h4><p>For a comparison instruction, return the source registers in SrcReg and SrcReg2 if having two register operands, and the value it compares against in CmpValue. Return true if the comparison instruction can be analyzed.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1397">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1397</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int&amp;<b> SrcReg</b></dt><dt class="is-family-code">unsigned int&amp;<b> SrcReg2</b></dt><dt class="is-family-code">int&amp;<b> Mask</b></dt><dt class="is-family-code">int&amp;<b> Value</b></dt></dl><h3 id="72CCE00073B9DAAA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#72CCE00073B9DAAA">¶</a><code class="hdoc-function-code language-cpp">virtual bool analyzeLoop(
    <a href="r510CD8D1F2BFFDBA.html">llvm::MachineLoop</a>&amp; L,
    llvm::MachineInstr*&amp; IndVarInst,
    llvm::MachineInstr*&amp; CmpInst) const</code></pre></h3><h4>Description</h4><p>Analyze the loop code, return true if it cannot be understoo. Upon success, this function returns false and returns information about the induction variable and compare instruction used at the end.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L732">llvm/include/llvm/CodeGen/TargetInstrInfo.h:732</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r510CD8D1F2BFFDBA.html">llvm::MachineLoop</a>&amp;<b> L</b></dt><dt class="is-family-code">llvm::MachineInstr*&amp;<b> IndVarInst</b></dt><dt class="is-family-code">llvm::MachineInstr*&amp;<b> CmpInst</b></dt></dl><h3 id="688C9FAAA20876F1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#688C9FAAA20876F1">¶</a><code class="hdoc-function-code language-cpp">int analyzeLoopForPipelining(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>* LoopBB) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L725">llvm/include/llvm/CodeGen/TargetInstrInfo.h:725</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>*<b> LoopBB</b></dt></dl><h3 id="FE8DFA115E916C53"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FE8DFA115E916C53">¶</a><code class="hdoc-function-code language-cpp">virtual bool analyzeSelect(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp; Cond,
    unsigned int&amp; TrueOp,
    unsigned int&amp; FalseOp,
    bool&amp; Optimizable) const</code></pre></h3><h4>Description</h4><p>Analyze the given select instruction, returning true if it cannot be understood. It is assumed that MI-&gt;isSelect() is true. When successful, return the controlling condition and the operands that determine the true and false result values. Result = SELECT Cond, TrueOp, FalseOp Some targets can optimize select instructions, for example by predicating the instruction defining one of the operands. Such targets should set Optimizable.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L893">llvm/include/llvm/CodeGen/TargetInstrInfo.h:893</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dd>Select instruction to analyze.</dd><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp;<b> Cond</b></dt><dd>Condition controlling the select.</dd><dt class="is-family-code">unsigned int&amp;<b> TrueOp</b></dt><dd>Operand number of the value selected when Cond is true.</dd><dt class="is-family-code">unsigned int&amp;<b> FalseOp</b></dt><dd>Operand number of the value selected when Cond is false.</dd><dt class="is-family-code">bool&amp;<b> Optimizable</b></dt><dd>Returned as true if MI is optimizable.</dd></dl><h4>Returns</h4><p>False on success.</p><h3 id="7B0DD320D1985F4B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7B0DD320D1985F4B">¶</a><code class="hdoc-function-code language-cpp">virtual bool areLoadsFromSameBasePtr(
    <a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>* Load1,
    <a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>* Load2,
    int64_t&amp; Offset1,
    int64_t&amp; Offset2) const</code></pre></h3><h4>Description</h4><p>This is used by the pre-regalloc scheduler to determine if two loads are loading from the same base address. It should only return true if the base pointers are the same and the only differences between the two addresses are the offset. It also returns the offsets by reference.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1218">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1218</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>*<b> Load1</b></dt><dt class="is-family-code"><a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>*<b> Load2</b></dt><dt class="is-family-code">int64_t&amp;<b> Offset1</b></dt><dt class="is-family-code">int64_t&amp;<b> Offset2</b></dt></dl><h3 id="5CD3C12F1E65BCDE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5CD3C12F1E65BCDE">¶</a><code class="hdoc-function-code language-cpp">virtual bool areMemAccessesTriviallyDisjoint(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MIa,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MIb) const</code></pre></h3><h4>Description</h4><p>Sometimes, it is possible for the target to tell, even without aliasing information, that two MIs access different memory addresses. This function returns true if two MIs access different memory addresses and false otherwise. Assumes any physical registers used to compute addresses have the same value for both instructions. (This is the most useful assumption for post-RA scheduling.) See also MachineInstr::mayAlias, which is implemented on top of this function.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1650">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1650</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MIa</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MIb</b></dt></dl><h3 id="D3BC8004D343B60A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D3BC8004D343B60A">¶</a><code class="hdoc-function-code language-cpp">virtual void breakPartialRegDependency(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int OpNum,
    const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>* TRI) const</code></pre></h3><h4>Description</h4><p>Insert a dependency-breaking instruction before MI to eliminate an unwanted dependency on OpNum. If it wasn&apos;t possible to avoid a def in the last N instructions before MI (see getPartialRegUpdateClearance), this hook will be called to break the unwanted dependency. On x86, an xorps instruction can be used as a dependency breaker: addps %xmm1, %xmm0 movaps %xmm0, (%rax) xorps %xmm0, %xmm0 cvtsi2ss %rbx, %xmm0 An  &lt;imp -kill&gt; operand should be added to MI if an instruction was inserted.  This ties the instructions together in the post-ra scheduler.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1629">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1629</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> OpNum</b></dt><dt class="is-family-code">const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>*<b> TRI</b></dt></dl><h3 id="827B83E7077E980E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#827B83E7077E980E">¶</a><code class="hdoc-function-code language-cpp">virtual void buildOutlinedFrame(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF,
    const <a href="r4BC44A554EC83894.html">outliner::OutlinedFunction</a>&amp; OF) const</code></pre></h3><h4>Description</h4><p>Insert a custom frame for outlined functions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1773">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1773</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code"><a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt><dt class="is-family-code">const <a href="r4BC44A554EC83894.html">outliner::OutlinedFunction</a>&amp;<b> OF</b></dt></dl><h3 id="F3CD13F18D678A66"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F3CD13F18D678A66">¶</a><code class="hdoc-function-code language-cpp">virtual bool canCopyGluedNodeDuringSchedule(
    <a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>* N) const</code></pre></h3><h4>Description</h4><p>Return true if the given SDNode can be copied during scheduling even if it has glue.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1107">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1107</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>*<b> N</b></dt></dl><h3 id="EAC1A48AA4EFE248"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EAC1A48AA4EFE248">¶</a><code class="hdoc-function-code language-cpp">virtual bool canInsertSelect(
    const <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt; Cond,
    unsigned int TrueReg,
    unsigned int FalseReg,
    int&amp; CondCycles,
    int&amp; TrueCycles,
    int&amp; FalseCycles) const</code></pre></h3><h4>Description</h4><p>Return true if it is possible to insert a select instruction that chooses between TrueReg and FalseReg based on the condition code in Cond. When successful, also return the latency in cycles from TrueReg, FalseReg, and Cond to the destination register. In most cases, a select instruction will be 1 cycle, so CondCycles = TrueCycles = FalseCycles = 1 Some x86 implementations have 2-cycle cmov instructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L846">llvm/include/llvm/CodeGen/TargetInstrInfo.h:846</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dd>Block where select instruction would be inserted.</dd><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt;<b> Cond</b></dt><dd>Condition returned by AnalyzeBranch.</dd><dt class="is-family-code">unsigned int<b> TrueReg</b></dt><dd>Virtual register to select when Cond is true.</dd><dt class="is-family-code">unsigned int<b> FalseReg</b></dt><dd>Virtual register to select when Cond is false.</dd><dt class="is-family-code">int&amp;<b> CondCycles</b></dt><dd>Latency from Cond+Branch to select output.</dd><dt class="is-family-code">int&amp;<b> TrueCycles</b></dt><dd>Latency from TrueReg to select output.</dd><dt class="is-family-code">int&amp;<b> FalseCycles</b></dt><dd>Latency from FalseReg to select output.</dd></dl><h3 id="8FDCDBB0CFD42200"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8FDCDBB0CFD42200">¶</a><code class="hdoc-function-code language-cpp">virtual bool canMakeTailCallConditional(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp; Cond,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; TailCall) const</code></pre></h3><h4>Description</h4><p>Returns true if the tail call can be made conditional on BranchCond.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1307">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1307</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp;<b> Cond</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> TailCall</b></dt></dl><h3 id="1D219BCF5692A36C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1D219BCF5692A36C">¶</a><code class="hdoc-function-code language-cpp"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* commuteInstruction(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    bool NewMI = false,
    unsigned int OpIdx1 = CommuteAnyOperandIndex,
    unsigned int OpIdx2 =
        CommuteAnyOperandIndex) const</code></pre></h3><h4>Description</h4><p>This method commutes the operands of the given machine instruction MI. The operands to be commuted are specified by their indices OpIdx1 and OpIdx2. OpIdx1 and OpIdx2 arguments may be set to a special value &apos;CommuteAnyOperandIndex&apos;, which means that the method is free to choose any arbitrarily chosen commutable operand. If both arguments are set to &apos;CommuteAnyOperandIndex&apos; then the method looks for 2 different commutable operands; then commutes them if such operands could be found. If NewMI is false, MI is modified in place and returned; otherwise, a new machine instruction is created and returned. Do not call this method for a non-commutable instruction or for non-commuable operands. Even though the instruction is commutable, the method may still fail to commute the operands, null pointer is returned in such cases.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L423">llvm/include/llvm/CodeGen/TargetInstrInfo.h:423</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">bool<b> NewMI</b> = false</dt><dt class="is-family-code">unsigned int<b> OpIdx1</b> = CommuteAnyOperandIndex</dt><dt class="is-family-code">unsigned int<b> OpIdx2</b> = CommuteAnyOperandIndex</dt></dl><h3 id="F7BE81CE558C77DB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F7BE81CE558C77DB">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>*
commuteInstructionImpl(<a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
                       bool NewMI,
                       unsigned int OpIdx1,
                       unsigned int OpIdx2) const</code></pre></h3><h4>Description</h4><p>This method commutes the operands of the given machine instruction MI. The operands to be commuted are specified by their indices OpIdx1 and OpIdx2. If a target has any instructions that are commutable but require converting to different instructions or making non-trivial changes to commute them, this method can be overloaded to do that. The default implementation simply swaps the commutable operands. If NewMI is false, MI is modified in place and returned; otherwise, a new machine instruction is created and returned. Do not call this method for a non-commutable instruction. Even though the instruction is commutable, the method may still fail to commute the operands, null pointer is returned in such cases.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L152">llvm/include/llvm/CodeGen/TargetInstrInfo.h:152</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">bool<b> NewMI</b></dt><dt class="is-family-code">unsigned int<b> OpIdx1</b></dt><dt class="is-family-code">unsigned int<b> OpIdx2</b></dt></dl><h3 id="C35E1148B6A1F806"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C35E1148B6A1F806">¶</a><code class="hdoc-function-code language-cpp">int computeDefOperandLatency(
    const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>* ItinData,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; DefMI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1485">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1485</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*<b> ItinData</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> DefMI</b></dt></dl><h3 id="34CC180829DB25BB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#34CC180829DB25BB">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* convertToThreeAddress(
    int&amp; MFI,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r8A55ECC8042BB819.html">llvm::LiveVariables</a>* LV) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L394">llvm/include/llvm/CodeGen/TargetInstrInfo.h:394</a></p><h4>Parameters</h4><dl><dt class="is-family-code">int&amp;<b> MFI</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="r8A55ECC8042BB819.html">llvm::LiveVariables</a>*<b> LV</b></dt></dl><h3 id="95777755E686A14A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#95777755E686A14A">¶</a><code class="hdoc-function-code language-cpp">virtual void copyPhysReg(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int MI,
    const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp; DL,
    <a href="r2E93E52F2730BB38.html">llvm::MCRegister</a> DestReg,
    <a href="r2E93E52F2730BB38.html">llvm::MCRegister</a> SrcReg,
    bool KillSrc) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L931">llvm/include/llvm/CodeGen/TargetInstrInfo.h:931</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> MI</b></dt><dt class="is-family-code">const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp;<b> DL</b></dt><dt class="is-family-code"><a href="r2E93E52F2730BB38.html">llvm::MCRegister</a><b> DestReg</b></dt><dt class="is-family-code"><a href="r2E93E52F2730BB38.html">llvm::MCRegister</a><b> SrcReg</b></dt><dt class="is-family-code">bool<b> KillSrc</b></dt></dl><h3 id="16963D4A3661C4CA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#16963D4A3661C4CA">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>*
createPHIDestinationCopy(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int InsPt,
    const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp; DL,
    <a href="rD04632A218C37229.html">llvm::Register</a> Src,
    <a href="rD04632A218C37229.html">llvm::Register</a> Dst) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1731">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1731</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> InsPt</b></dt><dt class="is-family-code">const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp;<b> DL</b></dt><dt class="is-family-code"><a href="rD04632A218C37229.html">llvm::Register</a><b> Src</b></dt><dt class="is-family-code"><a href="rD04632A218C37229.html">llvm::Register</a><b> Dst</b></dt></dl><h3 id="9C51FE7425E4B7DD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9C51FE7425E4B7DD">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* createPHISourceCopy(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int InsPt,
    const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp; DL,
    <a href="rD04632A218C37229.html">llvm::Register</a> Src,
    unsigned int SrcSubReg,
    <a href="rD04632A218C37229.html">llvm::Register</a> Dst) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1741">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1741</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> InsPt</b></dt><dt class="is-family-code">const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp;<b> DL</b></dt><dt class="is-family-code"><a href="rD04632A218C37229.html">llvm::Register</a><b> Src</b></dt><dt class="is-family-code">unsigned int<b> SrcSubReg</b></dt><dt class="is-family-code"><a href="rD04632A218C37229.html">llvm::Register</a><b> Dst</b></dt></dl><h3 id="A6065D41930440D8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A6065D41930440D8">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="https://en.cppreference.com/w/cpp/utility/pair">std::pair</a>&lt;unsigned int, unsigned int&gt;
decomposeMachineOperandsTargetFlags(
    unsigned int) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1680">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1680</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> </b></dt></dl><h3 id="AD412D7808494342"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AD412D7808494342">¶</a><code class="hdoc-function-code language-cpp">unsigned int defaultDefLatency(
    const <a href="rAF8698858E59FDB0.html">llvm::MCSchedModel</a>&amp; SchedModel,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; DefMI) const</code></pre></h3><h4>Description</h4><p>Return the default expected latency for a def based on its opcode.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1482">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1482</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAF8698858E59FDB0.html">llvm::MCSchedModel</a>&amp;<b> SchedModel</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> DefMI</b></dt></dl><h3 id="4BCDE131FB1681A8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4BCDE131FB1681A8">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r6607998C23E31109.html">Optional</a>&lt;llvm::ParamLoadedValue&gt;
describeLoadedValue(const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
                    <a href="rD04632A218C37229.html">llvm::Register</a> Reg) const</code></pre></h3><h4>Description</h4><p>Produce the expression describing the \p MI loading a value into the physical register \p Reg. This hook should only be used with\p MIs belonging to VReg-less functions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1808">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1808</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="rD04632A218C37229.html">llvm::Register</a><b> Reg</b></dt></dl><h3 id="4FCC85ABC3157B35"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4FCC85ABC3157B35">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; duplicate(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int InsertBefore,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Orig) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L380">llvm/include/llvm/CodeGen/TargetInstrInfo.h:380</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> InsertBefore</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Orig</b></dt></dl><h3 id="04DE5F39A52DE6DE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#04DE5F39A52DE6DE">¶</a><code class="hdoc-function-code language-cpp">virtual bool expandPostRAPseudo(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>This function is called for all pseudo instructions that remain after register allocation. Many pseudo instructions are created to help register allocation. This is the place to convert them into real instructions. The target can edit MI in place, or it can insert new instructions and erase MI. The function should return true if anything was changed.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1002">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1002</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="F8758553A1A8BFEB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F8758553A1A8BFEB">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int
extraSizeToPredicateInstructions(
    const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF,
    unsigned int NumInsts) const</code></pre></h3><h4>Description</h4><p>Return the increase in code size needed to predicate a contiguous run of NumInsts instructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L802">llvm/include/llvm/CodeGen/TargetInstrInfo.h:802</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt><dt class="is-family-code">unsigned int<b> NumInsts</b></dt></dl><h3 id="1E918D0F0F2FC7A2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1E918D0F0F2FC7A2">¶</a><code class="hdoc-function-code language-cpp">virtual bool findCommutedOpIndices(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int&amp; SrcOpIdx1,
    unsigned int&amp; SrcOpIdx2) const</code></pre></h3><h4>Description</h4><p>Returns true iff the routine could find two commutable operands in the given machine instruction. The &apos;SrcOpIdx1&apos; and &apos;SrcOpIdx2&apos; are INPUT and OUTPUT arguments. If any of the INPUT values is set to the special value &apos;CommuteAnyOperandIndex&apos; then the method arbitrarily picks a commutable operand, then returns its index in the corresponding argument. If both of INPUT values are set to &apos;CommuteAnyOperandIndex&apos; then method looks for 2 commutable operands. If INPUT values refer to some operands of MI, then the method simply returns true if the corresponding operands are commutable and returns false otherwise. For example, calling this method this way: unsigned Op1 = 1, Op2 = CommuteAnyOperandIndex; findCommutedOpIndices(MI, Op1, Op2); can be interpreted as a query asking to find an operand that would be commutable with the operand#1.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L444">llvm/include/llvm/CodeGen/TargetInstrInfo.h:444</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int&amp;<b> SrcOpIdx1</b></dt><dt class="is-family-code">unsigned int&amp;<b> SrcOpIdx2</b></dt></dl><h3 id="1595B568FAE49E7D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1595B568FAE49E7D">¶</a><code class="hdoc-function-code language-cpp">static bool fixCommutedOpIndices(
    unsigned int&amp; ResultIdx1,
    unsigned int&amp; ResultIdx2,
    unsigned int CommutableOpIdx1,
    unsigned int CommutableOpIdx2)</code></pre></h3><h4>Description</h4><p>Assigns the (CommutableOpIdx1, CommutableOpIdx2) pair of commutable operand indices to (ResultIdx1, ResultIdx2). One or both input values of the pair: (ResultIdx1, ResultIdx2) may be predefined to some indices or be undefined (designated by the special value &apos;CommuteAnyOperandIndex&apos;). The predefined result indices cannot be re-defined. The function returns true iff after the result pair redefinition the fixed result pair is equal to or equivalent to the source pair of indices: (CommutableOpIdx1, CommutableOpIdx2). It is assumed here that the pairs (x,y) and (y,x) are equivalent.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L166">llvm/include/llvm/CodeGen/TargetInstrInfo.h:166</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int&amp;<b> ResultIdx1</b></dt><dt class="is-family-code">unsigned int&amp;<b> ResultIdx2</b></dt><dt class="is-family-code">unsigned int<b> CommutableOpIdx1</b></dt><dt class="is-family-code">unsigned int<b> CommutableOpIdx2</b></dt></dl><h3 id="BBAF36E5A0CF1355"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BBAF36E5A0CF1355">¶</a><code class="hdoc-function-code language-cpp"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* foldMemoryOperand(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt; Ops,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; LoadMI,
    <a href="r43A712DB60885334.html">llvm::LiveIntervals</a>* LIS = nullptr) const</code></pre></h3><h4>Description</h4><p>Same as the previous version except it allows folding of any load and store from / to any address, not just from a specific stack slot.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1033">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1033</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt;<b> Ops</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> LoadMI</b></dt><dt class="is-family-code"><a href="r43A712DB60885334.html">llvm::LiveIntervals</a>*<b> LIS</b> = nullptr</dt></dl><h3 id="F329546B8B19E196"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F329546B8B19E196">¶</a><code class="hdoc-function-code language-cpp"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* foldMemoryOperand(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt; Ops,
    int FI,
    <a href="r43A712DB60885334.html">llvm::LiveIntervals</a>* LIS = nullptr,
    <a href="r814F850CF5F21E80.html">llvm::VirtRegMap</a>* VRM = nullptr) const</code></pre></h3><h4>Description</h4><p>Attempt to fold a load or store of the specified stack slot into the specified machine instruction for the specified operand(s). If this is possible, a new instruction is returned with the specified operand folded, otherwise NULL is returned. The new instruction is inserted before MI, and the client is responsible for removing the old instruction. If VRM is passed, the assigned physregs can be inspected by target to decide on using an opcode (note that those assignments can still change).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1026">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1026</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt;<b> Ops</b></dt><dt class="is-family-code">int<b> FI</b></dt><dt class="is-family-code"><a href="r43A712DB60885334.html">llvm::LiveIntervals</a>*<b> LIS</b> = nullptr</dt><dt class="is-family-code"><a href="r814F850CF5F21E80.html">llvm::VirtRegMap</a>*<b> VRM</b> = nullptr</dt></dl><h3 id="5729AB6B8A4BB851"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5729AB6B8A4BB851">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* foldMemoryOperandImpl(
    <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt; Ops,
    int InsertPt,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; LoadMI,
    <a href="r43A712DB60885334.html">llvm::LiveIntervals</a>* LIS = nullptr) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1129">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1129</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt;<b> Ops</b></dt><dt class="is-family-code">int<b> InsertPt</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> LoadMI</b></dt><dt class="is-family-code"><a href="r43A712DB60885334.html">llvm::LiveIntervals</a>*<b> LIS</b> = nullptr</dt></dl><h3 id="07A95581B7809154"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#07A95581B7809154">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* foldMemoryOperandImpl(
    <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt; Ops,
    int InsertPt,
    int FrameIndex,
    <a href="r43A712DB60885334.html">llvm::LiveIntervals</a>* LIS = nullptr,
    <a href="r814F850CF5F21E80.html">llvm::VirtRegMap</a>* VRM = nullptr) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1116">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1116</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt;<b> Ops</b></dt><dt class="is-family-code">int<b> InsertPt</b></dt><dt class="is-family-code">int<b> FrameIndex</b></dt><dt class="is-family-code"><a href="r43A712DB60885334.html">llvm::LiveIntervals</a>*<b> LIS</b> = nullptr</dt><dt class="is-family-code"><a href="r814F850CF5F21E80.html">llvm::VirtRegMap</a>*<b> VRM</b> = nullptr</dt></dl><h3 id="0868CC2E00132239"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0868CC2E00132239">¶</a><code class="hdoc-function-code language-cpp">virtual void genAlternativeCodeSequence(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Root,
    llvm::MachineCombinerPattern Pattern,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;
        InsInstrs,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;
        DelInstrs,
    int&amp; InstIdxForVirtReg) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1082">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1082</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Root</b></dt><dt class="is-family-code">llvm::MachineCombinerPattern<b> Pattern</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;<b> InsInstrs</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;<b> DelInstrs</b></dt><dt class="is-family-code">int&amp;<b> InstIdxForVirtReg</b></dt></dl><h3 id="78B41549F895C144"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#78B41549F895C144">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int
getAddressSpaceForPseudoSourceKind(
    unsigned int Kind) const</code></pre></h3><h4>Description</h4><p>getAddressSpaceForPseudoSourceKind - Given the kind of memory (e.g. stack) the target returns the corresponding address space.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1183">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1183</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Kind</b></dt></dl><h3 id="0CDFFC1289883C67"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0CDFFC1289883C67">¶</a><code class="hdoc-function-code language-cpp">virtual bool getBaseAndOffsetPosition(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int&amp; BasePos,
    unsigned int&amp; OffsetPos) const</code></pre></h3><h4>Description</h4><p>Return true if the instruction contains a base register and offset. If true, the function also sets the operand position in the instruction for the base register and offset.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1254">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1254</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int&amp;<b> BasePos</b></dt><dt class="is-family-code">unsigned int&amp;<b> OffsetPos</b></dt></dl><h3 id="BF23A524296B6D82"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BF23A524296B6D82">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>*
getBranchDestBlock(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L554">llvm/include/llvm/CodeGen/TargetInstrInfo.h:554</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h4>Returns</h4><p>The block that branch instruction \p MI jumps to.</p><h3 id="8D8FA1B3A4919DFB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8D8FA1B3A4919DFB">¶</a><code class="hdoc-function-code language-cpp">unsigned int getCallFrameDestroyOpcode() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L185">llvm/include/llvm/CodeGen/TargetInstrInfo.h:185</a></p><h3 id="EE1B48518EEAB9FF"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EE1B48518EEAB9FF">¶</a><code class="hdoc-function-code language-cpp">unsigned int getCallFrameSetupOpcode() const</code></pre></h3><h4>Description</h4><p>These methods return the opcode of the frame setup/destroy instructions if they exist (-1 otherwise).  Some targets use pseudo instructions in order to abstract away the difference between operating with a frame pointer and operating without, through the use of these two instructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L184">llvm/include/llvm/CodeGen/TargetInstrInfo.h:184</a></p><h3 id="DFF7DC95DAF3EF01"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DFF7DC95DAF3EF01">¶</a><code class="hdoc-function-code language-cpp">unsigned int getCatchReturnOpcode() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L224">llvm/include/llvm/CodeGen/TargetInstrInfo.h:224</a></p><h3 id="F466F42F72B98829"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F466F42F72B98829">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="https://en.cppreference.com/w/cpp/utility/pair">std::pair</a>&lt;uint16_t, uint16_t&gt;
getExecutionDomain(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1536">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1536</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="71FBB04B4195E5B5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#71FBB04B4195E5B5">¶</a><code class="hdoc-function-code language-cpp">bool getExtractSubregInputs(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int DefIdx,
    <a href="r049A4661B07F1EA4.html">llvm::TargetInstrInfo::RegSubRegPairAndIdx</a>&amp;
        InputReg) const</code></pre></h3><h4>Description</h4><p>Build the equivalent inputs of a EXTRACT_SUBREG for the given \p MI and \p DefIdx. \p [out] InputReg of the equivalent EXTRACT_SUBREG. E.g., EXTRACT_SUBREG %1:sub1, sub0, sub1 would produce: - %1:sub1, sub0</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L513">llvm/include/llvm/CodeGen/TargetInstrInfo.h:513</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt><dt class="is-family-code"><a href="r049A4661B07F1EA4.html">llvm::TargetInstrInfo::RegSubRegPairAndIdx</a>&amp;<b> InputReg</b></dt></dl><h4>Returns</h4><p>true if it is possible to build such an input sequence with the pair \p MI, \p DefIdx and the operand has no undef flag set. False otherwise.</p><h3 id="CCC87852C39F598C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CCC87852C39F598C">¶</a><code class="hdoc-function-code language-cpp">virtual bool getExtractSubregLikeInputs(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int DefIdx,
    <a href="r049A4661B07F1EA4.html">llvm::TargetInstrInfo::RegSubRegPairAndIdx</a>&amp;
        InputReg) const</code></pre></h3><h4>Description</h4><p>Target-dependent implementation of getExtractSubregInputs.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1158">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1158</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt><dt class="is-family-code"><a href="r049A4661B07F1EA4.html">llvm::TargetInstrInfo::RegSubRegPairAndIdx</a>&amp;<b> InputReg</b></dt></dl><h4>Returns</h4><p>true if it is possible to build the equivalent EXTRACT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</p><h3 id="737355150B529623"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#737355150B529623">¶</a><code class="hdoc-function-code language-cpp">int64_t getFrameSize(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; I) const</code></pre></h3><h4>Description</h4><p>Returns size of the frame associated with the given frame instruction. For frame setup instruction this is frame that is set up space set up after the instruction. For frame destroy instruction this is the frame freed by the caller. Note, in some cases a call frame (or a part of it) may be prepared prior to the frame setup instruction. It occurs in the calls that involve inalloca arguments. This function reports only the size of the frame part that is set up between the frame setup and destroy pseudo instructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L206">llvm/include/llvm/CodeGen/TargetInstrInfo.h:206</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> I</b></dt></dl><h3 id="B15EA38325F98524"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B15EA38325F98524">¶</a><code class="hdoc-function-code language-cpp">int64_t getFrameTotalSize(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; I) const</code></pre></h3><h4>Description</h4><p>Returns the total frame size, which is made up of the space set up inside the pair of frame start-stop instructions and the space that is set up prior to the pair.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L215">llvm/include/llvm/CodeGen/TargetInstrInfo.h:215</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> I</b></dt></dl><h3 id="D41E19802902458E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D41E19802902458E">¶</a><code class="hdoc-function-code language-cpp">virtual bool getIncrementValue(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    int&amp; Value) const</code></pre></h3><h4>Description</h4><p>If the instruction is an increment of a constant value, return the amount.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1261">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1261</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">int&amp;<b> Value</b></dt></dl><h3 id="A27A0FAADBB654AD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A27A0FAADBB654AD">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int getInlineAsmLength(
    const char* Str,
    const <a href="r2B8DFC4A269F6C90.html">llvm::MCAsmInfo</a>&amp; MAI,
    const <a href="rB76DF6D82BF57FB2.html">llvm::TargetSubtargetInfo</a>* STI =
        nullptr) const</code></pre></h3><h4>Description</h4><p>Measure the specified inline asm to determine an approximation of its length.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1360">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1360</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const char*<b> Str</b></dt><dt class="is-family-code">const <a href="r2B8DFC4A269F6C90.html">llvm::MCAsmInfo</a>&amp;<b> MAI</b></dt><dt class="is-family-code">const <a href="rB76DF6D82BF57FB2.html">llvm::TargetSubtargetInfo</a>*<b> STI</b> = nullptr</dt></dl><h3 id="7D66956C93F360A0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7D66956C93F360A0">¶</a><code class="hdoc-function-code language-cpp">bool getInsertSubregInputs(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int DefIdx,
    <a href="rC18380D1E05FB461.html">llvm::TargetInstrInfo::RegSubRegPair</a>&amp; BaseReg,
    <a href="r049A4661B07F1EA4.html">llvm::TargetInstrInfo::RegSubRegPairAndIdx</a>&amp;
        InsertedReg) const</code></pre></h3><h4>Description</h4><p>Build the equivalent inputs of a INSERT_SUBREG for the given \p MI and \p DefIdx. \p [out] BaseReg and \p [out] InsertedReg contain the equivalent inputs of INSERT_SUBREG. E.g., INSERT_SUBREG %0:sub0, %1:sub1, sub3 would produce: - BaseReg: %0:sub0 - InsertedReg: %1:sub1, sub3</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L533">llvm/include/llvm/CodeGen/TargetInstrInfo.h:533</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt><dt class="is-family-code"><a href="rC18380D1E05FB461.html">llvm::TargetInstrInfo::RegSubRegPair</a>&amp;<b> BaseReg</b></dt><dt class="is-family-code"><a href="r049A4661B07F1EA4.html">llvm::TargetInstrInfo::RegSubRegPairAndIdx</a>&amp;<b> InsertedReg</b></dt></dl><h4>Returns</h4><p>true if it is possible to build such an input sequence with the pair \p MI, \p DefIdx and the operand has no undef flag set. False otherwise.</p><h3 id="07406C48B7ED5EF4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#07406C48B7ED5EF4">¶</a><code class="hdoc-function-code language-cpp">virtual bool getInsertSubregLikeInputs(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int DefIdx,
    <a href="rC18380D1E05FB461.html">llvm::TargetInstrInfo::RegSubRegPair</a>&amp; BaseReg,
    <a href="r049A4661B07F1EA4.html">llvm::TargetInstrInfo::RegSubRegPairAndIdx</a>&amp;
        InsertedReg) const</code></pre></h3><h4>Description</h4><p>Target-dependent implementation of getInsertSubregInputs.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1173">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1173</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt><dt class="is-family-code"><a href="rC18380D1E05FB461.html">llvm::TargetInstrInfo::RegSubRegPair</a>&amp;<b> BaseReg</b></dt><dt class="is-family-code"><a href="r049A4661B07F1EA4.html">llvm::TargetInstrInfo::RegSubRegPairAndIdx</a>&amp;<b> InsertedReg</b></dt></dl><h4>Returns</h4><p>true if it is possible to build the equivalent INSERT_SUBREG inputs with the pair \p MI, \p DefIdx. False otherwise.</p><h3 id="B3BDA923334B5283"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B3BDA923334B5283">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int getInstSizeInBytes(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Returns the size in bytes of the specified MachineInstr, or ~0U when this function is not implemented by a target.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L346">llvm/include/llvm/CodeGen/TargetInstrInfo.h:346</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="440C82515D87CAFC"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#440C82515D87CAFC">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int getInstrLatency(
    const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>* ItinData,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int* PredCost = nullptr) const</code></pre></h3><h4>Description</h4><p>Compute the instruction latency of a given instruction. If the instruction has higher cost when predicated, it&apos;s returned via PredCost.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1472">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1472</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*<b> ItinData</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int*<b> PredCost</b> = nullptr</dt></dl><h3 id="3A4DC868F0B43753"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3A4DC868F0B43753">¶</a><code class="hdoc-function-code language-cpp">virtual int getInstrLatency(
    const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>* ItinData,
    <a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>* Node) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1478">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1478</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*<b> ItinData</b></dt><dt class="is-family-code"><a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>*<b> Node</b></dt></dl><h3 id="FBCACBA3371172D0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FBCACBA3371172D0">¶</a><code class="hdoc-function-code language-cpp">virtual const <a href="r614630F95B375A8D.html">llvm::MIRFormatter</a>*
getMIRFormatter() const</code></pre></h3><h4>Description</h4><p>Return MIR formatter to format/parse MIR operands.  Target can override this virtual function and return target specific MIR formatter.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1813">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1813</a></p><h3 id="F1B899D044721D3E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F1B899D044721D3E">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int getMachineCSELookAheadLimit()
    const</code></pre></h3><h4>Description</h4><p>Return the value to use for the MachineCSE&apos;s LookAheadLimit, which is a heuristic used for CSE&apos;ing phys reg defs.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1661">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1661</a></p><h3 id="0486985A226663CA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0486985A226663CA">¶</a><code class="hdoc-function-code language-cpp">virtual bool getMachineCombinerPatterns(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Root,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineCombinerPattern&gt;&amp;
        Patterns) const</code></pre></h3><h4>Description</h4><p>Return true when there is potentially a faster code sequence for an instruction chain ending in \p Root. All potential patterns are returned in the \p Pattern vector. Pattern should be sorted in priority order since the pattern evaluator stops checking as soon as it finds a faster sequence.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1044">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1044</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Root</b></dt><dd>- Instruction that could be combined with one of its operands</dd><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineCombinerPattern&gt;&amp;<b> Patterns</b></dt><dd>- Vector of possible combination patterns</dd></dl><h3 id="BE4189A1FB31753D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BE4189A1FB31753D">¶</a><code class="hdoc-function-code language-cpp">virtual bool getMemOperandWithOffset(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    const llvm::MachineOperand*&amp; BaseOp,
    int64_t&amp; Offset,
    const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>* TRI) const</code></pre></h3><h4>Description</h4><p>Get the base operand and byte offset of an instruction that reads/writes memory. It returns false if MI does not read/write memory. It returns false if no base operand and offset was found. It is not guaranteed to always recognize base operand and offsets in all cases.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1244">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1244</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">const llvm::MachineOperand*&amp;<b> BaseOp</b></dt><dt class="is-family-code">int64_t&amp;<b> Offset</b></dt><dt class="is-family-code">const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>*<b> TRI</b></dt></dl><h3 id="C12B7C57636E43BA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C12B7C57636E43BA">¶</a><code class="hdoc-function-code language-cpp">virtual void getNoop(<a href="r78690FB992665B6F.html">llvm::MCInst</a>&amp; NopInst) const</code></pre></h3><h4>Description</h4><p>Return the noop instruction to use for a noop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1289">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1289</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r78690FB992665B6F.html">llvm::MCInst</a>&amp;<b> NopInst</b></dt></dl><h3 id="FAD534F460F14502"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FAD534F460F14502">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int getNumMicroOps(
    const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>* ItinData,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Return the number of u-operations the given machine instruction will be decoded to on the target cpu. The itinerary&apos;s IssueWidth is the number of microops that can be dispatched each cycle. An instruction with zero microops takes no dispatch resources.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1441">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1441</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*<b> ItinData</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="95D7C13E25D7B874"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#95D7C13E25D7B874">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int getOpcodeAfterMemoryUnfold(
    unsigned int Opc,
    bool UnfoldLoad,
    bool UnfoldStore,
    unsigned int* LoadRegIndex = nullptr) const</code></pre></h3><h4>Description</h4><p>Returns the opcode of the would be new instruction after load / store are unfolded from an instruction of the specified opcode. It returns zero if the specified unfolding is not possible. If LoadRegIndex is non-null, it is filled in with the operand index of the operand which will hold the register holding the loaded value.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1209">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1209</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opc</b></dt><dt class="is-family-code">bool<b> UnfoldLoad</b></dt><dt class="is-family-code">bool<b> UnfoldStore</b></dt><dt class="is-family-code">unsigned int*<b> LoadRegIndex</b> = nullptr</dt></dl><h3 id="58955C5CDD7FABED"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#58955C5CDD7FABED">¶</a><code class="hdoc-function-code language-cpp">virtual int getOperandLatency(
    const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>* ItinData,
    <a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>* DefNode,
    unsigned int DefIdx,
    <a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>* UseNode,
    unsigned int UseIdx) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1452">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1452</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*<b> ItinData</b></dt><dt class="is-family-code"><a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>*<b> DefNode</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt><dt class="is-family-code"><a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>*<b> UseNode</b></dt><dt class="is-family-code">unsigned int<b> UseIdx</b></dt></dl><h3 id="5CB3036539192235"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5CB3036539192235">¶</a><code class="hdoc-function-code language-cpp">virtual int getOperandLatency(
    const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>* ItinData,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; DefMI,
    unsigned int DefIdx,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; UseMI,
    unsigned int UseIdx) const</code></pre></h3><h4>Description</h4><p>Compute and return the use operand latency of a given pair of def and use. In most cases, the static scheduling itinerary was enough to determine the operand latency. But it may not be possible for instructions with variable number of defs / uses. This is a raw interface to the itinerary that may be directly overridden by a target. Use computeOperandLatency to get the best estimate of latency.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1464">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1464</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rA77BF58889E0174E.html">llvm::InstrItineraryData</a>*<b> ItinData</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> DefMI</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> UseMI</b></dt><dt class="is-family-code">unsigned int<b> UseIdx</b></dt></dl><h3 id="04C10D86D580FAC0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#04C10D86D580FAC0">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r4BC44A554EC83894.html">outliner::OutlinedFunction</a>
getOutliningCandidateInfo(
    int&amp; RepeatedSequenceLocs) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1752">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1752</a></p><h4>Parameters</h4><dl><dt class="is-family-code">int&amp;<b> RepeatedSequenceLocs</b></dt></dl><h3 id="BBA0BEE47AEE6FF9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BBA0BEE47AEE6FF9">¶</a><code class="hdoc-function-code language-cpp">virtual outliner::InstrType getOutliningType(
    int&amp; MIT,
    unsigned int Flags) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1760">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1760</a></p><h4>Parameters</h4><dl><dt class="is-family-code">int&amp;<b> MIT</b></dt><dt class="is-family-code">unsigned int<b> Flags</b></dt></dl><h3 id="E48CBABF3E31BAD2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E48CBABF3E31BAD2">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int getPartialRegUpdateClearance(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int OpNum,
    const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>* TRI) const</code></pre></h3><h4>Description</h4><p>Returns the preferred minimum clearance before an instruction with an unwanted partial register update. Some instructions only write part of a register, and implicitly need to read the other parts of the register.  This may cause unwanted stalls preventing otherwise unrelated instructions from executing in parallel in an out-of-order CPU. For example, the x86 instruction cvtsi2ss writes its result to bits [31:0] of the destination xmm register. Bits [127:32] are unaffected, so the instruction needs to wait for the old value of the register to become available: addps %xmm1, %xmm0 movaps %xmm0, (%rax) cvtsi2ss %rbx, %xmm0 In the code above, the cvtsi2ss instruction needs to wait for the addps instruction before it can issue, even though the high bits of %xmm0 probably aren&apos;t needed. This hook returns the preferred clearance before MI, measured in instructions.  Other defs of MI&apos;s operand OpNum are avoided in the last N instructions before MI.  It should only return a positive value for unwanted dependencies.  If the old bits of the defined register have useful values, or if MI is determined to otherwise read the dependency, the hook should return 0. The unwanted dependency may be handled by: 1. Allocating the same register for an MI def and use.  That makes the unwanted dependency identical to a required dependency. 2. Allocating a register for the def that has no defs in the previous N instructions. 3. Calling breakPartialRegDependency() with the same arguments.  This allows the target to insert a dependency breaking instruction.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1586">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1586</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> OpNum</b></dt><dt class="is-family-code">const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>*<b> TRI</b></dt></dl><h3 id="2ACAA758A0A057CD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2ACAA758A0A057CD">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int getPredicationCost(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1476">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1476</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="088E134B3ADD7490"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#088E134B3ADD7490">¶</a><code class="hdoc-function-code language-cpp">virtual const <a href="r413242C5B6D720F3.html">llvm::TargetRegisterClass</a>*
getRegClass(const <a href="r0E6C58CB0903B7E5.html">llvm::MCInstrDesc</a>&amp; MCID,
            unsigned int OpNum,
            const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>* TRI,
            const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF) const</code></pre></h3><h4>Description</h4><p>Given a machine instruction descriptor, returns the register class constraint for OpNum, or NULL.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L107">llvm/include/llvm/CodeGen/TargetInstrInfo.h:107</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0E6C58CB0903B7E5.html">llvm::MCInstrDesc</a>&amp;<b> MCID</b></dt><dt class="is-family-code">unsigned int<b> OpNum</b></dt><dt class="is-family-code">const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>*<b> TRI</b></dt><dt class="is-family-code">const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt></dl><h3 id="5FDE3BA1711EA907"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5FDE3BA1711EA907">¶</a><code class="hdoc-function-code language-cpp">bool getRegSequenceInputs(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int DefIdx,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::TargetInstrInfo::
                        RegSubRegPairAndIdx&gt;&amp;
        InputRegs) const</code></pre></h3><h4>Description</h4><p>Build the equivalent inputs of a REG_SEQUENCE for the given \p MI and \p DefIdx. \p [out] InputRegs of the equivalent REG_SEQUENCE. Each element of the list is modeled as  &lt;Reg :SubReg, SubIdx&gt;. Operands with the undef flag are not added to this list. E.g., REG_SEQUENCE %1:sub1, sub0, %2, sub1 would produce two elements: - %1:sub1, sub0 - %2 &lt; :0&gt;, sub1</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L495">llvm/include/llvm/CodeGen/TargetInstrInfo.h:495</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;
    llvm::TargetInstrInfo::RegSubRegPairAndIdx&gt;&amp;<b> InputRegs</b></dt></dl><h4>Returns</h4><p>true if it is possible to build such an input sequence with the pair \p MI, \p DefIdx. False otherwise.</p><h3 id="9C926D4CDD130F6E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9C926D4CDD130F6E">¶</a><code class="hdoc-function-code language-cpp">virtual bool getRegSequenceLikeInputs(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int DefIdx,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::TargetInstrInfo::
                        RegSubRegPairAndIdx&gt;&amp;
        InputRegs) const</code></pre></h3><h4>Description</h4><p>Target-dependent implementation of getRegSequenceInputs.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1144">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1144</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;
    llvm::TargetInstrInfo::RegSubRegPairAndIdx&gt;&amp;<b> InputRegs</b></dt></dl><h4>Returns</h4><p>true if it is possible to build the equivalent REG_SEQUENCE inputs with the pair \p MI, \p DefIdx. False otherwise.</p><h3 id="F8FD39E1F547492C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F8FD39E1F547492C">¶</a><code class="hdoc-function-code language-cpp">unsigned int getReturnOpcode() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L225">llvm/include/llvm/CodeGen/TargetInstrInfo.h:225</a></p><h3 id="02E02C3D94B232AB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#02E02C3D94B232AB">¶</a><code class="hdoc-function-code language-cpp">virtual int getSPAdjust(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Returns the actual stack pointer adjustment made by an instruction as part of a call sequence. By default, only call frame setup/destroy instructions adjust the stack, but targets may want to override this to enable more fine-grained adjustment, or adjust by a different value.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L231">llvm/include/llvm/CodeGen/TargetInstrInfo.h:231</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="11B56A028A9171F9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#11B56A028A9171F9">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;
    std::pair&lt;unsigned int, const char*&gt;&gt;
getSerializableBitmaskMachineOperandTargetFlags()
    const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1700">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1700</a></p><h3 id="1BE40696F7360515"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1BE40696F7360515">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;
    std::pair&lt;unsigned int, const char*&gt;&gt;
getSerializableDirectMachineOperandTargetFlags()
    const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1690">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1690</a></p><h3 id="02E8973675BC192E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#02E8973675BC192E">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;
    std::pair&lt;MachineMemOperand::Flags,
              const char*&gt;&gt;
getSerializableMachineMemOperandTargetFlags()
    const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1710">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1710</a></p><h3 id="23549D14B4BCC5B7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#23549D14B4BCC5B7">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;std::pair&lt;int, const char*&gt;&gt;
getSerializableTargetIndices() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1673">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1673</a></p><h3 id="C9F80918FBA60C48"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C9F80918FBA60C48">¶</a><code class="hdoc-function-code language-cpp">virtual bool getStackSlotRange(
    const <a href="r413242C5B6D720F3.html">llvm::TargetRegisterClass</a>* RC,
    unsigned int SubIdx,
    unsigned int&amp; Size,
    unsigned int&amp; Offset,
    const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF) const</code></pre></h3><h4>Description</h4><p>Compute the size in bytes and offset within a stack slot of a spilled register or subregister. Not all subregisters have computable spill slots. For example, subregisters registers may not be byte-sized, and a pair of discontiguous subregisters has no single offset. Targets with nontrivial bigendian implementations may need to override this, particularly to support spilled vector registers.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L340">llvm/include/llvm/CodeGen/TargetInstrInfo.h:340</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r413242C5B6D720F3.html">llvm::TargetRegisterClass</a>*<b> RC</b></dt><dt class="is-family-code">unsigned int<b> SubIdx</b></dt><dt class="is-family-code">unsigned int&amp;<b> Size</b></dt><dd>in bytes of the spilled value.</dd><dt class="is-family-code">unsigned int&amp;<b> Offset</b></dt><dd>in bytes within the stack slot.</dd><dt class="is-family-code">const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt></dl><h4>Returns</h4><p>true if both Size and Offset are successfully computed.</p><h3 id="A3292AE5F14F3540"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A3292AE5F14F3540">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int getUndefRegClearance(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int&amp; OpNum,
    const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>* TRI) const</code></pre></h3><h4>Description</h4><p>Return the minimum clearance before an instruction that reads an unused register. For example, AVX instructions may copy part of a register operand into the unused high bits of the destination register. vcvtsi2sdq %rax, undef %xmm0, %xmm14 In the code above, vcvtsi2sdq copies %xmm0[127:64] into %xmm14 creating a false dependence on any previous write to %xmm0. This hook works similarly to getPartialRegUpdateClearance, except that it does not take an operand index. Instead sets \p OpNum to the index of the unused register.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1606">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1606</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int&amp;<b> OpNum</b></dt><dt class="is-family-code">const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>*<b> TRI</b></dt></dl><h3 id="4DB5D03BB33238F4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4DB5D03BB33238F4">¶</a><code class="hdoc-function-code language-cpp">virtual bool hasHighOperandLatency(
    const <a href="r8994228CE2DFC5C6.html">llvm::TargetSchedModel</a>&amp; SchedModel,
    const <a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>* MRI,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; DefMI,
    unsigned int DefIdx,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; UseMI,
    unsigned int UseIdx) const</code></pre></h3><h4>Description</h4><p>Compute operand latency between a def of &apos;Reg&apos; and a use in the current loop. Return true if the target considered it &apos;high&apos;. This is used by optimization passes such as machine LICM to determine whether it makes sense to hoist an instruction out even in a high register pressure situation.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1496">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1496</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r8994228CE2DFC5C6.html">llvm::TargetSchedModel</a>&amp;<b> SchedModel</b></dt><dt class="is-family-code">const <a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>*<b> MRI</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> DefMI</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> UseMI</b></dt><dt class="is-family-code">unsigned int<b> UseIdx</b></dt></dl><h3 id="7B51A8438FF51DF0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7B51A8438FF51DF0">¶</a><code class="hdoc-function-code language-cpp">virtual bool hasLoadFromStackSlot(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;
        const llvm::MachineMemOperand*&gt;&amp; Accesses)
    const</code></pre></h3><h4>Description</h4><p>If the specified machine instruction has a load from a stack slot, return true along with the FrameIndices of the loaded stack slot and the machine mem operands containing the reference. If not, return false.  Unlike isLoadFromStackSlot, this returns true for any instructions that loads from the stack.  This is just a hint, as some cases may be missed.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L277">llvm/include/llvm/CodeGen/TargetInstrInfo.h:277</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::MachineMemOperand*&gt;&amp;<b> Accesses</b></dt></dl><h3 id="02BEC6B34B685DA1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#02BEC6B34B685DA1">¶</a><code class="hdoc-function-code language-cpp">virtual bool hasLowDefLatency(
    const <a href="r8994228CE2DFC5C6.html">llvm::TargetSchedModel</a>&amp; SchedModel,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; DefMI,
    unsigned int DefIdx) const</code></pre></h3><h4>Description</h4><p>Compute operand latency of a def of &apos;Reg&apos;. Return true if the target considered it &apos;low&apos;.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1506">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1506</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r8994228CE2DFC5C6.html">llvm::TargetSchedModel</a>&amp;<b> SchedModel</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> DefMI</b></dt><dt class="is-family-code">unsigned int<b> DefIdx</b></dt></dl><h3 id="34A133FA5F300714"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#34A133FA5F300714">¶</a><code class="hdoc-function-code language-cpp">virtual bool hasReassociableOperands(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Inst,
    const <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>* MBB) const</code></pre></h3><h4>Description</h4><p>Return true when \PInst has reassociable operands in the same \PMBB.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1066">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1066</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Inst</b></dt><dt class="is-family-code">const <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>*<b> MBB</b></dt></dl><h3 id="E7EFC5D4EBBFE62F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E7EFC5D4EBBFE62F">¶</a><code class="hdoc-function-code language-cpp">bool hasReassociableSibling(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Inst,
    bool&amp; Commuted) const</code></pre></h3><h4>Description</h4><p>Return true when \PInst has reassociable sibling.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1070">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1070</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Inst</b></dt><dt class="is-family-code">bool&amp;<b> Commuted</b></dt></dl><h3 id="2CDEBA900645A049"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2CDEBA900645A049">¶</a><code class="hdoc-function-code language-cpp">virtual bool hasStoreToStackSlot(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;
        const llvm::MachineMemOperand*&gt;&amp; Accesses)
    const</code></pre></h3><h4>Description</h4><p>If the specified machine instruction has a store to a stack slot, return true along with the FrameIndices of the loaded stack slot and the machine mem operands containing the reference. If not, return false.  Unlike isStoreToStackSlot, this returns true for any instructions that stores to the stack.  This is just a hint, as some cases may be missed.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L315">llvm/include/llvm/CodeGen/TargetInstrInfo.h:315</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::MachineMemOperand*&gt;&amp;<b> Accesses</b></dt></dl><h3 id="CA789FEED214030A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CA789FEED214030A">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int insertBranch(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>* TBB,
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>* FBB,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt; Cond,
    const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp; DL,
    int* BytesAdded = nullptr) const</code></pre></h3><h4>Description</h4><p>Insert branch code into the end of the specified MachineBasicBlock. The operands to this method are the same as those returned by AnalyzeBranch. This is only invoked in cases where AnalyzeBranch returns success. It returns the number of instructions inserted. If \p BytesAdded is non-null, report the change in code size from the added instructions. It is also invoked by tail merging to add unconditional branches in cases where AnalyzeBranch doesn&apos;t apply because there was no original branch to analyze.  At least this much must be implemented, else tail merging needs to be disabled. The CFG information in MBB.Predecessors and MBB.Successors must be valid before calling this function.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L669">llvm/include/llvm/CodeGen/TargetInstrInfo.h:669</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>*<b> TBB</b></dt><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>*<b> FBB</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt;<b> Cond</b></dt><dt class="is-family-code">const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp;<b> DL</b></dt><dt class="is-family-code">int*<b> BytesAdded</b> = nullptr</dt></dl><h3 id="67CA814328F7D03C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#67CA814328F7D03C">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int insertIndirectBranch(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; NewDestBB,
    const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp; DL,
    int64_t BrOffset = 0,
    <a href="r59813A66BE126E3D.html">llvm::RegScavenger</a>* RS = nullptr) const</code></pre></h3><h4>Description</h4><p>Insert an unconditional indirect branch at the end of \p MBB to \p NewDestBB. \p BrOffset indicates the offset of \p NewDestBB relative to the offset of the position to insert the new branch.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L563">llvm/include/llvm/CodeGen/TargetInstrInfo.h:563</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> NewDestBB</b></dt><dt class="is-family-code">const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp;<b> DL</b></dt><dt class="is-family-code">int64_t<b> BrOffset</b> = 0</dt><dt class="is-family-code"><a href="r59813A66BE126E3D.html">llvm::RegScavenger</a>*<b> RS</b> = nullptr</dt></dl><h4>Returns</h4><p>The number of bytes added to the block.</p><h3 id="69A68CA61E8EFEDA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#69A68CA61E8EFEDA">¶</a><code class="hdoc-function-code language-cpp">virtual void insertNoop(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int MI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1285">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1285</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> MI</b></dt></dl><h3 id="43F75ACD3A729BF2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#43F75ACD3A729BF2">¶</a><code class="hdoc-function-code language-cpp">int insertOutlinedCall(
    <a href="r1428BC327E1751C3.html">llvm::Module</a>&amp; M,
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int&amp; It,
    <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF,
    const <a href="rE0A2BF96FE865AEF.html">outliner::Candidate</a>&amp; C) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1783">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1783</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r1428BC327E1751C3.html">llvm::Module</a>&amp;<b> M</b></dt><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int&amp;<b> It</b></dt><dt class="is-family-code"><a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt><dt class="is-family-code">const <a href="rE0A2BF96FE865AEF.html">outliner::Candidate</a>&amp;<b> C</b></dt></dl><h3 id="A2DBFB771E35EE77"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A2DBFB771E35EE77">¶</a><code class="hdoc-function-code language-cpp">virtual void insertSelect(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int I,
    const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp; DL,
    unsigned int DstReg,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt; Cond,
    unsigned int TrueReg,
    unsigned int FalseReg) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L868">llvm/include/llvm/CodeGen/TargetInstrInfo.h:868</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> I</b></dt><dt class="is-family-code">const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp;<b> DL</b></dt><dt class="is-family-code">unsigned int<b> DstReg</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::MachineOperand&gt;<b> Cond</b></dt><dt class="is-family-code">unsigned int<b> TrueReg</b></dt><dt class="is-family-code">unsigned int<b> FalseReg</b></dt></dl><h3 id="5BF6A403732F9E48"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5BF6A403732F9E48">¶</a><code class="hdoc-function-code language-cpp">unsigned int insertUnconditionalBranch(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>* DestBB,
    const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp; DL,
    int* BytesAdded = nullptr) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L677">llvm/include/llvm/CodeGen/TargetInstrInfo.h:677</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>*<b> DestBB</b></dt><dt class="is-family-code">const <a href="r7D971FB9604CC807.html">llvm::DebugLoc</a>&amp;<b> DL</b></dt><dt class="is-family-code">int*<b> BytesAdded</b> = nullptr</dt></dl><h3 id="3861EB94F8630AB9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3861EB94F8630AB9">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r6607998C23E31109.html">Optional</a>&lt;llvm::RegImmPair&gt; isAddImmediate(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="rD04632A218C37229.html">llvm::Register</a> Reg) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L966">llvm/include/llvm/CodeGen/TargetInstrInfo.h:966</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="rD04632A218C37229.html">llvm::Register</a><b> Reg</b></dt></dl><h3 id="3232171CBBD775BD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3232171CBBD775BD">¶</a><code class="hdoc-function-code language-cpp">virtual bool isAsCheapAsAMove(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Return true if the instruction is as cheap as a move instruction. Targets for different archs need to override this, and different micro-architectures can also be finely tuned inside.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L354">llvm/include/llvm/CodeGen/TargetInstrInfo.h:354</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="412FD42980A7B41B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#412FD42980A7B41B">¶</a><code class="hdoc-function-code language-cpp">virtual bool isAssociativeAndCommutative(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Inst) const</code></pre></h3><h4>Description</h4><p>Return true when \PInst is both associative and commutative.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1061">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1061</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Inst</b></dt></dl><h3 id="2E2EDA367D60085F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2E2EDA367D60085F">¶</a><code class="hdoc-function-code language-cpp">virtual bool isBasicBlockPrologue(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>True if the instruction is bound to the top of its basic block and no other instructions shall be inserted before it. This can be implemented to prevent register allocator to insert spills before such instructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1724">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1724</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="A35464F7CF907939"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A35464F7CF907939">¶</a><code class="hdoc-function-code language-cpp">virtual bool isBranchOffsetInRange(
    unsigned int BranchOpc,
    int64_t BrOffset) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L548">llvm/include/llvm/CodeGen/TargetInstrInfo.h:548</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> BranchOpc</b></dt><dt class="is-family-code">int64_t<b> BrOffset</b></dt></dl><h4>Returns</h4><p>true if a branch from an instruction with opcode \p BranchOpc bytes is capable of jumping to a position \p BrOffset bytes away.</p><h3 id="2712BA9E376F8345"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2712BA9E376F8345">¶</a><code class="hdoc-function-code language-cpp">virtual bool isCoalescableExtInstr(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int&amp; SrcReg,
    unsigned int&amp; DstReg,
    unsigned int&amp; SubIdx) const</code></pre></h3><h4>Description</h4><p>Return true if the instruction is a &quot;coalescable&quot; extension instruction. That is, it&apos;s like a copy where it&apos;s legal for the source to overlap the destination. e.g. X86::MOVSX64rr32. If this returns true, then it&apos;s expected the pre-extension value is available as a subreg of the result register. This also returns the sub-register index in SubIdx.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L238">llvm/include/llvm/CodeGen/TargetInstrInfo.h:238</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int&amp;<b> SrcReg</b></dt><dt class="is-family-code">unsigned int&amp;<b> DstReg</b></dt><dt class="is-family-code">unsigned int&amp;<b> SubIdx</b></dt></dl><h3 id="B3515D7F854265AD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B3515D7F854265AD">¶</a><code class="hdoc-function-code language-cpp"><a href="r6607998C23E31109.html">Optional</a>&lt;llvm::DestSourcePair&gt; isCopyInstr(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L955">llvm/include/llvm/CodeGen/TargetInstrInfo.h:955</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="1DD9EFC24BA68A6A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1DD9EFC24BA68A6A">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r6607998C23E31109.html">Optional</a>&lt;llvm::DestSourcePair&gt;
isCopyInstrImpl(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L944">llvm/include/llvm/CodeGen/TargetInstrInfo.h:944</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="A2815F1AAF82C118"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A2815F1AAF82C118">¶</a><code class="hdoc-function-code language-cpp">bool isFrameInstr(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; I) const</code></pre></h3><h4>Description</h4><p>Returns true if the argument is a frame pseudo instruction.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L188">llvm/include/llvm/CodeGen/TargetInstrInfo.h:188</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> I</b></dt></dl><h3 id="A34E738CCB7F9FB7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A34E738CCB7F9FB7">¶</a><code class="hdoc-function-code language-cpp">bool isFrameSetup(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; I) const</code></pre></h3><h4>Description</h4><p>Returns true if the argument is a frame setup pseudo instruction.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L194">llvm/include/llvm/CodeGen/TargetInstrInfo.h:194</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> I</b></dt></dl><h3 id="39494BDC471857C2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#39494BDC471857C2">¶</a><code class="hdoc-function-code language-cpp">virtual bool isFunctionSafeToOutlineFrom(
    <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF,
    bool OutlineFromLinkOnceODRs) const</code></pre></h3><h4>Description</h4><p>Return true if the function can safely be outlined from. A function \p MF is considered safe for outlining if an outlined function produced from instructions in F will produce a program which produces the same output for any set of given inputs.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1794">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1794</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt><dt class="is-family-code">bool<b> OutlineFromLinkOnceODRs</b></dt></dl><h3 id="3C3DEEFBDEF0A0B1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3C3DEEFBDEF0A0B1">¶</a><code class="hdoc-function-code language-cpp">static bool isGenericOpcode(unsigned int Opc)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L100">llvm/include/llvm/CodeGen/TargetInstrInfo.h:100</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opc</b></dt></dl><h3 id="720FBB13C96ADA4B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#720FBB13C96ADA4B">¶</a><code class="hdoc-function-code language-cpp">virtual bool isHighLatencyDef(int opc) const</code></pre></h3><h4>Description</h4><p>Return true if this opcode has high latency to its result.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1489">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1489</a></p><h4>Parameters</h4><dl><dt class="is-family-code">int<b> opc</b></dt></dl><h3 id="78DEA6C80ACB7E51"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#78DEA6C80ACB7E51">¶</a><code class="hdoc-function-code language-cpp">virtual bool isLegalToSplitMBBAt(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int MBBI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L758">llvm/include/llvm/CodeGen/TargetInstrInfo.h:758</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> MBBI</b></dt></dl><h3 id="61FDF85A255190F3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#61FDF85A255190F3">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int isLoadFromStackSlot(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    int&amp; FrameIndex,
    unsigned int&amp; MemBytes) const</code></pre></h3><h4>Description</h4><p>Optional extension of isLoadFromStackSlot that returns the number of bytes loaded from the stack. This must be implemented if a backend supports partial stack slot spills/loads to further disambiguate what the load does.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L257">llvm/include/llvm/CodeGen/TargetInstrInfo.h:257</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">int&amp;<b> FrameIndex</b></dt><dt class="is-family-code">unsigned int&amp;<b> MemBytes</b></dt></dl><h3 id="EFC9DF8CFA3CAA6C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EFC9DF8CFA3CAA6C">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int isLoadFromStackSlot(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    int&amp; FrameIndex) const</code></pre></h3><h4>Description</h4><p>If the specified machine instruction is a direct load from a stack slot, return the virtual or physical register number of the destination along with the FrameIndex of the loaded stack slot.  If not, return 0.  This predicate must return 0 if the instruction has any side effects other than loading from the stack slot.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L248">llvm/include/llvm/CodeGen/TargetInstrInfo.h:248</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">int&amp;<b> FrameIndex</b></dt></dl><h3 id="0AF9934A7046A0B8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0AF9934A7046A0B8">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int isLoadFromStackSlotPostFE(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    int&amp; FrameIndex) const</code></pre></h3><h4>Description</h4><p>Check for post-frame ptr elimination stack locations as well. This uses a heuristic so it isn&apos;t reliable for correctness.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L266">llvm/include/llvm/CodeGen/TargetInstrInfo.h:266</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">int&amp;<b> FrameIndex</b></dt></dl><h3 id="F6E2ADBBE15A581C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F6E2ADBBE15A581C">¶</a><code class="hdoc-function-code language-cpp">virtual bool isMBBSafeToOutlineFrom(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    unsigned int&amp; Flags) const</code></pre></h3><h4>Description</h4><p>Optional target hook that returns true if \p MBB is safe to outline from, and returns any target-specific information in \p Flags.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1767">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1767</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">unsigned int&amp;<b> Flags</b></dt></dl><h3 id="1BEB8CC6EF9CA174"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1BEB8CC6EF9CA174">¶</a><code class="hdoc-function-code language-cpp">virtual bool isPostIncrement(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Return true for post-incremented instructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1292">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1292</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="A452979E29A19E70"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A452979E29A19E70">¶</a><code class="hdoc-function-code language-cpp">virtual bool isPredicable(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Return true if the specified instruction can be predicated. By default, this returns true for every instruction with a PredicateOperand.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1342">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1342</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="D7CC28C1F0C34E42"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D7CC28C1F0C34E42">¶</a><code class="hdoc-function-code language-cpp">virtual bool isPredicated(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Returns true if the instruction is already predicated.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1295">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1295</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="3C393ACFC667A80B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3C393ACFC667A80B">¶</a><code class="hdoc-function-code language-cpp">virtual bool isProfitableToDupForIfCvt(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    unsigned int NumCycles,
    <a href="r237C322507965758.html">llvm::BranchProbability</a> Probability) const</code></pre></h3><h4>Description</h4><p>Return true if it&apos;s profitable for if-converter to duplicate instructions of specified accumulated instruction latencies in the specified MBB to enable if-conversion. The probability of the instructions being executed is given by Probability, and Confidence is a measure of our confidence that it will be properly predicted.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L794">llvm/include/llvm/CodeGen/TargetInstrInfo.h:794</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">unsigned int<b> NumCycles</b></dt><dt class="is-family-code"><a href="r237C322507965758.html">llvm::BranchProbability</a><b> Probability</b></dt></dl><h3 id="82EB17706607A0DA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#82EB17706607A0DA">¶</a><code class="hdoc-function-code language-cpp">virtual bool isProfitableToIfCvt(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; TMBB,
    unsigned int NumTCycles,
    unsigned int ExtraTCycles,
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; FMBB,
    unsigned int NumFCycles,
    unsigned int ExtraFCycles,
    <a href="r237C322507965758.html">llvm::BranchProbability</a> Probability) const</code></pre></h3><h4>Description</h4><p>Second variant of isProfitableToIfCvt. This one checks for the case where two basic blocks from true and false path of a if-then-else (diamond) are predicated on mutally exclusive predicates, where the probability of the true path being taken is given by Probability, and Confidence is a measure of our confidence that it will be properly predicted.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L780">llvm/include/llvm/CodeGen/TargetInstrInfo.h:780</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> TMBB</b></dt><dt class="is-family-code">unsigned int<b> NumTCycles</b></dt><dt class="is-family-code">unsigned int<b> ExtraTCycles</b></dt><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> FMBB</b></dt><dt class="is-family-code">unsigned int<b> NumFCycles</b></dt><dt class="is-family-code">unsigned int<b> ExtraFCycles</b></dt><dt class="is-family-code"><a href="r237C322507965758.html">llvm::BranchProbability</a><b> Probability</b></dt></dl><h3 id="4EF37B4D256FE48F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4EF37B4D256FE48F">¶</a><code class="hdoc-function-code language-cpp">virtual bool isProfitableToIfCvt(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    unsigned int NumCycles,
    unsigned int ExtraPredCycles,
    <a href="r237C322507965758.html">llvm::BranchProbability</a> Probability) const</code></pre></h3><h4>Description</h4><p>Return true if it&apos;s profitable to predicate instructions with accumulated instruction latency of &quot;NumCycles&quot; of the specified basic block, where the probability of the instructions being executed is given by Probability, and Confidence is a measure of our confidence that it will be properly predicted.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L768">llvm/include/llvm/CodeGen/TargetInstrInfo.h:768</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">unsigned int<b> NumCycles</b></dt><dt class="is-family-code">unsigned int<b> ExtraPredCycles</b></dt><dt class="is-family-code"><a href="r237C322507965758.html">llvm::BranchProbability</a><b> Probability</b></dt></dl><h3 id="69707669F8B1E522"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#69707669F8B1E522">¶</a><code class="hdoc-function-code language-cpp">virtual bool isProfitableToUnpredicate(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; TMBB,
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; FMBB) const</code></pre></h3><h4>Description</h4><p>Return true if it&apos;s profitable to unpredicate one side of a &apos;diamond&apos;, i.e. two sides of if-else predicated on mutually exclusive predicates. e.g. subeq  r0, r1, #1 addne  r0, r1, #1 =&gt; sub    r0, r1, #1 addne  r0, r1, #1 This may be profitable is conditional instructions are always executed.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L824">llvm/include/llvm/CodeGen/TargetInstrInfo.h:824</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> TMBB</b></dt><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> FMBB</b></dt></dl><h3 id="5D29B991C911C424"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5D29B991C911C424">¶</a><code class="hdoc-function-code language-cpp">virtual bool isReallyTriviallyReMaterializable(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="rCA1ED98E6FDF5F7E.html">llvm::AAResults</a>* AA) const</code></pre></h3><h4>Description</h4><p>For instructions with opcodes for which the M_REMATERIALIZABLE flag is set, this hook lets the target specify whether the instruction is actually trivially rematerializable, taking into consideration its operands. This predicate must return false if the instruction has any side effects other than producing a value, or if it requres any address registers that are not always available. Requirements must be check as stated in isTriviallyReMaterializable() .</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L132">llvm/include/llvm/CodeGen/TargetInstrInfo.h:132</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="rCA1ED98E6FDF5F7E.html">llvm::AAResults</a>*<b> AA</b></dt></dl><h3 id="845600387FF4F0F6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#845600387FF4F0F6">¶</a><code class="hdoc-function-code language-cpp">bool isReassociationCandidate(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Inst,
    bool&amp; Commuted) const</code></pre></h3><h4>Description</h4><p>Return true if the input \PInst is part of a chain of dependent ops that are suitable for reassociation, otherwise return false. If the instruction&apos;s operands must be commuted to have a previous instruction of the same type define the first source operand, \PCommuted will be set to true.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1058">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1058</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Inst</b></dt><dt class="is-family-code">bool&amp;<b> Commuted</b></dt></dl><h3 id="28A083E1BB7F9E58"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#28A083E1BB7F9E58">¶</a><code class="hdoc-function-code language-cpp">virtual bool isSafeToMoveRegClassDefs(
    const <a href="r413242C5B6D720F3.html">llvm::TargetRegisterClass</a>* RC) const</code></pre></h3><h4>Description</h4><p>Return true if it&apos;s safe to move a machine instruction that defines the specified register class.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1348">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1348</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r413242C5B6D720F3.html">llvm::TargetRegisterClass</a>*<b> RC</b></dt></dl><h3 id="CD76F1CD0A15A606"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CD76F1CD0A15A606">¶</a><code class="hdoc-function-code language-cpp">virtual bool isSchedulingBoundary(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    const <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>* MBB,
    const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF) const</code></pre></h3><h4>Description</h4><p>Test if the given instruction should be considered a scheduling boundary. This primarily includes labels and terminators.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1354">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1354</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">const <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>*<b> MBB</b></dt><dt class="is-family-code">const <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt></dl><h3 id="108290D748F19234"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#108290D748F19234">¶</a><code class="hdoc-function-code language-cpp">virtual bool isStackSlotCopy(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    int&amp; DestFrameIndex,
    int&amp; SrcFrameIndex) const</code></pre></h3><h4>Description</h4><p>Return true if the specified machine instruction is a copy of one stack slot to another and has no other effect. Provide the identity of the two frame indices.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L322">llvm/include/llvm/CodeGen/TargetInstrInfo.h:322</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">int&amp;<b> DestFrameIndex</b></dt><dt class="is-family-code">int&amp;<b> SrcFrameIndex</b></dt></dl><h3 id="B6864846FBABE401"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B6864846FBABE401">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int isStoreToStackSlot(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    int&amp; FrameIndex) const</code></pre></h3><h4>Description</h4><p>If the specified machine instruction is a direct store to a stack slot, return the virtual or physical register number of the source reg along with the FrameIndex of the loaded stack slot.  If not, return 0.  This predicate must return 0 if the instruction has any side effects other than storing to the stack slot.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L286">llvm/include/llvm/CodeGen/TargetInstrInfo.h:286</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">int&amp;<b> FrameIndex</b></dt></dl><h3 id="DF78E311B8892E9E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DF78E311B8892E9E">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int isStoreToStackSlot(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    int&amp; FrameIndex,
    unsigned int&amp; MemBytes) const</code></pre></h3><h4>Description</h4><p>Optional extension of isStoreToStackSlot that returns the number of bytes stored to the stack. This must be implemented if a backend supports partial stack slot spills/loads to further disambiguate what the store does.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L295">llvm/include/llvm/CodeGen/TargetInstrInfo.h:295</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">int&amp;<b> FrameIndex</b></dt><dt class="is-family-code">unsigned int&amp;<b> MemBytes</b></dt></dl><h3 id="A5F321273A8795DB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A5F321273A8795DB">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int isStoreToStackSlotPostFE(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    int&amp; FrameIndex) const</code></pre></h3><h4>Description</h4><p>Check for post-frame ptr elimination stack locations as well. This uses a heuristic, so it isn&apos;t reliable for correctness.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L304">llvm/include/llvm/CodeGen/TargetInstrInfo.h:304</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">int&amp;<b> FrameIndex</b></dt></dl><h3 id="436A6DC1A6686B7A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#436A6DC1A6686B7A">¶</a><code class="hdoc-function-code language-cpp">virtual bool isSubregFoldable() const</code></pre></h3><h4>Description</h4><p>Check whether the target can fold a load that feeds a subreg operand (or a subreg operand that feeds a store). For example, X86 may want to return true if it can fold movl (%esp), %eax subb, %al, ... Into: subb (%esp), ... Ideally, we&apos;d like the target implementation of foldMemoryOperand() to reject subregs - but since this behavior used to be enforced in the target-independent code, moving this responsibility to the targets has the potential of causing nasty silent breakage in out-of-tree targets.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1016">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1016</a></p><h3 id="CB59E662B7976B9C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CB59E662B7976B9C">¶</a><code class="hdoc-function-code language-cpp">virtual bool isTailCall(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Inst) const</code></pre></h3><h4>Description</h4><p>Determines whether \p Inst is a tail call instruction. Override this method on targets that do not properly set MCID::Return and MCID::Call on tail call instructions.&quot;</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1717">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1717</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Inst</b></dt></dl><h3 id="BB234CAFABCCAC24"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BB234CAFABCCAC24">¶</a><code class="hdoc-function-code language-cpp">virtual bool isThroughputPattern(
    llvm::MachineCombinerPattern Pattern) const</code></pre></h3><h4>Description</h4><p>Return true when a code sequence can improve throughput. It should be called only for instructions in loops.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1051">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1051</a></p><h4>Parameters</h4><dl><dt class="is-family-code">llvm::MachineCombinerPattern<b> Pattern</b></dt><dd>- combiner pattern</dd></dl><h3 id="9884D56C1D5EB578"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9884D56C1D5EB578">¶</a><code class="hdoc-function-code language-cpp">bool isTriviallyReMaterializable(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="rCA1ED98E6FDF5F7E.html">llvm::AAResults</a>* AA = nullptr) const</code></pre></h3><h4>Description</h4><p>Return true if the instruction is trivially rematerializable, meaning it has no side effects and requires no operands that aren&apos;t always available. This means the only allowed uses are constants and unallocatable physical registers so that the instructions result is independent of the place in the function.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L116">llvm/include/llvm/CodeGen/TargetInstrInfo.h:116</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="rCA1ED98E6FDF5F7E.html">llvm::AAResults</a>*<b> AA</b> = nullptr</dt></dl><h3 id="FB34BCE69F06B726"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FB34BCE69F06B726">¶</a><code class="hdoc-function-code language-cpp">virtual bool isUnconditionalTailCall(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Returns true if MI is an unconditional tail call.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1302">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1302</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="F9BD9157F61450EE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F9BD9157F61450EE">¶</a><code class="hdoc-function-code language-cpp">virtual bool isUnpredicatedTerminator(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Returns true if the instruction is a terminator instruction that has not been predicated.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1299">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1299</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="587E15A8AB58BA68"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#587E15A8AB58BA68">¶</a><code class="hdoc-function-code language-cpp">bool isZeroCost(unsigned int Opcode) const</code></pre></h3><h4>Description</h4><p>Return true for pseudo instructions that don&apos;t consume any machine resources in their current form. These are common cases that the scheduler should consider free, rather than conservatively handling them as instructions with no itinerary.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1448">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1448</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt></dl><h3 id="6BE91B61D3471895"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6BE91B61D3471895">¶</a><code class="hdoc-function-code language-cpp">virtual void loadRegFromStackSlot(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int MI,
    unsigned int DestReg,
    int FrameIndex,
    const <a href="r413242C5B6D720F3.html">llvm::TargetRegisterClass</a>* RC,
    const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>* TRI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L987">llvm/include/llvm/CodeGen/TargetInstrInfo.h:987</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> MI</b></dt><dt class="is-family-code">unsigned int<b> DestReg</b></dt><dt class="is-family-code">int<b> FrameIndex</b></dt><dt class="is-family-code">const <a href="r413242C5B6D720F3.html">llvm::TargetRegisterClass</a>*<b> RC</b></dt><dt class="is-family-code">const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>*<b> TRI</b></dt></dl><h3 id="5A17DCC74B008804"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5A17DCC74B008804">¶</a><code class="hdoc-function-code language-cpp">virtual bool optimizeCompareInstr(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; CmpInstr,
    unsigned int SrcReg,
    unsigned int SrcReg2,
    int Mask,
    int Value,
    const <a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>* MRI) const</code></pre></h3><h4>Description</h4><p>See if the comparison instruction can be converted into something more efficient. E.g., on ARM most instructions can set the flags register, obviating the need for a separate CMP.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1405">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1405</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> CmpInstr</b></dt><dt class="is-family-code">unsigned int<b> SrcReg</b></dt><dt class="is-family-code">unsigned int<b> SrcReg2</b></dt><dt class="is-family-code">int<b> Mask</b></dt><dt class="is-family-code">int<b> Value</b></dt><dt class="is-family-code">const <a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>*<b> MRI</b></dt></dl><h3 id="CEF2B8E58A8F69C8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CEF2B8E58A8F69C8">¶</a><code class="hdoc-function-code language-cpp">virtual bool optimizeCondBranch(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1410">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1410</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="51C3305A6CAA115E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#51C3305A6CAA115E">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* optimizeLoadInstr(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    const <a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>* MRI,
    unsigned int&amp; FoldAsLoadDefReg,
    llvm::MachineInstr*&amp; DefMI) const</code></pre></h3><h4>Description</h4><p>Try to remove the load by folding it to a register operand at the use. We fold the load instructions if and only if the def and use are in the same BB. We only look at one load and see whether it can be folded into MI. FoldAsLoadDefReg is the virtual register defined by the load we are trying to fold. DefMI returns the machine instruction that defines FoldAsLoadDefReg, and the function returns the machine instruction generated due to folding.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1419">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1419</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">const <a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>*<b> MRI</b></dt><dt class="is-family-code">unsigned int&amp;<b> FoldAsLoadDefReg</b></dt><dt class="is-family-code">llvm::MachineInstr*&amp;<b> DefMI</b></dt></dl><h3 id="19FD5141C97110BD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#19FD5141C97110BD">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* optimizeSelect(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;llvm::MachineInstr*&gt;&amp; NewMIs,
    bool PreferFalse = false) const</code></pre></h3><h4>Description</h4><p>Given a select instruction that was understood by analyzeSelect and returned Optimizable = true, attempt to optimize MI by merging it with one of its operands. Returns NULL on failure. When successful, returns the new select instruction. The client is responsible for deleting MI. If both sides of the select can be optimized, PreferFalse is used to pick a side.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L916">llvm/include/llvm/CodeGen/TargetInstrInfo.h:916</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dd>Optimizable select instruction.</dd><dt class="is-family-code"><a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;llvm::MachineInstr*&gt;&amp;<b> NewMIs</b></dt><dd>Set that record all MIs in the basic block up to \p MI. Has to be updated with any newly created MI or deleted ones.</dd><dt class="is-family-code">bool<b> PreferFalse</b> = false</dt><dd>Try to optimize FalseOp instead of TrueOp.</dd></dl><h4>Returns</h4><p>Optimized instruction or NULL.</p><h3 id="5BCD95A111E6F6EF"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5BCD95A111E6F6EF">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int predictBranchSizeForIfCvt(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Return an estimate for the code size reduction (in bytes) which will be caused by removing the given branch instruction during if-conversion.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L809">llvm/include/llvm/CodeGen/TargetInstrInfo.h:809</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="55BBB7BB2BAF9DE4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#55BBB7BB2BAF9DE4">¶</a><code class="hdoc-function-code language-cpp">virtual bool produceSameValue(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI0,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI1,
    const <a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>* MRI =
        nullptr) const</code></pre></h3><h4>Description</h4><p>Return true if two machine instructions would produce identical values. By default, this is only true when the two instructions are deemed identical except for defs. If this function is called when the IR is still in SSA form, the caller can pass the MachineRegisterInfo for aggressive checks.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L542">llvm/include/llvm/CodeGen/TargetInstrInfo.h:542</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI0</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI1</b></dt><dt class="is-family-code">const <a href="rFEED0093AAFD6DB4.html">llvm::MachineRegisterInfo</a>*<b> MRI</b> = nullptr</dt></dl><h3 id="F96BB8DC8D042DD6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F96BB8DC8D042DD6">¶</a><code class="hdoc-function-code language-cpp">virtual void reMaterialize(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int MI,
    unsigned int DestReg,
    unsigned int SubIdx,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Orig,
    const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>&amp; TRI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L370">llvm/include/llvm/CodeGen/TargetInstrInfo.h:370</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> MI</b></dt><dt class="is-family-code">unsigned int<b> DestReg</b></dt><dt class="is-family-code">unsigned int<b> SubIdx</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Orig</b></dt><dt class="is-family-code">const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>&amp;<b> TRI</b></dt></dl><h3 id="094E51BE5D0B8B59"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#094E51BE5D0B8B59">¶</a><code class="hdoc-function-code language-cpp">void reassociateOps(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Root,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Prev,
    llvm::MachineCombinerPattern Pattern,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;
        InsInstrs,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;
        DelInstrs,
    int&amp; InstrIdxForVirtReg) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1090">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1090</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Root</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Prev</b></dt><dt class="is-family-code">llvm::MachineCombinerPattern<b> Pattern</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;<b> InsInstrs</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;<b> DelInstrs</b></dt><dt class="is-family-code">int&amp;<b> InstrIdxForVirtReg</b></dt></dl><h3 id="712201E081C61EE5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#712201E081C61EE5">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int reduceLoopCount(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; PreHeader,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>* IndVar,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; Cmp,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp; Cond,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;
        PrevInsts,
    unsigned int Iter,
    unsigned int MaxIter) const</code></pre></h3><h4>Description</h4><p>Generate code to reduce the loop iteration by one and check if the loop is finished.  Return the value/register of the new loop count.  We need this function when peeling off one or more iterations of a loop. This function assumes the nth iteration is peeled first.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L741">llvm/include/llvm/CodeGen/TargetInstrInfo.h:741</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> PreHeader</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>*<b> IndVar</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> Cmp</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp;<b> Cond</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;<b> PrevInsts</b></dt><dt class="is-family-code">unsigned int<b> Iter</b></dt><dt class="is-family-code">unsigned int<b> MaxIter</b></dt></dl><h3 id="3525798E1DB67EDE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3525798E1DB67EDE">¶</a><code class="hdoc-function-code language-cpp">virtual unsigned int removeBranch(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int* BytesRemoved = nullptr) const</code></pre></h3><h4>Description</h4><p>Remove the branching code at the end of the specific MBB. This is only invoked in cases where AnalyzeBranch returns success. It returns the number of instructions that were removed. If \p BytesRemoved is non-null, report the change in code size from the removed instructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L651">llvm/include/llvm/CodeGen/TargetInstrInfo.h:651</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int*<b> BytesRemoved</b> = nullptr</dt></dl><h3 id="82207AFE66DF2EEC"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#82207AFE66DF2EEC">¶</a><code class="hdoc-function-code language-cpp">virtual void replaceBranchWithTailCall(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp; Cond,
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; TailCall) const</code></pre></h3><h4>Description</h4><p>Replace the conditional branch in MBB with a conditional tail call.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1313">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1313</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp;<b> Cond</b></dt><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> TailCall</b></dt></dl><h3 id="2562758428C9B63C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2562758428C9B63C">¶</a><code class="hdoc-function-code language-cpp">virtual bool reverseBranchCondition(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp; Cond)
    const</code></pre></h3><h4>Description</h4><p>Reverses the branch condition of the specified condition list, returning false on success and true if it cannot be reversed.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1280">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1280</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineOperand&gt;&amp;<b> Cond</b></dt></dl><h3 id="5314B0E9B12F16AA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5314B0E9B12F16AA">¶</a><code class="hdoc-function-code language-cpp">virtual void setExecutionDomain(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int Domain) const</code></pre></h3><h4>Description</h4><p>Change the opcode of MI to execute in Domain. The bit (1  &lt; &lt; Domain) must be set in the mask returned from getExecutionDomain(MI).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1544">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1544</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> Domain</b></dt></dl><h3 id="1DADDCAD5FA23945"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1DADDCAD5FA23945">¶</a><code class="hdoc-function-code language-cpp">virtual void setSpecialOperandAttr(
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; OldMI1,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; OldMI2,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; NewMI1,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; NewMI2) const</code></pre></h3><h4>Description</h4><p>This is an architecture-specific helper function of reassociateOps. Set special operand attributes for new instructions after reassociation.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1098">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1098</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> OldMI1</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> OldMI2</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> NewMI1</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> NewMI2</b></dt></dl><h3 id="E269B153F00E9FC8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E269B153F00E9FC8">¶</a><code class="hdoc-function-code language-cpp">virtual bool shouldClusterMemOps(
    const <a href="r0A1522BF7EFA6139.html">llvm::MachineOperand</a>&amp; BaseOp1,
    const <a href="r0A1522BF7EFA6139.html">llvm::MachineOperand</a>&amp; BaseOp2,
    unsigned int NumLoads) const</code></pre></h3><h4>Description</h4><p>Returns true if the two given memory operations should be scheduled adjacent. Note that you have to add: DAG-&gt;addMutation(createLoadClusterDAGMutation(DAG-&gt;TII, DAG-&gt;TRI)); or DAG-&gt;addMutation(createStoreClusterDAGMutation(DAG-&gt;TII, DAG-&gt;TRI)); to TargetPassConfig::createMachineScheduler() to have an effect.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1271">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1271</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0A1522BF7EFA6139.html">llvm::MachineOperand</a>&amp;<b> BaseOp1</b></dt><dt class="is-family-code">const <a href="r0A1522BF7EFA6139.html">llvm::MachineOperand</a>&amp;<b> BaseOp2</b></dt><dt class="is-family-code">unsigned int<b> NumLoads</b></dt></dl><h3 id="C8E3F9918BA5DF66"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C8E3F9918BA5DF66">¶</a><code class="hdoc-function-code language-cpp">virtual bool shouldOutlineFromFunctionByDefault(
    <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF) const</code></pre></h3><h4>Description</h4><p>Return true if the function should be outlined from by default.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1801">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1801</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt></dl><h3 id="360C971A7677695D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#360C971A7677695D">¶</a><code class="hdoc-function-code language-cpp">virtual bool shouldScheduleLoadsNear(
    <a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>* Load1,
    <a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>* Load2,
    int64_t Offset1,
    int64_t Offset2,
    unsigned int NumLoads) const</code></pre></h3><h4>Description</h4><p>This is a used by the pre-regalloc scheduler to determine (in conjunction with areLoadsFromSameBasePtr) if two loads should be scheduled together. On some targets if two loads are loading from addresses in the same cache line, it&apos;s better if they are scheduled together. This function takes two integers that represent the load offsets from the common base address. It returns true if it decides it&apos;s desirable to schedule the two loads together. &quot;NumLoads&quot; is the number of loads that have already been scheduled after Load1.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1232">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1232</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>*<b> Load1</b></dt><dt class="is-family-code"><a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>*<b> Load2</b></dt><dt class="is-family-code">int64_t<b> Offset1</b></dt><dt class="is-family-code">int64_t<b> Offset2</b></dt><dt class="is-family-code">unsigned int<b> NumLoads</b></dt></dl><h3 id="0F86CF0DF7834FA7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0F86CF0DF7834FA7">¶</a><code class="hdoc-function-code language-cpp">virtual bool shouldSink(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI) const</code></pre></h3><h4>Description</h4><p>Return true if the instruction should be sunk by MachineSink. MachineSink determines on its own whether the instruction is safe to sink; this gives the target a hook to override the default behavior with regards to which instructions should be sunk.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L363">llvm/include/llvm/CodeGen/TargetInstrInfo.h:363</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt></dl><h3 id="764DD008317DEEC6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#764DD008317DEEC6">¶</a><code class="hdoc-function-code language-cpp">virtual void storeRegToStackSlot(
    <a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp; MBB,
    int MI,
    unsigned int SrcReg,
    bool isKill,
    int FrameIndex,
    const <a href="r413242C5B6D720F3.html">llvm::TargetRegisterClass</a>* RC,
    const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>* TRI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L975">llvm/include/llvm/CodeGen/TargetInstrInfo.h:975</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD94B5FBC5E7E6A08.html">llvm::MachineBasicBlock</a>&amp;<b> MBB</b></dt><dt class="is-family-code">int<b> MI</b></dt><dt class="is-family-code">unsigned int<b> SrcReg</b></dt><dt class="is-family-code">bool<b> isKill</b></dt><dt class="is-family-code">int<b> FrameIndex</b></dt><dt class="is-family-code">const <a href="r413242C5B6D720F3.html">llvm::TargetRegisterClass</a>*<b> RC</b></dt><dt class="is-family-code">const <a href="r2F26D4796E7C36E2.html">llvm::TargetRegisterInfo</a>*<b> TRI</b></dt></dl><h3 id="657051E19623F4F2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#657051E19623F4F2">¶</a><code class="hdoc-function-code language-cpp">virtual bool unfoldMemoryOperand(
    <a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp; MF,
    <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    unsigned int Reg,
    bool UnfoldLoad,
    bool UnfoldStore,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp; NewMIs)
    const</code></pre></h3><h4>Description</h4><p>unfoldMemoryOperand - Separate a single instruction which folded a load or a store or a load and a store into two or more instruction. If this is possible, returns true as well as the new instructions by reference.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1191">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1191</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r0899A788A19F8C40.html">llvm::MachineFunction</a>&amp;<b> MF</b></dt><dt class="is-family-code"><a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code">unsigned int<b> Reg</b></dt><dt class="is-family-code">bool<b> UnfoldLoad</b></dt><dt class="is-family-code">bool<b> UnfoldStore</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::MachineInstr*&gt;&amp;<b> NewMIs</b></dt></dl><h3 id="B84420458F720982"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B84420458F720982">¶</a><code class="hdoc-function-code language-cpp">virtual bool unfoldMemoryOperand(
    <a href="r6847FED92C3743F2.html">llvm::SelectionDAG</a>&amp; DAG,
    <a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>* N,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::SDNode*&gt;&amp; NewNodes)
    const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1197">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1197</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6847FED92C3743F2.html">llvm::SelectionDAG</a>&amp;<b> DAG</b></dt><dt class="is-family-code"><a href="r50D1FBEF89FFA97B.html">llvm::SDNode</a>*<b> N</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::SDNode*&gt;&amp;<b> NewNodes</b></dt></dl><h3 id="F218AAFF83B81408"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F218AAFF83B81408">¶</a><code class="hdoc-function-code language-cpp">virtual bool useMachineCombiner() const</code></pre></h3><h4>Description</h4><p>Return true when a target supports MachineCombiner.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1103">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1103</a></p><h3 id="392FB1B512BB83EE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#392FB1B512BB83EE">¶</a><code class="hdoc-function-code language-cpp">bool usePreRAHazardRecognizer() const</code></pre></h3><h4>Description</h4><p>Provide a global flag for disabling the PreRA hazard recognizer that targets may choose to honor.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1391">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1391</a></p><h3 id="D8E081888EA140E8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D8E081888EA140E8">¶</a><code class="hdoc-function-code language-cpp">virtual bool verifyInstruction(
    const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp; MI,
    <a href="rECFCAF624C04523A.html">llvm::StringRef</a>&amp; ErrInfo) const</code></pre></h3><h4>Description</h4><p>Perform target-specific instruction verification.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L1511">llvm/include/llvm/CodeGen/TargetInstrInfo.h:1511</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rD562DBB6D69859EC.html">llvm::MachineInstr</a>&amp;<b> MI</b></dt><dt class="is-family-code"><a href="rECFCAF624C04523A.html">llvm::StringRef</a>&amp;<b> ErrInfo</b></dt></dl><h3 id="C8F51E588850B315"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C8F51E588850B315">¶</a><code class="hdoc-function-code language-cpp">virtual ~TargetInstrInfo()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/TargetInstrInfo.h#L98">llvm/include/llvm/CodeGen/TargetInstrInfo.h:98</a></p></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>