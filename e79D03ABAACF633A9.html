<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>enum NodeType: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li><a href="namespaces.html#5D5C59CA5A5FE495"><span>namespace ISD</span></a></li><li class="is-active"><a aria-current="page79D03ABAACF633A9"><span>enum NodeType</span></a></li></ul></nav><main class="content"><h1>enum NodeType</h1><h2>Description</h2><p>ISD::NodeType enum - This enum defines the target-independent operators for a SelectionDAG. Targets may also define target-dependent operator codes for SDNodes. For example, on x86, these are the enum values in the X86ISD namespace. Targets should aim to use target-independent operators to model their instruction sets as much as possible, and only use target-dependent operators when they have special requirements. Finally, during and after selection proper, SNodes may use special operator codes that correspond directly with MachineInstr opcodes. These are used to represent selected instructions. See the isMachineOpcode() and getMachineOpcode() member functions of SDNode.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/CodeGen/ISDOpcodes.h#L40">llvm/include/llvm/CodeGen/ISDOpcodes.h:40</a></p><h2>Enumerators</h2><table class="table is-narrow is-hoverable"><tr><th>Name</th><th>Value</th><th>Comment</th></tr><tr><td class="is-family-code">DELETED_NODE</td><td class="is-family-code">0</td><td>DELETED_NODE - This is an illegal value that is used to catch errors.  This opcode is not a legal opcode for any node.</td></tr><tr><td class="is-family-code">EntryToken</td><td class="is-family-code">1</td><td>EntryToken - This is the marker used to indicate the start of a region.</td></tr><tr><td class="is-family-code">TokenFactor</td><td class="is-family-code">2</td><td>TokenFactor - This node takes multiple tokens as input and produces a single token result. This is used to represent the fact that the operand operators are independent of each other.</td></tr><tr><td class="is-family-code">AssertSext</td><td class="is-family-code">3</td><td>AssertSext, AssertZext - These nodes record if a register contains a value that has already been zero or sign extended from a narrower type. These nodes take two operands.  The first is the node that has already been extended, and the second is a value type node indicating the width of the extension</td></tr><tr><td class="is-family-code">AssertZext</td><td class="is-family-code">4</td><td>AssertSext, AssertZext - These nodes record if a register contains a value that has already been zero or sign extended from a narrower type. These nodes take two operands.  The first is the node that has already been extended, and the second is a value type node indicating the width of the extension</td></tr><tr><td class="is-family-code">BasicBlock</td><td class="is-family-code">5</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">VALUETYPE</td><td class="is-family-code">6</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">CONDCODE</td><td class="is-family-code">7</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">Register</td><td class="is-family-code">8</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">RegisterMask</td><td class="is-family-code">9</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">Constant</td><td class="is-family-code">10</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">ConstantFP</td><td class="is-family-code">11</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">GlobalAddress</td><td class="is-family-code">12</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">GlobalTLSAddress</td><td class="is-family-code">13</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">FrameIndex</td><td class="is-family-code">14</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">JumpTable</td><td class="is-family-code">15</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">ConstantPool</td><td class="is-family-code">16</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">ExternalSymbol</td><td class="is-family-code">17</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">BlockAddress</td><td class="is-family-code">18</td><td>Various leaf nodes.</td></tr><tr><td class="is-family-code">GLOBAL_OFFSET_TABLE</td><td class="is-family-code">19</td><td>The address of the GOT</td></tr><tr><td class="is-family-code">FRAMEADDR</td><td class="is-family-code">20</td><td>FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and llvm.returnaddress on the DAG.  These nodes take one operand, the index of the frame or return address to return.  An index of zero corresponds to the current function&apos;s frame or return address, an index of one to the parent&apos;s frame or return address, and so on.</td></tr><tr><td class="is-family-code">RETURNADDR</td><td class="is-family-code">21</td><td>FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and llvm.returnaddress on the DAG.  These nodes take one operand, the index of the frame or return address to return.  An index of zero corresponds to the current function&apos;s frame or return address, an index of one to the parent&apos;s frame or return address, and so on.</td></tr><tr><td class="is-family-code">ADDROFRETURNADDR</td><td class="is-family-code">22</td><td>FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and llvm.returnaddress on the DAG.  These nodes take one operand, the index of the frame or return address to return.  An index of zero corresponds to the current function&apos;s frame or return address, an index of one to the parent&apos;s frame or return address, and so on.</td></tr><tr><td class="is-family-code">SPONENTRY</td><td class="is-family-code">23</td><td>FRAMEADDR, RETURNADDR - These nodes represent llvm.frameaddress and llvm.returnaddress on the DAG.  These nodes take one operand, the index of the frame or return address to return.  An index of zero corresponds to the current function&apos;s frame or return address, an index of one to the parent&apos;s frame or return address, and so on.</td></tr><tr><td class="is-family-code">LOCAL_RECOVER</td><td class="is-family-code">24</td><td>LOCAL_RECOVER - Represents the llvm.localrecover intrinsic. Materializes the offset from the local object pointer of another function to a particular local object passed to llvm.localescape. The operand is the MCSymbol label used to represent this offset, since typically the offset is not known until after code generation of the parent.</td></tr><tr><td class="is-family-code">READ_REGISTER</td><td class="is-family-code">25</td><td>READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on the DAG, which implements the named register global variables extension.</td></tr><tr><td class="is-family-code">WRITE_REGISTER</td><td class="is-family-code">26</td><td>READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on the DAG, which implements the named register global variables extension.</td></tr><tr><td class="is-family-code">FRAME_TO_ARGS_OFFSET</td><td class="is-family-code">27</td><td>FRAME_TO_ARGS_OFFSET - This node represents offset from frame pointer to first (possible) on-stack argument. This is needed for correct stack adjustment during unwind.</td></tr><tr><td class="is-family-code">EH_DWARF_CFA</td><td class="is-family-code">28</td><td>EH_DWARF_CFA - This node represents the pointer to the DWARF Canonical Frame Address (CFA), generally the value of the stack pointer at the call site in the previous frame.</td></tr><tr><td class="is-family-code">EH_RETURN</td><td class="is-family-code">29</td><td>OUTCHAIN = EH_RETURN(INCHAIN, OFFSET, HANDLER) - This node represents &apos;eh_return&apos; gcc dwarf builtin, which is used to return from exception. The general meaning is: adjust stack by OFFSET and pass execution to HANDLER. Many platform-related details also :)</td></tr><tr><td class="is-family-code">EH_SJLJ_SETJMP</td><td class="is-family-code">30</td><td>RESULT, OUTCHAIN = EH_SJLJ_SETJMP(INCHAIN, buffer) This corresponds to the eh.sjlj.setjmp intrinsic. It takes an input chain and a pointer to the jump buffer as inputs and returns an outchain.</td></tr><tr><td class="is-family-code">EH_SJLJ_LONGJMP</td><td class="is-family-code">31</td><td>OUTCHAIN = EH_SJLJ_LONGJMP(INCHAIN, buffer) This corresponds to the eh.sjlj.longjmp intrinsic. It takes an input chain and a pointer to the jump buffer as inputs and returns an outchain.</td></tr><tr><td class="is-family-code">EH_SJLJ_SETUP_DISPATCH</td><td class="is-family-code">32</td><td>OUTCHAIN = EH_SJLJ_SETUP_DISPATCH(INCHAIN) The target initializes the dispatch table here.</td></tr><tr><td class="is-family-code">TargetConstant</td><td class="is-family-code">33</td><td>TargetConstant* - Like Constant*, but the DAG does not do any folding, simplification, or lowering of the constant. They are used for constants which are known to fit in the immediate fields of their users, or for carrying magic numbers which are not values which need to be materialized in registers.</td></tr><tr><td class="is-family-code">TargetConstantFP</td><td class="is-family-code">34</td><td>TargetConstant* - Like Constant*, but the DAG does not do any folding, simplification, or lowering of the constant. They are used for constants which are known to fit in the immediate fields of their users, or for carrying magic numbers which are not values which need to be materialized in registers.</td></tr><tr><td class="is-family-code">TargetGlobalAddress</td><td class="is-family-code">35</td><td>TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or anything else with this node, and this is valid in the target-specific dag, turning into a GlobalAddress operand.</td></tr><tr><td class="is-family-code">TargetGlobalTLSAddress</td><td class="is-family-code">36</td><td>TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or anything else with this node, and this is valid in the target-specific dag, turning into a GlobalAddress operand.</td></tr><tr><td class="is-family-code">TargetFrameIndex</td><td class="is-family-code">37</td><td>TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or anything else with this node, and this is valid in the target-specific dag, turning into a GlobalAddress operand.</td></tr><tr><td class="is-family-code">TargetJumpTable</td><td class="is-family-code">38</td><td>TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or anything else with this node, and this is valid in the target-specific dag, turning into a GlobalAddress operand.</td></tr><tr><td class="is-family-code">TargetConstantPool</td><td class="is-family-code">39</td><td>TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or anything else with this node, and this is valid in the target-specific dag, turning into a GlobalAddress operand.</td></tr><tr><td class="is-family-code">TargetExternalSymbol</td><td class="is-family-code">40</td><td>TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or anything else with this node, and this is valid in the target-specific dag, turning into a GlobalAddress operand.</td></tr><tr><td class="is-family-code">TargetBlockAddress</td><td class="is-family-code">41</td><td>TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or anything else with this node, and this is valid in the target-specific dag, turning into a GlobalAddress operand.</td></tr><tr><td class="is-family-code">MCSymbol</td><td class="is-family-code">42</td><td>TargetGlobalAddress - Like GlobalAddress, but the DAG does no folding or anything else with this node, and this is valid in the target-specific dag, turning into a GlobalAddress operand.</td></tr><tr><td class="is-family-code">TargetIndex</td><td class="is-family-code">43</td><td>TargetIndex - Like a constant pool entry, but with completely target-dependent semantics. Holds target flags, a 32-bit index, and a 64-bit index. Targets can use this however they like.</td></tr><tr><td class="is-family-code">INTRINSIC_WO_CHAIN</td><td class="is-family-code">44</td><td>RESULT = INTRINSIC_WO_CHAIN(INTRINSICID, arg1, arg2, ...) This node represents a target intrinsic function with no side effects. The first operand is the ID number of the intrinsic from the llvm::Intrinsic namespace.  The operands to the intrinsic follow.  The node returns the result of the intrinsic.</td></tr><tr><td class="is-family-code">INTRINSIC_W_CHAIN</td><td class="is-family-code">45</td><td>RESULT,OUTCHAIN = INTRINSIC_W_CHAIN(INCHAIN, INTRINSICID, arg1, ...) This node represents a target intrinsic function with side effects that returns a result.  The first operand is a chain pointer.  The second is the ID number of the intrinsic from the llvm::Intrinsic namespace.  The operands to the intrinsic follow.  The node has two results, the result of the intrinsic and an output chain.</td></tr><tr><td class="is-family-code">INTRINSIC_VOID</td><td class="is-family-code">46</td><td>OUTCHAIN = INTRINSIC_VOID(INCHAIN, INTRINSICID, arg1, arg2, ...) This node represents a target intrinsic function with side effects that does not return a result.  The first operand is a chain pointer.  The second is the ID number of the intrinsic from the llvm::Intrinsic namespace.  The operands to the intrinsic follow.</td></tr><tr><td class="is-family-code">CopyToReg</td><td class="is-family-code">47</td><td>CopyToReg - This node has three operands: a chain, a register number to set to this value, and a value.</td></tr><tr><td class="is-family-code">CopyFromReg</td><td class="is-family-code">48</td><td>CopyFromReg - This node indicates that the input value is a virtual or physical register that is defined outside of the scope of this SelectionDAG.  The register is available from the RegisterSDNode object.</td></tr><tr><td class="is-family-code">UNDEF</td><td class="is-family-code">49</td><td>UNDEF - An undefined node.</td></tr><tr><td class="is-family-code">EXTRACT_ELEMENT</td><td class="is-family-code">50</td><td>EXTRACT_ELEMENT - This is used to get the lower or upper (determined by a Constant, which is required to be operand #1) half of the integer or float value specified as operand #0.  This is only for use before legalization, for values that will be broken into multiple registers.</td></tr><tr><td class="is-family-code">BUILD_PAIR</td><td class="is-family-code">51</td><td>BUILD_PAIR - This is the opposite of EXTRACT_ELEMENT in some ways. Given two values of the same integer value type, this produces a value twice as big.  Like EXTRACT_ELEMENT, this can only be used before legalization. The lower part of the composite value should be in element 0 and the upper part should be in element 1.</td></tr><tr><td class="is-family-code">MERGE_VALUES</td><td class="is-family-code">52</td><td>MERGE_VALUES - This node takes multiple discrete operands and returns them all as its individual results.  This nodes has exactly the same number of inputs and outputs. This node is useful for some pieces of the code generator that want to think about a single node with multiple results, not multiple nodes.</td></tr><tr><td class="is-family-code">ADD</td><td class="is-family-code">53</td><td>Simple integer binary arithmetic operators.</td></tr><tr><td class="is-family-code">SUB</td><td class="is-family-code">54</td><td>Simple integer binary arithmetic operators.</td></tr><tr><td class="is-family-code">MUL</td><td class="is-family-code">55</td><td>Simple integer binary arithmetic operators.</td></tr><tr><td class="is-family-code">SDIV</td><td class="is-family-code">56</td><td>Simple integer binary arithmetic operators.</td></tr><tr><td class="is-family-code">UDIV</td><td class="is-family-code">57</td><td>Simple integer binary arithmetic operators.</td></tr><tr><td class="is-family-code">SREM</td><td class="is-family-code">58</td><td>Simple integer binary arithmetic operators.</td></tr><tr><td class="is-family-code">UREM</td><td class="is-family-code">59</td><td>Simple integer binary arithmetic operators.</td></tr><tr><td class="is-family-code">SMUL_LOHI</td><td class="is-family-code">60</td><td>SMUL_LOHI/UMUL_LOHI - Multiply two integers of type iN, producing a signed/unsigned value of type i[2*N], and return the full value as two results, each of type iN.</td></tr><tr><td class="is-family-code">UMUL_LOHI</td><td class="is-family-code">61</td><td>SMUL_LOHI/UMUL_LOHI - Multiply two integers of type iN, producing a signed/unsigned value of type i[2*N], and return the full value as two results, each of type iN.</td></tr><tr><td class="is-family-code">SDIVREM</td><td class="is-family-code">62</td><td>SDIVREM/UDIVREM - Divide two integers and produce both a quotient and remainder result.</td></tr><tr><td class="is-family-code">UDIVREM</td><td class="is-family-code">63</td><td>SDIVREM/UDIVREM - Divide two integers and produce both a quotient and remainder result.</td></tr><tr><td class="is-family-code">CARRY_FALSE</td><td class="is-family-code">64</td><td>CARRY_FALSE - This node is used when folding other nodes, like ADDC/SUBC, which indicate the carry result is always false.</td></tr><tr><td class="is-family-code">ADDC</td><td class="is-family-code">65</td><td>Carry-setting nodes for multiple precision addition and subtraction. These nodes take two operands of the same value type, and produce two results.  The first result is the normal add or sub result, the second result is the carry flag result. FIXME: These nodes are deprecated in favor of ADDCARRY and SUBCARRY. They are kept around for now to provide a smooth transition path toward the use of ADDCARRY/SUBCARRY and will eventually be removed.</td></tr><tr><td class="is-family-code">SUBC</td><td class="is-family-code">66</td><td>Carry-setting nodes for multiple precision addition and subtraction. These nodes take two operands of the same value type, and produce two results.  The first result is the normal add or sub result, the second result is the carry flag result. FIXME: These nodes are deprecated in favor of ADDCARRY and SUBCARRY. They are kept around for now to provide a smooth transition path toward the use of ADDCARRY/SUBCARRY and will eventually be removed.</td></tr><tr><td class="is-family-code">ADDE</td><td class="is-family-code">67</td><td>Carry-using nodes for multiple precision addition and subtraction. These nodes take three operands: The first two are the normal lhs and rhs to the add or sub, and the third is the input carry flag.  These nodes produce two results; the normal result of the add or sub, and the output carry flag.  These nodes both read and write a carry flag to allow them to them to be chained together for add and sub of arbitrarily large values.</td></tr><tr><td class="is-family-code">SUBE</td><td class="is-family-code">68</td><td>Carry-using nodes for multiple precision addition and subtraction. These nodes take three operands: The first two are the normal lhs and rhs to the add or sub, and the third is the input carry flag.  These nodes produce two results; the normal result of the add or sub, and the output carry flag.  These nodes both read and write a carry flag to allow them to them to be chained together for add and sub of arbitrarily large values.</td></tr><tr><td class="is-family-code">ADDCARRY</td><td class="is-family-code">69</td><td>Carry-using nodes for multiple precision addition and subtraction. These nodes take three operands: The first two are the normal lhs and rhs to the add or sub, and the third is a boolean indicating if there is an incoming carry. These nodes produce two results: the normal result of the add or sub, and the output carry so they can be chained together. The use of this opcode is preferable to adde/sube if the target supports it, as the carry is a regular value rather than a glue, which allows further optimisation.</td></tr><tr><td class="is-family-code">SUBCARRY</td><td class="is-family-code">70</td><td>Carry-using nodes for multiple precision addition and subtraction. These nodes take three operands: The first two are the normal lhs and rhs to the add or sub, and the third is a boolean indicating if there is an incoming carry. These nodes produce two results: the normal result of the add or sub, and the output carry so they can be chained together. The use of this opcode is preferable to adde/sube if the target supports it, as the carry is a regular value rather than a glue, which allows further optimisation.</td></tr><tr><td class="is-family-code">SADDO</td><td class="is-family-code">71</td><td>RESULT, BOOL = [SU]ADDO(LHS, RHS) - Overflow-aware nodes for addition. These nodes take two operands: the normal LHS and RHS to the add. They produce two results: the normal result of the add, and a boolean that indicates if an overflow occurred (*not* a flag, because it may be store to memory, etc.).  If the type of the boolean is not i1 then the high bits conform to getBooleanContents. These nodes are generated from llvm.[su]add.with.overflow intrinsics.</td></tr><tr><td class="is-family-code">UADDO</td><td class="is-family-code">72</td><td>RESULT, BOOL = [SU]ADDO(LHS, RHS) - Overflow-aware nodes for addition. These nodes take two operands: the normal LHS and RHS to the add. They produce two results: the normal result of the add, and a boolean that indicates if an overflow occurred (*not* a flag, because it may be store to memory, etc.).  If the type of the boolean is not i1 then the high bits conform to getBooleanContents. These nodes are generated from llvm.[su]add.with.overflow intrinsics.</td></tr><tr><td class="is-family-code">SSUBO</td><td class="is-family-code">73</td><td>Same for subtraction.</td></tr><tr><td class="is-family-code">USUBO</td><td class="is-family-code">74</td><td>Same for subtraction.</td></tr><tr><td class="is-family-code">SMULO</td><td class="is-family-code">75</td><td>Same for multiplication.</td></tr><tr><td class="is-family-code">UMULO</td><td class="is-family-code">76</td><td>Same for multiplication.</td></tr><tr><td class="is-family-code">SADDSAT</td><td class="is-family-code">77</td><td>RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2 integers with the same bit width (W). If the true value of LHS + RHS exceeds the largest value that can be represented by W bits, the resulting value is this maximum value. Otherwise, if this value is less than the smallest value that can be represented by W bits, the resulting value is this minimum value.</td></tr><tr><td class="is-family-code">UADDSAT</td><td class="is-family-code">78</td><td>RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2 integers with the same bit width (W). If the true value of LHS + RHS exceeds the largest value that can be represented by W bits, the resulting value is this maximum value. Otherwise, if this value is less than the smallest value that can be represented by W bits, the resulting value is this minimum value.</td></tr><tr><td class="is-family-code">SSUBSAT</td><td class="is-family-code">79</td><td>RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2 integers with the same bit width (W). If the true value of LHS - RHS exceeds the largest value that can be represented by W bits, the resulting value is this maximum value. Otherwise, if this value is less than the smallest value that can be represented by W bits, the resulting value is this minimum value.</td></tr><tr><td class="is-family-code">USUBSAT</td><td class="is-family-code">80</td><td>RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2 integers with the same bit width (W). If the true value of LHS - RHS exceeds the largest value that can be represented by W bits, the resulting value is this maximum value. Otherwise, if this value is less than the smallest value that can be represented by W bits, the resulting value is this minimum value.</td></tr><tr><td class="is-family-code">SMULFIX</td><td class="is-family-code">81</td><td>RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication on 2 integers with the same width and scale. SCALE represents the scale of both operands as fixed point numbers. This SCALE parameter must be a constant integer. A scale of zero is effectively performing multiplication on 2 integers.</td></tr><tr><td class="is-family-code">UMULFIX</td><td class="is-family-code">82</td><td>RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication on 2 integers with the same width and scale. SCALE represents the scale of both operands as fixed point numbers. This SCALE parameter must be a constant integer. A scale of zero is effectively performing multiplication on 2 integers.</td></tr><tr><td class="is-family-code">SMULFIXSAT</td><td class="is-family-code">83</td><td>Same as the corresponding unsaturated fixed point instructions, but the result is clamped between the min and max values representable by the bits of the first 2 operands.</td></tr><tr><td class="is-family-code">UMULFIXSAT</td><td class="is-family-code">84</td><td>Same as the corresponding unsaturated fixed point instructions, but the result is clamped between the min and max values representable by the bits of the first 2 operands.</td></tr><tr><td class="is-family-code">SDIVFIX</td><td class="is-family-code">85</td><td>RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on 2 integers with the same width and scale. SCALE represents the scale of both operands as fixed point numbers. This SCALE parameter must be a constant integer.</td></tr><tr><td class="is-family-code">UDIVFIX</td><td class="is-family-code">86</td><td>RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on 2 integers with the same width and scale. SCALE represents the scale of both operands as fixed point numbers. This SCALE parameter must be a constant integer.</td></tr><tr><td class="is-family-code">FADD</td><td class="is-family-code">87</td><td>Simple binary floating point operators.</td></tr><tr><td class="is-family-code">FSUB</td><td class="is-family-code">88</td><td>Simple binary floating point operators.</td></tr><tr><td class="is-family-code">FMUL</td><td class="is-family-code">89</td><td>Simple binary floating point operators.</td></tr><tr><td class="is-family-code">FDIV</td><td class="is-family-code">90</td><td>Simple binary floating point operators.</td></tr><tr><td class="is-family-code">FREM</td><td class="is-family-code">91</td><td>Simple binary floating point operators.</td></tr><tr><td class="is-family-code">STRICT_FADD</td><td class="is-family-code">92</td><td>Constrained versions of the binary floating point operators. These will be lowered to the simple operators before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FSUB</td><td class="is-family-code">93</td><td>Constrained versions of the binary floating point operators. These will be lowered to the simple operators before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FMUL</td><td class="is-family-code">94</td><td>Constrained versions of the binary floating point operators. These will be lowered to the simple operators before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FDIV</td><td class="is-family-code">95</td><td>Constrained versions of the binary floating point operators. These will be lowered to the simple operators before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FREM</td><td class="is-family-code">96</td><td>Constrained versions of the binary floating point operators. These will be lowered to the simple operators before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FMA</td><td class="is-family-code">97</td><td>Constrained versions of the binary floating point operators. These will be lowered to the simple operators before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FSQRT</td><td class="is-family-code">98</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FPOW</td><td class="is-family-code">99</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FPOWI</td><td class="is-family-code">100</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FSIN</td><td class="is-family-code">101</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FCOS</td><td class="is-family-code">102</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FEXP</td><td class="is-family-code">103</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FEXP2</td><td class="is-family-code">104</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FLOG</td><td class="is-family-code">105</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FLOG10</td><td class="is-family-code">106</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FLOG2</td><td class="is-family-code">107</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FRINT</td><td class="is-family-code">108</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FNEARBYINT</td><td class="is-family-code">109</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FMAXNUM</td><td class="is-family-code">110</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FMINNUM</td><td class="is-family-code">111</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FCEIL</td><td class="is-family-code">112</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FFLOOR</td><td class="is-family-code">113</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FROUND</td><td class="is-family-code">114</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FTRUNC</td><td class="is-family-code">115</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_LROUND</td><td class="is-family-code">116</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_LLROUND</td><td class="is-family-code">117</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_LRINT</td><td class="is-family-code">118</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_LLRINT</td><td class="is-family-code">119</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FMAXIMUM</td><td class="is-family-code">120</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FMINIMUM</td><td class="is-family-code">121</td><td>Constrained versions of libm-equivalent floating point intrinsics. These will be lowered to the equivalent non-constrained pseudo-op (or expanded to the equivalent library call) before final selection. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FP_TO_SINT</td><td class="is-family-code">122</td><td>STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or unsigned integer. These have the same semantics as fptosi and fptoui  in IR. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FP_TO_UINT</td><td class="is-family-code">123</td><td>STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or unsigned integer. These have the same semantics as fptosi and fptoui  in IR. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_SINT_TO_FP</td><td class="is-family-code">124</td><td>STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to a floating point value. These have the same semantics as sitofp and uitofp in IR. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_UINT_TO_FP</td><td class="is-family-code">125</td><td>STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to a floating point value. These have the same semantics as sitofp and uitofp in IR. They are used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FP_ROUND</td><td class="is-family-code">126</td><td>X = STRICT_FP_ROUND(Y, TRUNC) - Rounding &apos;Y&apos; from a larger floating  point type down to the precision of the destination VT.  TRUNC is a  flag, which is always an integer that is zero or one.  If TRUNC is 0, this is a normal rounding, if it is 1, this FP_ROUND is known to not change the value of Y.The TRUNC = 1 case is used in cases where we know that the value will not be modified by the node, because Y is not using any of the extra precision of source type.  This allows certain transformations like STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -&gt; X which are not safe for STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren&apos;t removed. It is used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FP_EXTEND</td><td class="is-family-code">127</td><td>X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type. It is used to limit optimizations while the DAG is being optimized.</td></tr><tr><td class="is-family-code">STRICT_FSETCC</td><td class="is-family-code">128</td><td>STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used for floating-point operands only.  STRICT_FSETCC performs a quiet comparison operation, while STRICT_FSETCCS performs a signaling comparison operation.</td></tr><tr><td class="is-family-code">STRICT_FSETCCS</td><td class="is-family-code">129</td><td>STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used for floating-point operands only.  STRICT_FSETCC performs a quiet comparison operation, while STRICT_FSETCCS performs a signaling comparison operation.</td></tr><tr><td class="is-family-code">FMA</td><td class="is-family-code">130</td><td>FMA - Perform a * b + c with no intermediate rounding step.</td></tr><tr><td class="is-family-code">FMAD</td><td class="is-family-code">131</td><td>FMAD - Perform a * b + c, while getting the same result as the separately rounded operations.</td></tr><tr><td class="is-family-code">FCOPYSIGN</td><td class="is-family-code">132</td><td>FCOPYSIGN(X, Y) - Return the value of X with the sign of Y.  NOTE: This DAG node does not require that X and Y have the same type, just that they are both floating point.  X and the result must have the same type. FCOPYSIGN(f32, f64) is allowed.</td></tr><tr><td class="is-family-code">FGETSIGN</td><td class="is-family-code">133</td><td>INT = FGETSIGN(FP) - Return the sign bit of the specified floating point value as an integer 0/1 value.</td></tr><tr><td class="is-family-code">FCANONICALIZE</td><td class="is-family-code">134</td><td>Returns platform specific canonical encoding of a floating point number.</td></tr><tr><td class="is-family-code">BUILD_VECTOR</td><td class="is-family-code">135</td><td>BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...) - Return a vector with the specified, possibly variable, elements.  The number of elements is required to be a power of two.  The types of the operands must all be the same and must match the vector element type, except that integer types are allowed to be larger than the element type, in which case the operands are implicitly truncated.</td></tr><tr><td class="is-family-code">INSERT_VECTOR_ELT</td><td class="is-family-code">136</td><td>INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element at IDX replaced with VAL.  If the type of VAL is larger than the vector element type then VAL is truncated before replacement.</td></tr><tr><td class="is-family-code">EXTRACT_VECTOR_ELT</td><td class="is-family-code">137</td><td>EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR identified by the (potentially variable) element number IDX.  If the return type is an integer type larger than the element type of the vector, the result is extended to the width of the return type. In that case, the high bits are undefined.</td></tr><tr><td class="is-family-code">CONCAT_VECTORS</td><td class="is-family-code">138</td><td>CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of vector type with the same length and element type, this produces a concatenated vector result value, with length equal to the sum of the lengths of the input vectors.</td></tr><tr><td class="is-family-code">INSERT_SUBVECTOR</td><td class="is-family-code">139</td><td>INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2 inserted into VECTOR1 at the (potentially variable) element number IDX, which must be a multiple of the VECTOR2 vector length.  The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.  Elements IDX through vector_length(VECTOR2) must be valid VECTOR1 indices.</td></tr><tr><td class="is-family-code">EXTRACT_SUBVECTOR</td><td class="is-family-code">140</td><td>EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR (an vector value) starting with the element number IDX, which must be a constant multiple of the result vector length.</td></tr><tr><td class="is-family-code">VECTOR_SHUFFLE</td><td class="is-family-code">141</td><td>VECTOR_SHUFFLE(VEC1, VEC2) - Returns a vector, of the same type as VEC1/VEC2.  A VECTOR_SHUFFLE node also contains an array of constant int values that indicate which value (or undef) each result element will get.  These constant ints are accessible through the ShuffleVectorSDNode class.  This is quite similar to the Altivec &apos;vperm&apos; instruction, except that the indices must be constants and are in terms of the element size of VEC1/VEC2, not in terms of bytes.</td></tr><tr><td class="is-family-code">SCALAR_TO_VECTOR</td><td class="is-family-code">142</td><td>SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a scalar value into element 0 of the resultant vector type.  The top elements 1 to N-1 of the N-element vector are undefined.  The type of the operand must match the vector element type, except when they are integer types.  In this case the operand is allowed to be wider than the vector element type, and is implicitly truncated to it.</td></tr><tr><td class="is-family-code">SPLAT_VECTOR</td><td class="is-family-code">143</td><td>SPLAT_VECTOR(VAL) - Returns a vector with the scalar value VAL duplicated in all lanes. The type of the operand must match the vector element type, except when they are integer types.  In this case the operand is allowed to be wider than the vector element type, and is implicitly truncated to it.</td></tr><tr><td class="is-family-code">MULHU</td><td class="is-family-code">144</td><td>MULHU/MULHS - Multiply high - Multiply two integers of type iN, producing an unsigned/signed value of type i[2*N], then return the top part.</td></tr><tr><td class="is-family-code">MULHS</td><td class="is-family-code">145</td><td>MULHU/MULHS - Multiply high - Multiply two integers of type iN, producing an unsigned/signed value of type i[2*N], then return the top part.</td></tr><tr><td class="is-family-code">SMIN</td><td class="is-family-code">146</td><td>[US]{MIN/MAX} - Binary minimum or maximum or signed or unsigned integers.</td></tr><tr><td class="is-family-code">SMAX</td><td class="is-family-code">147</td><td>[US]{MIN/MAX} - Binary minimum or maximum or signed or unsigned integers.</td></tr><tr><td class="is-family-code">UMIN</td><td class="is-family-code">148</td><td>[US]{MIN/MAX} - Binary minimum or maximum or signed or unsigned integers.</td></tr><tr><td class="is-family-code">UMAX</td><td class="is-family-code">149</td><td>[US]{MIN/MAX} - Binary minimum or maximum or signed or unsigned integers.</td></tr><tr><td class="is-family-code">AND</td><td class="is-family-code">150</td><td>Bitwise operators - logical and, logical or, logical xor.</td></tr><tr><td class="is-family-code">OR</td><td class="is-family-code">151</td><td>Bitwise operators - logical and, logical or, logical xor.</td></tr><tr><td class="is-family-code">XOR</td><td class="is-family-code">152</td><td>Bitwise operators - logical and, logical or, logical xor.</td></tr><tr><td class="is-family-code">ABS</td><td class="is-family-code">153</td><td>ABS - Determine the unsigned absolute value of a signed integer value of the same bitwidth. Note: A value of INT_MIN will return INT_MIN, no saturation or overflow is performed.</td></tr><tr><td class="is-family-code">SHL</td><td class="is-family-code">154</td><td>Shift and rotation operations.  After legalization, the type of the shift amount is known to be TLI.getShiftAmountTy().  Before legalization the shift amount can be any type, but care must be taken to ensure it is large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before legalization, types like i1024 can occur and i8 doesn&apos;t have enough bits to represent the shift amount. When the 1st operand is a vector, the shift amount must be in the same type. (TLI.getShiftAmountTy() will return the same type when the input type is a vector.) For rotates and funnel shifts, the shift amount is treated as an unsigned amount modulo the element size of the first operand.Funnel &apos;double&apos; shifts take 3 operands, 2 inputs and the shift amount. fshl(X,Y,Z): (X  &lt; &lt; (Z % BW)) | (Y &gt;&gt; (BW - (Z % BW))) fshr(X,Y,Z): (X  &lt; &lt; (BW - (Z % BW))) | (Y &gt;&gt; (Z % BW))</td></tr><tr><td class="is-family-code">SRA</td><td class="is-family-code">155</td><td>Shift and rotation operations.  After legalization, the type of the shift amount is known to be TLI.getShiftAmountTy().  Before legalization the shift amount can be any type, but care must be taken to ensure it is large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before legalization, types like i1024 can occur and i8 doesn&apos;t have enough bits to represent the shift amount. When the 1st operand is a vector, the shift amount must be in the same type. (TLI.getShiftAmountTy() will return the same type when the input type is a vector.) For rotates and funnel shifts, the shift amount is treated as an unsigned amount modulo the element size of the first operand.Funnel &apos;double&apos; shifts take 3 operands, 2 inputs and the shift amount. fshl(X,Y,Z): (X  &lt; &lt; (Z % BW)) | (Y &gt;&gt; (BW - (Z % BW))) fshr(X,Y,Z): (X  &lt; &lt; (BW - (Z % BW))) | (Y &gt;&gt; (Z % BW))</td></tr><tr><td class="is-family-code">SRL</td><td class="is-family-code">156</td><td>Shift and rotation operations.  After legalization, the type of the shift amount is known to be TLI.getShiftAmountTy().  Before legalization the shift amount can be any type, but care must be taken to ensure it is large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before legalization, types like i1024 can occur and i8 doesn&apos;t have enough bits to represent the shift amount. When the 1st operand is a vector, the shift amount must be in the same type. (TLI.getShiftAmountTy() will return the same type when the input type is a vector.) For rotates and funnel shifts, the shift amount is treated as an unsigned amount modulo the element size of the first operand.Funnel &apos;double&apos; shifts take 3 operands, 2 inputs and the shift amount. fshl(X,Y,Z): (X  &lt; &lt; (Z % BW)) | (Y &gt;&gt; (BW - (Z % BW))) fshr(X,Y,Z): (X  &lt; &lt; (BW - (Z % BW))) | (Y &gt;&gt; (Z % BW))</td></tr><tr><td class="is-family-code">ROTL</td><td class="is-family-code">157</td><td>Shift and rotation operations.  After legalization, the type of the shift amount is known to be TLI.getShiftAmountTy().  Before legalization the shift amount can be any type, but care must be taken to ensure it is large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before legalization, types like i1024 can occur and i8 doesn&apos;t have enough bits to represent the shift amount. When the 1st operand is a vector, the shift amount must be in the same type. (TLI.getShiftAmountTy() will return the same type when the input type is a vector.) For rotates and funnel shifts, the shift amount is treated as an unsigned amount modulo the element size of the first operand.Funnel &apos;double&apos; shifts take 3 operands, 2 inputs and the shift amount. fshl(X,Y,Z): (X  &lt; &lt; (Z % BW)) | (Y &gt;&gt; (BW - (Z % BW))) fshr(X,Y,Z): (X  &lt; &lt; (BW - (Z % BW))) | (Y &gt;&gt; (Z % BW))</td></tr><tr><td class="is-family-code">ROTR</td><td class="is-family-code">158</td><td>Shift and rotation operations.  After legalization, the type of the shift amount is known to be TLI.getShiftAmountTy().  Before legalization the shift amount can be any type, but care must be taken to ensure it is large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before legalization, types like i1024 can occur and i8 doesn&apos;t have enough bits to represent the shift amount. When the 1st operand is a vector, the shift amount must be in the same type. (TLI.getShiftAmountTy() will return the same type when the input type is a vector.) For rotates and funnel shifts, the shift amount is treated as an unsigned amount modulo the element size of the first operand.Funnel &apos;double&apos; shifts take 3 operands, 2 inputs and the shift amount. fshl(X,Y,Z): (X  &lt; &lt; (Z % BW)) | (Y &gt;&gt; (BW - (Z % BW))) fshr(X,Y,Z): (X  &lt; &lt; (BW - (Z % BW))) | (Y &gt;&gt; (Z % BW))</td></tr><tr><td class="is-family-code">FSHL</td><td class="is-family-code">159</td><td>Shift and rotation operations.  After legalization, the type of the shift amount is known to be TLI.getShiftAmountTy().  Before legalization the shift amount can be any type, but care must be taken to ensure it is large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before legalization, types like i1024 can occur and i8 doesn&apos;t have enough bits to represent the shift amount. When the 1st operand is a vector, the shift amount must be in the same type. (TLI.getShiftAmountTy() will return the same type when the input type is a vector.) For rotates and funnel shifts, the shift amount is treated as an unsigned amount modulo the element size of the first operand.Funnel &apos;double&apos; shifts take 3 operands, 2 inputs and the shift amount. fshl(X,Y,Z): (X  &lt; &lt; (Z % BW)) | (Y &gt;&gt; (BW - (Z % BW))) fshr(X,Y,Z): (X  &lt; &lt; (BW - (Z % BW))) | (Y &gt;&gt; (Z % BW))</td></tr><tr><td class="is-family-code">FSHR</td><td class="is-family-code">160</td><td>Shift and rotation operations.  After legalization, the type of the shift amount is known to be TLI.getShiftAmountTy().  Before legalization the shift amount can be any type, but care must be taken to ensure it is large enough.  TLI.getShiftAmountTy() is i8 on some targets, but before legalization, types like i1024 can occur and i8 doesn&apos;t have enough bits to represent the shift amount. When the 1st operand is a vector, the shift amount must be in the same type. (TLI.getShiftAmountTy() will return the same type when the input type is a vector.) For rotates and funnel shifts, the shift amount is treated as an unsigned amount modulo the element size of the first operand.Funnel &apos;double&apos; shifts take 3 operands, 2 inputs and the shift amount. fshl(X,Y,Z): (X  &lt; &lt; (Z % BW)) | (Y &gt;&gt; (BW - (Z % BW))) fshr(X,Y,Z): (X  &lt; &lt; (BW - (Z % BW))) | (Y &gt;&gt; (Z % BW))</td></tr><tr><td class="is-family-code">BSWAP</td><td class="is-family-code">161</td><td>Byte Swap and Counting operators.</td></tr><tr><td class="is-family-code">CTTZ</td><td class="is-family-code">162</td><td>Byte Swap and Counting operators.</td></tr><tr><td class="is-family-code">CTLZ</td><td class="is-family-code">163</td><td>Byte Swap and Counting operators.</td></tr><tr><td class="is-family-code">CTPOP</td><td class="is-family-code">164</td><td>Byte Swap and Counting operators.</td></tr><tr><td class="is-family-code">BITREVERSE</td><td class="is-family-code">165</td><td>Byte Swap and Counting operators.</td></tr><tr><td class="is-family-code">CTTZ_ZERO_UNDEF</td><td class="is-family-code">166</td><td>Bit counting operators with an undefined result for zero inputs.</td></tr><tr><td class="is-family-code">CTLZ_ZERO_UNDEF</td><td class="is-family-code">167</td><td>Bit counting operators with an undefined result for zero inputs.</td></tr><tr><td class="is-family-code">SELECT</td><td class="is-family-code">168</td><td>Select(COND, TRUEVAL, FALSEVAL).  If the type of the boolean COND is not i1 then the high bits must conform to getBooleanContents.</td></tr><tr><td class="is-family-code">VSELECT</td><td class="is-family-code">169</td><td>Select with a vector condition (op #0) and two vector operands (ops #1 and #2), returning a vector result.  All vectors have the same length. Much like the scalar select and setcc, each bit in the condition selects whether the corresponding result element is taken from op #1 or op #2. At first, the VSELECT condition is of vXi1 type. Later, targets may change the condition type in order to match the VSELECT node using a pattern. The condition follows the BooleanContent format of the target.</td></tr><tr><td class="is-family-code">SELECT_CC</td><td class="is-family-code">170</td><td>Select with condition operator - This selects between a true value and a false value (ops #2 and #3) based on the boolean result of comparing the lhs and rhs (ops #0 and #1) of a conditional expression with the condition code in op #4, a CondCodeSDNode.</td></tr><tr><td class="is-family-code">SETCC</td><td class="is-family-code">171</td><td>SetCC operator - This evaluates to a true value iff the condition is true.  If the result value type is not i1 then the high bits conform to getBooleanContents.  The operands to this are the left and right operands to compare (ops #0, and #1) and the condition code to compare them with (op #2) as a CondCodeSDNode. If the operands are vector types then the result type must also be a vector type.</td></tr><tr><td class="is-family-code">SETCCCARRY</td><td class="is-family-code">172</td><td>Like SetCC, ops #0 and #1 are the LHS and RHS operands to compare, but op #2 is a boolean indicating if there is an incoming carry. This operator checks the result of &quot;LHS - RHS - Carry&quot;, and can be used to compare two wide integers: (setcccarry lhshi rhshi (subcarry lhslo rhslo) cc). Only valid for integers.</td></tr><tr><td class="is-family-code">SHL_PARTS</td><td class="is-family-code">173</td><td>SHL_PARTS/SRA_PARTS/SRL_PARTS - These operators are used for expanded integer shift operations.  The operation ordering is: [Lo,Hi] = op [LoLHS,HiLHS], Amt</td></tr><tr><td class="is-family-code">SRA_PARTS</td><td class="is-family-code">174</td><td>SHL_PARTS/SRA_PARTS/SRL_PARTS - These operators are used for expanded integer shift operations.  The operation ordering is: [Lo,Hi] = op [LoLHS,HiLHS], Amt</td></tr><tr><td class="is-family-code">SRL_PARTS</td><td class="is-family-code">175</td><td>SHL_PARTS/SRA_PARTS/SRL_PARTS - These operators are used for expanded integer shift operations.  The operation ordering is: [Lo,Hi] = op [LoLHS,HiLHS], Amt</td></tr><tr><td class="is-family-code">SIGN_EXTEND</td><td class="is-family-code">176</td><td>SIGN_EXTEND - Used for integer types, replicating the sign bit into new bits.</td></tr><tr><td class="is-family-code">ZERO_EXTEND</td><td class="is-family-code">177</td><td>ZERO_EXTEND - Used for integer types, zeroing the new bits.</td></tr><tr><td class="is-family-code">ANY_EXTEND</td><td class="is-family-code">178</td><td>ANY_EXTEND - Used for integer types.  The high bits are undefined.</td></tr><tr><td class="is-family-code">TRUNCATE</td><td class="is-family-code">179</td><td>TRUNCATE - Completely drop the high bits.</td></tr><tr><td class="is-family-code">SINT_TO_FP</td><td class="is-family-code">180</td><td>[SU]INT_TO_FP - These operators convert integers (whose interpreted sign depends on the first letter) to floating point.</td></tr><tr><td class="is-family-code">UINT_TO_FP</td><td class="is-family-code">181</td><td>[SU]INT_TO_FP - These operators convert integers (whose interpreted sign depends on the first letter) to floating point.</td></tr><tr><td class="is-family-code">SIGN_EXTEND_INREG</td><td class="is-family-code">182</td><td>SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to sign extend a small value in a large integer register (e.g. sign extending the low 8 bits of a 32-bit register to fill the top 24 bits with the 7th bit).  The size of the smaller type is indicated by the 1th operand, a ValueType node.</td></tr><tr><td class="is-family-code">ANY_EXTEND_VECTOR_INREG</td><td class="is-family-code">183</td><td>ANY_EXTEND_VECTOR_INREG(Vector) - This operator represents an in-register any-extension of the low lanes of an integer vector. The result type must have fewer elements than the operand type, and those elements must be larger integer types such that the total size of the operand type is less than or equal to the size of the result type. Each of the low operand elements is any-extended into the corresponding, wider result elements with the high bits becoming undef. NOTE: The type legalizer prefers to make the operand and result size the same to allow expansion to shuffle vector during op legalization.</td></tr><tr><td class="is-family-code">SIGN_EXTEND_VECTOR_INREG</td><td class="is-family-code">184</td><td>SIGN_EXTEND_VECTOR_INREG(Vector) - This operator represents an in-register sign-extension of the low lanes of an integer vector. The result type must have fewer elements than the operand type, and those elements must be larger integer types such that the total size of the operand type is less than or equal to the size of the result type. Each of the low operand elements is sign-extended into the corresponding, wider result elements. NOTE: The type legalizer prefers to make the operand and result size the same to allow expansion to shuffle vector during op legalization.</td></tr><tr><td class="is-family-code">ZERO_EXTEND_VECTOR_INREG</td><td class="is-family-code">185</td><td>ZERO_EXTEND_VECTOR_INREG(Vector) - This operator represents an in-register zero-extension of the low lanes of an integer vector. The result type must have fewer elements than the operand type, and those elements must be larger integer types such that the total size of the operand type is less than or equal to the size of the result type. Each of the low operand elements is zero-extended into the corresponding, wider result elements. NOTE: The type legalizer prefers to make the operand and result size the same to allow expansion to shuffle vector during op legalization.</td></tr><tr><td class="is-family-code">FP_TO_SINT</td><td class="is-family-code">186</td><td>FP_TO_[US]INT - Convert a floating point value to a signed or unsigned integer. These have the same semantics as fptosi and fptoui in IR. If the FP value cannot fit in the integer type, the results are undefined.</td></tr><tr><td class="is-family-code">FP_TO_UINT</td><td class="is-family-code">187</td><td>FP_TO_[US]INT - Convert a floating point value to a signed or unsigned integer. These have the same semantics as fptosi and fptoui in IR. If the FP value cannot fit in the integer type, the results are undefined.</td></tr><tr><td class="is-family-code">FP_ROUND</td><td class="is-family-code">188</td><td>X = FP_ROUND(Y, TRUNC) - Rounding &apos;Y&apos; from a larger floating point type down to the precision of the destination VT.  TRUNC is a flag, which is always an integer that is zero or one.  If TRUNC is 0, this is a normal rounding, if it is 1, this FP_ROUND is known to not change the value of Y.The TRUNC = 1 case is used in cases where we know that the value will not be modified by the node, because Y is not using any of the extra precision of source type.  This allows certain transformations like FP_EXTEND(FP_ROUND(X,1)) -&gt; X which are not safe for FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren&apos;t removed.</td></tr><tr><td class="is-family-code">FLT_ROUNDS_</td><td class="is-family-code">189</td><td>FLT_ROUNDS_ - Returns current rounding mode: -1 Undefined 0 Round to 0 1 Round to nearest 2 Round to +inf 3 Round to -inf</td></tr><tr><td class="is-family-code">FP_EXTEND</td><td class="is-family-code">190</td><td>X = FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.</td></tr><tr><td class="is-family-code">BITCAST</td><td class="is-family-code">191</td><td>BITCAST - This operator converts between integer, vector and FP values, as if the value was stored to memory with one type and loaded from the same address with the other type (or equivalently for vector format conversions, etc).  The source and result are required to have the same bit size (e.g.  f32  &lt; -&gt; i32).  This can also be used for int-to-int or fp-to-fp conversions, but that is a noop, deleted by getNode().This operator is subtly different from the bitcast instruction from LLVM-IR since this node may change the bits in the register. For example, this occurs on big-endian NEON and big-endian MSA where the layout of the bits in the register depends on the vector type and this operator acts as a shuffle operation for some vector type combinations.</td></tr><tr><td class="is-family-code">ADDRSPACECAST</td><td class="is-family-code">192</td><td>ADDRSPACECAST - This operator converts between pointers of different address spaces.</td></tr><tr><td class="is-family-code">FP16_TO_FP</td><td class="is-family-code">193</td><td>FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions and truncation for half-precision (16 bit) floating numbers. These nodes form a semi-softened interface for dealing with f16 (as an i16), which is often a storage-only type but has native conversions.</td></tr><tr><td class="is-family-code">FP_TO_FP16</td><td class="is-family-code">194</td><td>FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions and truncation for half-precision (16 bit) floating numbers. These nodes form a semi-softened interface for dealing with f16 (as an i16), which is often a storage-only type but has native conversions.</td></tr><tr><td class="is-family-code">FNEG</td><td class="is-family-code">195</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FABS</td><td class="is-family-code">196</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FSQRT</td><td class="is-family-code">197</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FCBRT</td><td class="is-family-code">198</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FSIN</td><td class="is-family-code">199</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FCOS</td><td class="is-family-code">200</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FPOWI</td><td class="is-family-code">201</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FPOW</td><td class="is-family-code">202</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FLOG</td><td class="is-family-code">203</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FLOG2</td><td class="is-family-code">204</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FLOG10</td><td class="is-family-code">205</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FEXP</td><td class="is-family-code">206</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FEXP2</td><td class="is-family-code">207</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FCEIL</td><td class="is-family-code">208</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FTRUNC</td><td class="is-family-code">209</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FRINT</td><td class="is-family-code">210</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FNEARBYINT</td><td class="is-family-code">211</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FROUND</td><td class="is-family-code">212</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FFLOOR</td><td class="is-family-code">213</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">LROUND</td><td class="is-family-code">214</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">LLROUND</td><td class="is-family-code">215</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">LRINT</td><td class="is-family-code">216</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">LLRINT</td><td class="is-family-code">217</td><td>Perform various unary floating-point operations inspired by libm. For FPOWI, the result is undefined if if the integer operand doesn&apos;t fit into 32 bits.</td></tr><tr><td class="is-family-code">FMINNUM</td><td class="is-family-code">218</td><td>In the case where a single input is a NaN (either signaling or quiet), the non-NaN input is returned.The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.</td></tr><tr><td class="is-family-code">FMAXNUM</td><td class="is-family-code">219</td><td>In the case where a single input is a NaN (either signaling or quiet), the non-NaN input is returned.The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.</td></tr><tr><td class="is-family-code">FMINNUM_IEEE</td><td class="is-family-code">220</td><td>FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on two values, following the IEEE-754 2008 definition. This differs from FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a signaling NaN, returns a quiet NaN.</td></tr><tr><td class="is-family-code">FMAXNUM_IEEE</td><td class="is-family-code">221</td><td>FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on two values, following the IEEE-754 2008 definition. This differs from FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a signaling NaN, returns a quiet NaN.</td></tr><tr><td class="is-family-code">FMINIMUM</td><td class="is-family-code">222</td><td>FMINIMUM/FMAXIMUM - NaN-propagating minimum/maximum that also treat -0.0 as less than 0.0. While FMINNUM_IEEE/FMAXNUM_IEEE follow IEEE 754-2008 semantics, FMINIMUM/FMAXIMUM follow IEEE 754-2018 draft semantics.</td></tr><tr><td class="is-family-code">FMAXIMUM</td><td class="is-family-code">223</td><td>FMINIMUM/FMAXIMUM - NaN-propagating minimum/maximum that also treat -0.0 as less than 0.0. While FMINNUM_IEEE/FMAXNUM_IEEE follow IEEE 754-2008 semantics, FMINIMUM/FMAXIMUM follow IEEE 754-2018 draft semantics.</td></tr><tr><td class="is-family-code">FSINCOS</td><td class="is-family-code">224</td><td>FSINCOS - Compute both fsin and fcos as a single operation.</td></tr><tr><td class="is-family-code">LOAD</td><td class="is-family-code">225</td><td>LOAD and STORE have token chains as their first operand, then the same operands as an LLVM load/store instruction, then an offset node that is added / subtracted from the base pointer to form the address (for indexed memory ops).</td></tr><tr><td class="is-family-code">STORE</td><td class="is-family-code">226</td><td>LOAD and STORE have token chains as their first operand, then the same operands as an LLVM load/store instruction, then an offset node that is added / subtracted from the base pointer to form the address (for indexed memory ops).</td></tr><tr><td class="is-family-code">DYNAMIC_STACKALLOC</td><td class="is-family-code">227</td><td>DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned to a specified boundary.  This node always has two return values: a new stack pointer value and a chain. The first operand is the token chain, the second is the number of bytes to allocate, and the third is the alignment boundary.  The size is guaranteed to be a multiple of the stack alignment, and the alignment is guaranteed to be bigger than the stack alignment (if required) or 0 to get standard stack alignment.</td></tr><tr><td class="is-family-code">BR</td><td class="is-family-code">228</td><td>BR - Unconditional branch.  The first operand is the chain operand, the second is the MBB to branch to.</td></tr><tr><td class="is-family-code">BRIND</td><td class="is-family-code">229</td><td>BRIND - Indirect branch.  The first operand is the chain, the second is the value to branch to, which must be of the same type as the target&apos;s pointer type.</td></tr><tr><td class="is-family-code">BR_JT</td><td class="is-family-code">230</td><td>BR_JT - Jumptable branch. The first operand is the chain, the second is the jumptable index, the last one is the jumptable entry index.</td></tr><tr><td class="is-family-code">BRCOND</td><td class="is-family-code">231</td><td>BRCOND - Conditional branch.  The first operand is the chain, the second is the condition, the third is the block to branch to if the condition is true.  If the type of the condition is not i1, then the high bits must conform to getBooleanContents.</td></tr><tr><td class="is-family-code">BR_CC</td><td class="is-family-code">232</td><td>BR_CC - Conditional branch.  The behavior is like that of SELECT_CC, in that the condition is represented as condition code, and two nodes to compare, rather than as a combined SetCC node.  The operands in order are chain, cc, lhs, rhs, block to branch to if condition is true.</td></tr><tr><td class="is-family-code">INLINEASM</td><td class="is-family-code">233</td><td>INLINEASM - Represents an inline asm block.  This node always has two return values: a chain and a flag result.  The inputs are as follows: Operand #0  : Input chain. Operand #1  : a ExternalSymbolSDNode with a pointer to the asm string. Operand #2  : a MDNodeSDNode with the !srcloc metadata. Operand #3  : HasSideEffect, IsAlignStack bits. After this, it is followed by a list of operands with this format: ConstantSDNode: Flags that encode whether it is a mem or not, the of operands that follow, etc.  See InlineAsm.h. ... however many operands ... Operand #last: Optional, an incoming flag.The variable width operands are required to represent target addressing modes as a single &quot;operand&quot;, even though they may have multiple SDOperands.</td></tr><tr><td class="is-family-code">INLINEASM_BR</td><td class="is-family-code">234</td><td>INLINEASM_BR - Terminator version of inline asm. Used by asm-goto.</td></tr><tr><td class="is-family-code">EH_LABEL</td><td class="is-family-code">235</td><td>EH_LABEL - Represents a label in mid basic block used to track locations needed for debug and exception handling tables.  These nodes take a chain as input and return a chain.</td></tr><tr><td class="is-family-code">ANNOTATION_LABEL</td><td class="is-family-code">236</td><td>ANNOTATION_LABEL - Represents a mid basic block label used by annotations. This should remain within the basic block and be ordered with respect to other call instructions, but loads and stores may float past it.</td></tr><tr><td class="is-family-code">CATCHPAD</td><td class="is-family-code">237</td><td>CATCHPAD - Represents a catchpad instruction.</td></tr><tr><td class="is-family-code">CATCHRET</td><td class="is-family-code">238</td><td>CATCHRET - Represents a return from a catch block funclet. Used for MSVC compatible exception handling. Takes a chain operand and a destination basic block operand.</td></tr><tr><td class="is-family-code">CLEANUPRET</td><td class="is-family-code">239</td><td>CLEANUPRET - Represents a return from a cleanup block funclet.  Used for MSVC compatible exception handling. Takes only a chain operand.</td></tr><tr><td class="is-family-code">STACKSAVE</td><td class="is-family-code">240</td><td>STACKSAVE - STACKSAVE has one operand, an input chain.  It produces a value, the same type as the pointer type for the system, and an output chain.</td></tr><tr><td class="is-family-code">STACKRESTORE</td><td class="is-family-code">241</td><td>STACKRESTORE has two operands, an input chain and a pointer to restore to it returns an output chain.</td></tr><tr><td class="is-family-code">CALLSEQ_START</td><td class="is-family-code">242</td><td>CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end of a call sequence, and carry arbitrary information that target might want to know.  The first operand is a chain, the rest are specified by the target and not touched by the DAG optimizers. Targets that may use stack to pass call arguments define additional operands: - size of the call frame part that must be set up within the CALLSEQ_START..CALLSEQ_END pair, - part of the call frame prepared prior to CALLSEQ_START. Both these parameters must be constants, their sum is the total call frame size. CALLSEQ_START..CALLSEQ_END pairs may not be nested.</td></tr><tr><td class="is-family-code">CALLSEQ_END</td><td class="is-family-code">243</td><td>CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end of a call sequence, and carry arbitrary information that target might want to know.  The first operand is a chain, the rest are specified by the target and not touched by the DAG optimizers. Targets that may use stack to pass call arguments define additional operands: - size of the call frame part that must be set up within the CALLSEQ_START..CALLSEQ_END pair, - part of the call frame prepared prior to CALLSEQ_START. Both these parameters must be constants, their sum is the total call frame size. CALLSEQ_START..CALLSEQ_END pairs may not be nested.</td></tr><tr><td class="is-family-code">VAARG</td><td class="is-family-code">244</td><td>VAARG - VAARG has four operands: an input chain, a pointer, a SRCVALUE, and the alignment. It returns a pair of values: the vaarg value and a new chain.</td></tr><tr><td class="is-family-code">VACOPY</td><td class="is-family-code">245</td><td>VACOPY - VACOPY has 5 operands: an input chain, a destination pointer, a source pointer, a SRCVALUE for the destination, and a SRCVALUE for the source.</td></tr><tr><td class="is-family-code">VAEND</td><td class="is-family-code">246</td><td>VAEND, VASTART - VAEND and VASTART have three operands: an input chain, pointer, and a SRCVALUE.</td></tr><tr><td class="is-family-code">VASTART</td><td class="is-family-code">247</td><td>VAEND, VASTART - VAEND and VASTART have three operands: an input chain, pointer, and a SRCVALUE.</td></tr><tr><td class="is-family-code">SRCVALUE</td><td class="is-family-code">248</td><td>SRCVALUE - This is a node type that holds a Value* that is used to make reference to a value in the LLVM IR.</td></tr><tr><td class="is-family-code">MDNODE_SDNODE</td><td class="is-family-code">249</td><td>MDNODE_SDNODE - This is a node that holdes an MDNode*, which is used to reference metadata in the IR.</td></tr><tr><td class="is-family-code">PCMARKER</td><td class="is-family-code">250</td><td>PCMARKER - This corresponds to the pcmarker intrinsic.</td></tr><tr><td class="is-family-code">READCYCLECOUNTER</td><td class="is-family-code">251</td><td>READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic. It produces a chain and one i64 value. The only operand is a chain. If i64 is not legal, the result will be expanded into smaller values. Still, it returns an i64, so targets should set legality for i64. The result is the content of the architecture-specific cycle counter-like register (or other high accuracy low latency clock source).</td></tr><tr><td class="is-family-code">HANDLENODE</td><td class="is-family-code">252</td><td>HANDLENODE node - Used as a handle for various purposes.</td></tr><tr><td class="is-family-code">INIT_TRAMPOLINE</td><td class="is-family-code">253</td><td>INIT_TRAMPOLINE - This corresponds to the init_trampoline intrinsic.  It takes as input a token chain, the pointer to the trampoline, the pointer to the nested function, the pointer to pass for the &apos;nest&apos; parameter, a SRCVALUE for the trampoline and another for the nested function (allowing targets to access the original Function*). It produces a token chain as output.</td></tr><tr><td class="is-family-code">ADJUST_TRAMPOLINE</td><td class="is-family-code">254</td><td>ADJUST_TRAMPOLINE - This corresponds to the adjust_trampoline intrinsic. It takes a pointer to the trampoline and produces a (possibly) new pointer to the same trampoline with platform-specific adjustments applied.  The pointer it returns points to an executable block of code.</td></tr><tr><td class="is-family-code">TRAP</td><td class="is-family-code">255</td><td>TRAP - Trapping instruction</td></tr><tr><td class="is-family-code">DEBUGTRAP</td><td class="is-family-code">256</td><td>DEBUGTRAP - Trap intended to get the attention of a debugger.</td></tr><tr><td class="is-family-code">PREFETCH</td><td class="is-family-code">257</td><td>PREFETCH - This corresponds to a prefetch intrinsic. The first operand is the chain.  The other operands are the address to prefetch, read / write specifier, locality specifier and instruction / data cache specifier.</td></tr><tr><td class="is-family-code">ATOMIC_FENCE</td><td class="is-family-code">258</td><td>OUTCHAIN = ATOMIC_FENCE(INCHAIN, ordering, scope) This corresponds to the fence instruction. It takes an input chain, and two integer constants: an AtomicOrdering and a SynchronizationScope.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD</td><td class="is-family-code">259</td><td>Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr) This corresponds to &quot;load atomic&quot; instruction.</td></tr><tr><td class="is-family-code">ATOMIC_STORE</td><td class="is-family-code">260</td><td>OUTCHAIN = ATOMIC_STORE(INCHAIN, ptr, val) This corresponds to &quot;store atomic&quot; instruction.</td></tr><tr><td class="is-family-code">ATOMIC_CMP_SWAP</td><td class="is-family-code">261</td><td>Val, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmp, swap) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_CMP_SWAP(INCHAIN, ptr, cmpLo, cmpHi, swapLo, swapHi) This corresponds to the cmpxchg instruction.</td></tr><tr><td class="is-family-code">ATOMIC_CMP_SWAP_WITH_SUCCESS</td><td class="is-family-code">262</td><td>Val, Success, OUTCHAIN = ATOMIC_CMP_SWAP_WITH_SUCCESS(INCHAIN, ptr, cmp, swap) N.b. this is still a strong cmpxchg operation, so Success == &quot;Val == cmp&quot;.</td></tr><tr><td class="is-family-code">ATOMIC_SWAP</td><td class="is-family-code">263</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_ADD</td><td class="is-family-code">264</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_SUB</td><td class="is-family-code">265</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_AND</td><td class="is-family-code">266</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_CLR</td><td class="is-family-code">267</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_OR</td><td class="is-family-code">268</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_XOR</td><td class="is-family-code">269</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_NAND</td><td class="is-family-code">270</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_MIN</td><td class="is-family-code">271</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_MAX</td><td class="is-family-code">272</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_UMIN</td><td class="is-family-code">273</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_UMAX</td><td class="is-family-code">274</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_FADD</td><td class="is-family-code">275</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">ATOMIC_LOAD_FSUB</td><td class="is-family-code">276</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">MLOAD</td><td class="is-family-code">277</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">MSTORE</td><td class="is-family-code">278</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">MGATHER</td><td class="is-family-code">279</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">MSCATTER</td><td class="is-family-code">280</td><td>Val, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amt) Val, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amt) For double-word atomic operations: ValLo, ValHi, OUTCHAIN = ATOMIC_SWAP(INCHAIN, ptr, amtLo, amtHi) ValLo, ValHi, OUTCHAIN = ATOMIC_LOAD_[OpName](INCHAIN, ptr, amtLo, amtHi) These correspond to the atomicrmw instruction.</td></tr><tr><td class="is-family-code">LIFETIME_START</td><td class="is-family-code">281</td><td>This corresponds to the llvm.lifetime.* intrinsics. The first operand is the chain and the second operand is the alloca pointer.</td></tr><tr><td class="is-family-code">LIFETIME_END</td><td class="is-family-code">282</td><td>This corresponds to the llvm.lifetime.* intrinsics. The first operand is the chain and the second operand is the alloca pointer.</td></tr><tr><td class="is-family-code">GC_TRANSITION_START</td><td class="is-family-code">283</td><td>GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the beginning and end of GC transition  sequence, and carry arbitrary information that target might need for lowering.  The first operand is a chain, the rest are specified by the target and not touched by the DAG optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be nested.</td></tr><tr><td class="is-family-code">GC_TRANSITION_END</td><td class="is-family-code">284</td><td>GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the beginning and end of GC transition  sequence, and carry arbitrary information that target might need for lowering.  The first operand is a chain, the rest are specified by the target and not touched by the DAG optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be nested.</td></tr><tr><td class="is-family-code">GET_DYNAMIC_AREA_OFFSET</td><td class="is-family-code">285</td><td>GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of the most recent dynamic alloca. For most targets that would be 0, but for some others (e.g. PowerPC, PowerPC64) that would be compile-time known nonzero constant. The only operand here is the chain.</td></tr><tr><td class="is-family-code">VECREDUCE_STRICT_FADD</td><td class="is-family-code">286</td><td>Generic reduction nodes. These nodes represent horizontal vector reduction operations, producing a scalar result. The STRICT variants perform reductions in sequential order. The first operand is an initial scalar accumulator value, and the second operand is the vector to reduce.</td></tr><tr><td class="is-family-code">VECREDUCE_STRICT_FMUL</td><td class="is-family-code">287</td><td>Generic reduction nodes. These nodes represent horizontal vector reduction operations, producing a scalar result. The STRICT variants perform reductions in sequential order. The first operand is an initial scalar accumulator value, and the second operand is the vector to reduce.</td></tr><tr><td class="is-family-code">VECREDUCE_FADD</td><td class="is-family-code">288</td><td>These reductions are non-strict, and have a single vector operand.</td></tr><tr><td class="is-family-code">VECREDUCE_FMUL</td><td class="is-family-code">289</td><td>These reductions are non-strict, and have a single vector operand.</td></tr><tr><td class="is-family-code">VECREDUCE_FMAX</td><td class="is-family-code">290</td><td>FMIN/FMAX nodes can have flags, for NaN/NoNaN variants.</td></tr><tr><td class="is-family-code">VECREDUCE_FMIN</td><td class="is-family-code">291</td><td>FMIN/FMAX nodes can have flags, for NaN/NoNaN variants.</td></tr><tr><td class="is-family-code">VECREDUCE_ADD</td><td class="is-family-code">292</td><td>Integer reductions may have a result type larger than the vector element type. However, the reduction is performed using the vector element type and the value in the top bits is unspecified.</td></tr><tr><td class="is-family-code">VECREDUCE_MUL</td><td class="is-family-code">293</td><td>Integer reductions may have a result type larger than the vector element type. However, the reduction is performed using the vector element type and the value in the top bits is unspecified.</td></tr><tr><td class="is-family-code">VECREDUCE_AND</td><td class="is-family-code">294</td><td>Integer reductions may have a result type larger than the vector element type. However, the reduction is performed using the vector element type and the value in the top bits is unspecified.</td></tr><tr><td class="is-family-code">VECREDUCE_OR</td><td class="is-family-code">295</td><td>Integer reductions may have a result type larger than the vector element type. However, the reduction is performed using the vector element type and the value in the top bits is unspecified.</td></tr><tr><td class="is-family-code">VECREDUCE_XOR</td><td class="is-family-code">296</td><td>Integer reductions may have a result type larger than the vector element type. However, the reduction is performed using the vector element type and the value in the top bits is unspecified.</td></tr><tr><td class="is-family-code">VECREDUCE_SMAX</td><td class="is-family-code">297</td><td>Integer reductions may have a result type larger than the vector element type. However, the reduction is performed using the vector element type and the value in the top bits is unspecified.</td></tr><tr><td class="is-family-code">VECREDUCE_SMIN</td><td class="is-family-code">298</td><td>Integer reductions may have a result type larger than the vector element type. However, the reduction is performed using the vector element type and the value in the top bits is unspecified.</td></tr><tr><td class="is-family-code">VECREDUCE_UMAX</td><td class="is-family-code">299</td><td>Integer reductions may have a result type larger than the vector element type. However, the reduction is performed using the vector element type and the value in the top bits is unspecified.</td></tr><tr><td class="is-family-code">VECREDUCE_UMIN</td><td class="is-family-code">300</td><td>Integer reductions may have a result type larger than the vector element type. However, the reduction is performed using the vector element type and the value in the top bits is unspecified.</td></tr><tr><td class="is-family-code">BUILTIN_OP_END</td><td class="is-family-code">301</td><td>BUILTIN_OP_END - This must be the last enum value in this list. The target-specific pre-isel opcode values start here.</td></tr></table></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>