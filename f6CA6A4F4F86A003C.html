<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>function SolveQuadraticEquationWrap: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li><a href="namespaces.html#8D467D5FD525E849"><span>namespace APIntOps</span></a></li><li class="is-active"><a aria-current="page6CA6A4F4F86A003C"><span>function SolveQuadraticEquationWrap</span></a></li></ul></nav><main class="content"><h3 id="6CA6A4F4F86A003C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6CA6A4F4F86A003C">Â¶</a><code class="hdoc-function-code language-cpp"><a href="r6607998C23E31109.html">Optional</a>&lt;<a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&gt; SolveQuadraticEquationWrap(
    <a href="r50D306F9F4C3FD25.html">llvm::APInt</a> A,
    <a href="r50D306F9F4C3FD25.html">llvm::APInt</a> B,
    llvm::APInt C,
    unsigned int RangeWidth)</code></pre></h3><h4>Description</h4><p>Let q(n) = An^2 + Bn + C, and BW = bit width of the value range (e.g. 32 for i32). This function finds the smallest number n, such that (a) n &gt;= 0 and q(n) = 0, or (b) n &gt;= 1 and q(n-1) and q(n), when evaluated in the set of all integers, belong to two different intervals [Rk, Rk+R), where R = 2^BW, and k is an integer. The idea here is to find when q(n) &quot;overflows&quot; 2^BW, while at the same time &quot;allowing&quot; subtraction. In unsigned modulo arithmetic a subtraction (treated as addition of negated numbers) would always count as an overflow, but here we want to allow values to decrease and increase as long as they are within the same interval. Specifically, adding of two negative numbers should not cause an overflow (as long as the magnitude does not exceed the bit width). On the other hand, given a positive number, adding a negative number to it can give a negative result, which would cause the value to go from [-2^BW, 0) to [0, 2^BW). In that sense, zero is treated as a special case of an overflow. This function returns None if after finding k that minimizes the positive solution to q(n) = kR, both solutions are contained between two consecutive integers. There are cases where q(n) &gt; T, and q(n+1)  &lt; T (assuming evaluation in arithmetic modulo 2^BW, and treating the values as signed) by the virtue of *signed* overflow. This function will *not* find such an n, however it may find a value of n satisfying the inequalities due to an *unsigned* overflow (if the values are treated as unsigned). To find a solution for a signed overflow, treat it as a problem of finding an unsigned overflow with a range with of BW-1. The returned value may have a different bit width from the input coefficients.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/APInt.h#L2266">llvm/include/llvm/ADT/APInt.h:2266</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r50D306F9F4C3FD25.html">llvm::APInt</a><b> A</b></dt><dt class="is-family-code"><a href="r50D306F9F4C3FD25.html">llvm::APInt</a><b> B</b></dt><dt class="is-family-code"><a href="r50D306F9F4C3FD25.html">llvm::APInt</a><b> C</b></dt><dt class="is-family-code">unsigned int<b> RangeWidth</b></dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>