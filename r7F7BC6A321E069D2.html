<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class JumpThreadingPass: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="page7F7BC6A321E069D2"><span>class JumpThreadingPass</span></a></li></ul></nav><main class="content"><h1>class JumpThreadingPass</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class JumpThreadingPass : public PassInfoMixin { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>This pass performs &apos;jump threading&apos;, which looks at blocks that have multiple predecessors and multiple successors.  If one or more of the predecessors of the block can be proven to always jump to one of the successors, we forward the edge from the predecessor to the successor by duplicating the contents of this block. An example of when this can occur is code like this: if () { ... X = 4; } if (X  &lt; 3) { In this case, the unconditional branch at the end of the first if can be revectored to the false side of the second if.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L77">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:77</a></p><p>Inherits from: PassInfoMixin</p><h2>Method Overview</h2><ul><li class="is-family-code">public DenseMap&lt;llvm::Instruction *, llvm::Value *&gt;  <a href="#F646194EDEC629ED"><b>CloneInstructions</b></a>(BasicBlock::iterator BI, BasicBlock::iterator BE, llvm::BasicBlock * NewBB, llvm::BasicBlock * PredBB)</li><li class="is-family-code">public bool  <a href="#D83A1D0DFDD40DD4"><b>ComputeValueKnownInPredecessors</b></a>(llvm::Value * V, llvm::BasicBlock * BB, jumpthreading::PredValueInfo &amp; Result, jumpthreading::ConstantPreference Preference, llvm::Instruction * CxtI = nullptr)</li><li class="is-family-code">public bool  <a href="#A622215D0BA2219D"><b>ComputeValueKnownInPredecessorsImpl</b></a>(llvm::Value * V, llvm::BasicBlock * BB, jumpthreading::PredValueInfo &amp; Result, jumpthreading::ConstantPreference Preference, DenseSet&lt;std::pair&lt;Value *, BasicBlock *&gt;&gt; &amp; RecursionSet, llvm::Instruction * CxtI = nullptr)</li><li class="is-family-code">public bool  <a href="#D486F2973DF44A1A"><b>DuplicateCondBranchOnPHIIntoPred</b></a>(llvm::BasicBlock * BB, const SmallVectorImpl&lt;llvm::BasicBlock *&gt; &amp; PredBBs)</li><li class="is-family-code">public void  <a href="#580FF376CA17B08B"><b>FindLoopHeaders</b></a>(llvm::Function &amp; F)</li><li class="is-family-code">public  <a href="#C68C6F9A9D93E4CC"><b>JumpThreadingPass</b></a>(int T = -1)</li><li class="is-family-code">public bool  <a href="#31D71ACB7D40AE37"><b>MaybeMergeBasicBlockIntoOnlyPred</b></a>(llvm::BasicBlock * BB)</li><li class="is-family-code">public bool  <a href="#C63C1C8B4DF7A332"><b>ProcessBlock</b></a>(llvm::BasicBlock * BB)</li><li class="is-family-code">public bool  <a href="#8D4CCC60080759F3"><b>ProcessBranchOnPHI</b></a>(llvm::PHINode * PN)</li><li class="is-family-code">public bool  <a href="#8357A8A95AE08DD9"><b>ProcessBranchOnXOR</b></a>(llvm::BinaryOperator * BO)</li><li class="is-family-code">public bool  <a href="#BDD8057096A92ACB"><b>ProcessGuards</b></a>(llvm::BasicBlock * BB)</li><li class="is-family-code">public bool  <a href="#E5D1C413BAEC391D"><b>ProcessImpliedCondition</b></a>(llvm::BasicBlock * BB)</li><li class="is-family-code">public bool  <a href="#132D4E2A4BA1AE16"><b>ProcessThreadableEdges</b></a>(llvm::Value * Cond, llvm::BasicBlock * BB, jumpthreading::ConstantPreference Preference, llvm::Instruction * CxtI = nullptr)</li><li class="is-family-code">public bool  <a href="#CFB29C033A6DCFCA"><b>SimplifyPartiallyRedundantLoad</b></a>(llvm::LoadInst * LI)</li><li class="is-family-code">public void  <a href="#30A8F770D1B60E12"><b>ThreadEdge</b></a>(llvm::BasicBlock * BB, const SmallVectorImpl&lt;llvm::BasicBlock *&gt; &amp; PredBBs, llvm::BasicBlock * SuccBB)</li><li class="is-family-code">public bool  <a href="#F40B8429F2401D4A"><b>ThreadGuard</b></a>(llvm::BasicBlock * BB, llvm::IntrinsicInst * Guard, llvm::BranchInst * BI)</li><li class="is-family-code">public bool  <a href="#7ED6C68EB89CA212"><b>TryThreadEdge</b></a>(llvm::BasicBlock * BB, const SmallVectorImpl&lt;llvm::BasicBlock *&gt; &amp; PredBBs, llvm::BasicBlock * SuccBB)</li><li class="is-family-code">public bool  <a href="#EB3EBA02CE77E8ED"><b>TryToUnfoldSelect</b></a>(llvm::CmpInst * CondCmp, llvm::BasicBlock * BB)</li><li class="is-family-code">public bool  <a href="#CA383B78D062C97D"><b>TryToUnfoldSelect</b></a>(llvm::SwitchInst * SI, llvm::BasicBlock * BB)</li><li class="is-family-code">public bool  <a href="#B49564E01A4F86E3"><b>TryToUnfoldSelectInCurrBB</b></a>(llvm::BasicBlock * BB)</li><li class="is-family-code">public void  <a href="#27772DA4D9A1B057"><b>UnfoldSelectInstr</b></a>(llvm::BasicBlock * Pred, llvm::BasicBlock * BB, llvm::SelectInst * SI, llvm::PHINode * SIUse, unsigned int Idx)</li><li class="is-family-code">public void  <a href="#584432F76B3B9CE0"><b>UpdateSSA</b></a>(llvm::BasicBlock * BB, llvm::BasicBlock * NewBB, DenseMap&lt;llvm::Instruction *, llvm::Value *&gt; &amp; ValueMapping)</li><li class="is-family-code">public void  <a href="#94DBBF568794924B"><b>releaseMemory</b></a>()</li><li class="is-family-code">public llvm::PreservedAnalyses  <a href="#92DD0BF80E6C1F07"><b>run</b></a>(llvm::Function &amp; F, llvm::FunctionAnalysisManager &amp; AM)</li><li class="is-family-code">public bool  <a href="#79C5F8FBEBD3F2EC"><b>runImpl</b></a>(llvm::Function &amp; F, llvm::TargetLibraryInfo * TLI_, llvm::LazyValueInfo * LVI_, llvm::AliasAnalysis * AA_, llvm::DomTreeUpdater * DTU_, bool HasProfileData_, std::unique_ptr&lt;BlockFrequencyInfo&gt; BFI_, std::unique_ptr&lt;BranchProbabilityInfo&gt; BPI_)</li></ul><h2>Methods</h2><h3 id="F646194EDEC629ED"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F646194EDEC629ED">¶</a><code class="hdoc-function-code language-cpp"><a href="rC2880C7E8E458B54.html">DenseMap</a>&lt;llvm::Instruction*, llvm::Value*&gt;
CloneInstructions(<a href="r360F37E943D71FA0.html">BasicBlock::iterator</a> BI,
                  <a href="r360F37E943D71FA0.html">BasicBlock::iterator</a> BE,
                  <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* NewBB,
                  <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* PredBB)</code></pre></h3><h4>Description</h4><p>Clone instructions in range [BI, BE) to NewBB.  For PHI nodes, we only clone arguments that come from PredBB.  Return the map from the variables in the source basic block to the variables in the newly created basic block.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L115">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:115</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r360F37E943D71FA0.html">BasicBlock::iterator</a><b> BI</b></dt><dt class="is-family-code"><a href="r360F37E943D71FA0.html">BasicBlock::iterator</a><b> BE</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> NewBB</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> PredBB</b></dt></dl><h3 id="D83A1D0DFDD40DD4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D83A1D0DFDD40DD4">¶</a><code class="hdoc-function-code language-cpp">bool ComputeValueKnownInPredecessors(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
    <a href="r6CBD92E95A65634C.html">jumpthreading::PredValueInfo</a>&amp; Result,
    jumpthreading::ConstantPreference Preference,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* CxtI = nullptr)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L133">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:133</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">jumpthreading::PredValueInfo</a>&amp;<b> Result</b></dt><dt class="is-family-code">jumpthreading::ConstantPreference<b> Preference</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> CxtI</b> = nullptr</dt></dl><h3 id="A622215D0BA2219D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A622215D0BA2219D">¶</a><code class="hdoc-function-code language-cpp">bool ComputeValueKnownInPredecessorsImpl(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
    <a href="r6CBD92E95A65634C.html">jumpthreading::PredValueInfo</a>&amp; Result,
    jumpthreading::ConstantPreference Preference,
    <a href="r30EF9B14EFC7AC5C.html">DenseSet</a>&lt;std::pair&lt;Value*, BasicBlock*&gt;&gt;&amp;
        RecursionSet,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* CxtI = nullptr)</code></pre></h3><h4>Description</h4><p>ComputeValueKnownInPredecessors - Given a basic block BB and a value V, see if we can infer that the value is a known ConstantInt/BlockAddress or undef in any of our predecessors.  If so, return the known list of value and pred BB in the result vector. This returns true if there were any known values.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L127">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:127</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">jumpthreading::PredValueInfo</a>&amp;<b> Result</b></dt><dt class="is-family-code">jumpthreading::ConstantPreference<b> Preference</b></dt><dt class="is-family-code"><a href="r30EF9B14EFC7AC5C.html">DenseSet</a>&lt;std::pair&lt;Value*, BasicBlock*&gt;&gt;&amp;<b> RecursionSet</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> CxtI</b> = nullptr</dt></dl><h3 id="D486F2973DF44A1A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D486F2973DF44A1A">¶</a><code class="hdoc-function-code language-cpp">bool DuplicateCondBranchOnPHIIntoPred(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
    const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::BasicBlock*&gt;&amp;
        PredBBs)</code></pre></h3><h4>Description</h4><p>DuplicateCondBranchOnPHIIntoPred - PredBB contains an unconditional branch to BB which contains an i1 PHI node and a conditional branch on that PHI. If we can duplicate the contents of BB up into PredBB do so now, this improves the odds that the branch will be on an analyzable instruction like a compare.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L124">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:124</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code">const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::BasicBlock*&gt;&amp;<b> PredBBs</b></dt></dl><h3 id="580FF376CA17B08B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#580FF376CA17B08B">¶</a><code class="hdoc-function-code language-cpp">void FindLoopHeaders(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F)</code></pre></h3><h4>Description</h4><p>FindLoopHeaders - We do not want jump threading to turn proper loop structures into irreducible loops.  Doing this breaks up the loop nesting hierarchy and pessimizes later transformations.  To prevent this from happening, we first have to find the loop headers.  Here we approximate this by finding targets of backedges in the CFG. Note that there definitely are cases when we want to allow threading of edges across a loop header.  For example, threading a jump from outside the loop (the preheader) to an exit block of the loop is definitely profitable. It is also almost always profitable to thread backedges from within the loop to exit blocks, and is often profitable to thread backedges to other blocks within the loop (forming a nested loop).  This simple analysis is not rich enough to track all of these properties and keep it up-to-date as the CFG mutates, so we don&apos;t allow any of these transformations.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L110">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:110</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt></dl><h3 id="C68C6F9A9D93E4CC"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C68C6F9A9D93E4CC">¶</a><code class="hdoc-function-code language-cpp">JumpThreadingPass(int T = -1)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L95">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:95</a></p><h4>Parameters</h4><dl><dt class="is-family-code">int<b> T</b> = -1</dt></dl><h3 id="31D71ACB7D40AE37"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#31D71ACB7D40AE37">¶</a><code class="hdoc-function-code language-cpp">bool MaybeMergeBasicBlockIntoOnlyPred(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><h4>Description</h4><p>Merge basic block BB into its sole predecessor if possible.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L112">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:112</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="C63C1C8B4DF7A332"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C63C1C8B4DF7A332">¶</a><code class="hdoc-function-code language-cpp">bool ProcessBlock(<a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><h4>Description</h4><p>ProcessBlock - If there are any predecessors whose control can be threaded through to a successor, transform them now.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L111">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:111</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="8D4CCC60080759F3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8D4CCC60080759F3">¶</a><code class="hdoc-function-code language-cpp">bool ProcessBranchOnPHI(<a href="r33A490E798BA8C33.html">llvm::PHINode</a>* PN)</code></pre></h3><h4>Description</h4><p>ProcessBranchOnPHI - We have an otherwise unthreadable conditional branch on a PHI node in the current block.  See if there are any simplifications we can do based on inputs to the phi node.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L146">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:146</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r33A490E798BA8C33.html">llvm::PHINode</a>*<b> PN</b></dt></dl><h3 id="8357A8A95AE08DD9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8357A8A95AE08DD9">¶</a><code class="hdoc-function-code language-cpp">bool ProcessBranchOnXOR(<a href="rD8E863ED1964241F.html">llvm::BinaryOperator</a>* BO)</code></pre></h3><h4>Description</h4><p>ProcessBranchOnXOR - We have an otherwise unthreadable conditional branch on a xor instruction in the current block.  See if there are any simplifications we can do based on inputs to the xor.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L147">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:147</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD8E863ED1964241F.html">llvm::BinaryOperator</a>*<b> BO</b></dt></dl><h3 id="BDD8057096A92ACB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BDD8057096A92ACB">¶</a><code class="hdoc-function-code language-cpp">bool ProcessGuards(<a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><h4>Description</h4><p>Try to propagate a guard from the current BB into one of its predecessors in case if another branch of execution implies that the condition of this guard is always true. Currently we only process the simplest case that looks like: Start: %cond = ... br i1 %cond, label %T1, label %F1 T1: br label %Merge F1: br label %Merge Merge: %condGuard = ... call void(i1, ...) @llvm.experimental.guard( i1 %condGuard )[ &quot;deopt&quot;() ] And cond either implies condGuard or !condGuard. In this case all the instructions before the guard can be duplicated in both branches, and the guard is then threaded to one of them.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L158">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:158</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="E5D1C413BAEC391D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E5D1C413BAEC391D">¶</a><code class="hdoc-function-code language-cpp">bool ProcessImpliedCondition(<a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L148">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:148</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="132D4E2A4BA1AE16"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#132D4E2A4BA1AE16">¶</a><code class="hdoc-function-code language-cpp">bool ProcessThreadableEdges(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Cond,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
    jumpthreading::ConstantPreference Preference,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* CxtI = nullptr)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L142">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:142</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Cond</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code">jumpthreading::ConstantPreference<b> Preference</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> CxtI</b> = nullptr</dt></dl><h3 id="CFB29C033A6DCFCA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CFB29C033A6DCFCA">¶</a><code class="hdoc-function-code language-cpp">bool SimplifyPartiallyRedundantLoad(
    <a href="r537857E9FE6D2795.html">llvm::LoadInst</a>* LI)</code></pre></h3><h4>Description</h4><p>SimplifyPartiallyRedundantLoad - If LoadI is an obviously partially redundant load instruction, eliminate it by replacing it with a PHI node. This is an important optimization that encourages jump threading, and needs to be run interlaced with other jump threading tasks.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L150">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:150</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r537857E9FE6D2795.html">llvm::LoadInst</a>*<b> LI</b></dt></dl><h3 id="30A8F770D1B60E12"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#30A8F770D1B60E12">¶</a><code class="hdoc-function-code language-cpp">void ThreadEdge(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
    const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;<a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*&gt;&amp;
        PredBBs,
    llvm::BasicBlock* SuccBB)</code></pre></h3><h4>Description</h4><p>ThreadEdge - We have decided that it is safe and profitable to factor the blocks in PredBBs to one predecessor, then thread an edge from it to SuccBB across BB.  Transform the IR to reflect this change.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L122">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:122</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code">const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::BasicBlock*&gt;&amp;<b> PredBBs</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> SuccBB</b></dt></dl><h3 id="F40B8429F2401D4A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F40B8429F2401D4A">¶</a><code class="hdoc-function-code language-cpp">bool ThreadGuard(<a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
                 <a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>* Guard,
                 <a href="r5DC16D915F4AEC0F.html">llvm::BranchInst</a>* BI)</code></pre></h3><h4>Description</h4><p>Try to propagate the guard from BB which is the lower block of a diamond to one of its branches, in case if diamond&apos;s condition implies guard&apos;s condition.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L159">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:159</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code"><a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>*<b> Guard</b></dt><dt class="is-family-code"><a href="r5DC16D915F4AEC0F.html">llvm::BranchInst</a>*<b> BI</b></dt></dl><h3 id="7ED6C68EB89CA212"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7ED6C68EB89CA212">¶</a><code class="hdoc-function-code language-cpp">bool TryThreadEdge(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
    const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;<a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*&gt;&amp;
        PredBBs,
    llvm::BasicBlock* SuccBB)</code></pre></h3><h4>Description</h4><p>TryThreadEdge - Thread an edge if it&apos;s safe and profitable to do so.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L119">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:119</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code">const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::BasicBlock*&gt;&amp;<b> PredBBs</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> SuccBB</b></dt></dl><h3 id="EB3EBA02CE77E8ED"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EB3EBA02CE77E8ED">¶</a><code class="hdoc-function-code language-cpp">bool TryToUnfoldSelect(<a href="rFEBEB259D24BFC1A.html">llvm::CmpInst</a>* CondCmp,
                       <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><h4>Description</h4><p>TryToUnfoldSelect - Look for blocks of the form bb1: %a = select br bb2 bb2: %p = phi [%a, %bb1] ... %c = icmp %p br i1 %c And expand the select into a branch structure if one of its arms allows %c to be folded. This later enables threading from bb1 over bb2.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L154">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:154</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rFEBEB259D24BFC1A.html">llvm::CmpInst</a>*<b> CondCmp</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="CA383B78D062C97D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CA383B78D062C97D">¶</a><code class="hdoc-function-code language-cpp">bool TryToUnfoldSelect(<a href="r1A6F1C03A3F0DA37.html">llvm::SwitchInst</a>* SI,
                       <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L155">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:155</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r1A6F1C03A3F0DA37.html">llvm::SwitchInst</a>*<b> SI</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="B49564E01A4F86E3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B49564E01A4F86E3">¶</a><code class="hdoc-function-code language-cpp">bool TryToUnfoldSelectInCurrBB(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><h4>Description</h4><p>TryToUnfoldSelectInCurrBB - Look for PHI/Select or PHI/CMP/Select in the same BB in the form bb: %p = phi [false, %bb1], [true, %bb2], [false, %bb3], [true, %bb4], ... %s = select %p, trueval, falseval or bb: %p = phi [0, %bb1], [1, %bb2], [0, %bb3], [1, %bb4], ... %c = cmp %p, 0 %s = select %c, trueval, falseval And expand the select into a branch structure. This later enables jump-threading over bb in this pass. Using the similar approach of SimplifyCFG::FoldCondBranchOnPHI(), unfold select if the associated PHI has at least one constant.  If the unfolded select is not jump-threaded, it will be folded again in the later optimizations.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L156">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:156</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="27772DA4D9A1B057"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#27772DA4D9A1B057">¶</a><code class="hdoc-function-code language-cpp">void UnfoldSelectInstr(<a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* Pred,
                       <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
                       <a href="r49B7541B367FF828.html">llvm::SelectInst</a>* SI,
                       <a href="r33A490E798BA8C33.html">llvm::PHINode</a>* SIUse,
                       unsigned int Idx)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L151">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:151</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> Pred</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code"><a href="r49B7541B367FF828.html">llvm::SelectInst</a>*<b> SI</b></dt><dt class="is-family-code"><a href="r33A490E798BA8C33.html">llvm::PHINode</a>*<b> SIUse</b></dt><dt class="is-family-code">unsigned int<b> Idx</b></dt></dl><h3 id="584432F76B3B9CE0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#584432F76B3B9CE0">¶</a><code class="hdoc-function-code language-cpp">void UpdateSSA(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* NewBB,
    <a href="rC2880C7E8E458B54.html">DenseMap</a>&lt;llvm::Instruction*, llvm::Value*&gt;&amp;
        ValueMapping)</code></pre></h3><h4>Description</h4><p>Update the SSA form.  NewBB contains instructions that are copied from BB. ValueMapping maps old values in BB to new ones in NewBB.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L113">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:113</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> NewBB</b></dt><dt class="is-family-code"><a href="rC2880C7E8E458B54.html">DenseMap</a>&lt;llvm::Instruction*, llvm::Value*&gt;&amp;<b> ValueMapping</b></dt></dl><h3 id="94DBBF568794924B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#94DBBF568794924B">¶</a><code class="hdoc-function-code language-cpp">void releaseMemory()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L105">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:105</a></p><h3 id="92DD0BF80E6C1F07"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#92DD0BF80E6C1F07">¶</a><code class="hdoc-function-code language-cpp"><a href="r9EDCE8A1E6A8CDD6.html">llvm::PreservedAnalyses</a> run(
    <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F,
    <a href="rB9A0ED74935D969B.html">llvm::FunctionAnalysisManager</a>&amp; AM)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L103">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:103</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt><dt class="is-family-code"><a href="rB9A0ED74935D969B.html">llvm::FunctionAnalysisManager</a>&amp;<b> AM</b></dt></dl><h3 id="79C5F8FBEBD3F2EC"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#79C5F8FBEBD3F2EC">¶</a><code class="hdoc-function-code language-cpp">bool runImpl(
    <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F,
    <a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>* TLI_,
    <a href="r21DF1B9A08DAA464.html">llvm::LazyValueInfo</a>* LVI_,
    <a href="rCA1ED98E6FDF5F7E.html">llvm::AliasAnalysis</a>* AA_,
    <a href="r11162AC129BF1CE7.html">llvm::DomTreeUpdater</a>* DTU_,
    bool HasProfileData_,
    <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>&lt;BlockFrequencyInfo&gt; BFI_,
    <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>&lt;BranchProbabilityInfo&gt; BPI_)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Scalar/JumpThreading.h#L98">llvm/include/llvm/Transforms/Scalar/JumpThreading.h:98</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt><dt class="is-family-code"><a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>*<b> TLI_</b></dt><dt class="is-family-code"><a href="r21DF1B9A08DAA464.html">llvm::LazyValueInfo</a>*<b> LVI_</b></dt><dt class="is-family-code"><a href="rCA1ED98E6FDF5F7E.html">llvm::AliasAnalysis</a>*<b> AA_</b></dt><dt class="is-family-code"><a href="r11162AC129BF1CE7.html">llvm::DomTreeUpdater</a>*<b> DTU_</b></dt><dt class="is-family-code">bool<b> HasProfileData_</b></dt><dt class="is-family-code"><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>&lt;BlockFrequencyInfo&gt;<b> BFI_</b></dt><dt class="is-family-code"><a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>&lt;BranchProbabilityInfo&gt;<b> BPI_</b></dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>