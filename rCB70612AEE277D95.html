<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class SparseMultiSet: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="pageCB70612AEE277D95"><span>class SparseMultiSet</span></a></li></ul></nav><main class="content"><h1>class SparseMultiSet</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">template &lt;typename ValueT,
          typename KeyFunctorT = identity&lt;unsigned int&gt;,
          typename SparseT = uint8_t&gt;
class SparseMultiSet { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>Fast multiset implementation for objects that can be identified by small unsigned keys. SparseMultiSet allocates memory proportional to the size of the key universe, so it is not recommended for building composite data structures. It is useful for algorithms that require a single set with fast operations. Compared to DenseSet and DenseMap, SparseMultiSet provides constant-time fast clear() as fast as a vector.  The find(), insert(), and erase() operations are all constant time, and typically faster than a hash table. The iteration order doesn&apos;t depend on numerical key values, it only depends on the order of insert() and erase() operations.  Iteration order is the insertion order. Iteration is only provided over elements of equivalent keys, but iterators are bidirectional. Compared to BitVector, SparseMultiSet &lt;unsigned &gt; uses 8x-40x more memory, but offers constant-time clear() and size() operations as well as fast iteration independent on the size of the universe. SparseMultiSet contains a dense vector holding all the objects and a sparse array holding indexes into the dense vector.  Most of the memory is used by the sparse array which is the size of the key universe. The SparseT template parameter provides a space/speed tradeoff for sets holding many elements. When SparseT is uint32_t, find() only touches up to 3 cache lines, but the sparse array uses 4 x Universe bytes. When SparseT is uint8_t (the default), find() touches up to 3+[N/256] cache lines, but the sparse array is 4x smaller.  N is the number of elements in the set. For sets that may grow to thousands of elements, SparseT should be set to uint16_t or uint32_t. Multiset behavior is provided by providing doubly linked lists for values that are inlined in the dense vector. SparseMultiSet is a good choice when one desires a growable number of entries per key, as it will retain the SparseSet algorithmic properties despite being growable. Thus, it is often a better choice than a SparseSet of growable containers or a vector of vectors. SparseMultiSet also keeps iterators valid after erasure (provided the iterators don&apos;t point to the element erased), allowing for more intuitive and fast removal.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L85">llvm/include/llvm/ADT/SparseMultiSet.h:85</a></p><h2>Templates</h2><dl><dt class="is-family-code"><b> ValueT</b></dt><dd>The type of objects in the set.</dd><dt class="is-family-code"><b> KeyFunctorT</b> = identity&lt;unsigned int&gt;</dt><dd>A functor that computes an unsigned index from KeyT.</dd><dt class="is-family-code"><b> SparseT</b> = uint8_t</dt><dd>An unsigned integer type. See above.</dd></dl><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#87A1A428687B5F22"><b>SparseMultiSet&lt;ValueT, KeyFunctorT, SparseT&gt;</b></a>(const SparseMultiSet&lt;ValueT, KeyFunctorT, SparseT&gt; &amp;)</li><li class="is-family-code">public  <a href="#E73560C5835B3EDA"><b>SparseMultiSet&lt;ValueT, KeyFunctorT, SparseT&gt;</b></a>()</li><li class="is-family-code">public void  <a href="#B1185460659B8739"><b>clear</b></a>()</li><li class="is-family-code">public bool  <a href="#7292A80014DF87D2"><b>contains</b></a>(const llvm::SparseMultiSet::KeyT &amp; Key) const</li><li class="is-family-code">public llvm::SparseMultiSet::size_type  <a href="#122246DFD388D586"><b>count</b></a>(const llvm::SparseMultiSet::KeyT &amp; Key) const</li><li class="is-family-code">public bool  <a href="#C72BF6C6CFA9F68A"><b>empty</b></a>() const</li><li class="is-family-code">public llvm::SparseMultiSet::iterator  <a href="#EC8A65082779080A"><b>end</b></a>()</li><li class="is-family-code">public llvm::SparseMultiSet::const_iterator  <a href="#7598E088256C54C7"><b>end</b></a>() const</li><li class="is-family-code">public llvm::SparseMultiSet::RangePair  <a href="#F15A774663006270"><b>equal_range</b></a>(const llvm::SparseMultiSet::KeyT &amp; K)</li><li class="is-family-code">public llvm::SparseMultiSet::iterator  <a href="#684D25270D58E682"><b>erase</b></a>(llvm::SparseMultiSet::iterator I)</li><li class="is-family-code">public void  <a href="#6286CF915F7A0F1B"><b>eraseAll</b></a>(const llvm::SparseMultiSet::KeyT &amp; K)</li><li class="is-family-code">public llvm::SparseMultiSet::const_iterator  <a href="#8EC9D13B99DC28B0"><b>find</b></a>(const llvm::SparseMultiSet::KeyT &amp; Key) const</li><li class="is-family-code">public llvm::SparseMultiSet::iterator  <a href="#71D5205774162E0D"><b>find</b></a>(const llvm::SparseMultiSet::KeyT &amp; Key)</li><li class="is-family-code">public llvm::SparseMultiSet::iterator  <a href="#398570B5A8745CA1"><b>findIndex</b></a>(unsigned int Idx)</li><li class="is-family-code">public llvm::SparseMultiSet::iterator  <a href="#7AE087601B79FAC1"><b>getHead</b></a>(const llvm::SparseMultiSet::KeyT &amp; Key)</li><li class="is-family-code">public llvm::SparseMultiSet::iterator  <a href="#08DEA5C3EBD8D126"><b>getTail</b></a>(const llvm::SparseMultiSet::KeyT &amp; Key)</li><li class="is-family-code">public llvm::SparseMultiSet::iterator  <a href="#5B0DFC37E8198EE9"><b>insert</b></a>(const ValueT &amp; Val)</li><li class="is-family-code">public void  <a href="#3B220E3903467D14"><b>setUniverse</b></a>(unsigned int U)</li><li class="is-family-code">public llvm::SparseMultiSet::size_type  <a href="#92640EE93699B497"><b>size</b></a>() const</li><li class="is-family-code">public  <a href="#ECB7BF21B5E3DFC9"><b>~SparseMultiSet&lt;ValueT, KeyFunctorT, SparseT&gt;</b></a>()</li></ul><h2>Methods</h2><h3 id="87A1A428687B5F22"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#87A1A428687B5F22">¶</a><code class="hdoc-function-code language-cpp"><a href="rCB70612AEE277D95.html">SparseMultiSet</a>&lt;ValueT, KeyFunctorT, SparseT&gt;(
    const SparseMultiSet&lt;ValueT,
                         KeyFunctorT,
                         SparseT&gt;&amp;)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L193">llvm/include/llvm/ADT/SparseMultiSet.h:193</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rCB70612AEE277D95.html">SparseMultiSet</a>&lt;ValueT,
                     KeyFunctorT,
                     SparseT&gt;&amp;<b> </b></dt></dl><h3 id="E73560C5835B3EDA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E73560C5835B3EDA">¶</a><code class="hdoc-function-code language-cpp">SparseMultiSet&lt;ValueT, KeyFunctorT, SparseT&gt;()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L192">llvm/include/llvm/ADT/SparseMultiSet.h:192</a></p><h3 id="B1185460659B8739"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B1185460659B8739">¶</a><code class="hdoc-function-code language-cpp">void clear()</code></pre></h3><h4>Description</h4><p>Clears the set.  This is a very fast constant time operation.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L342">llvm/include/llvm/ADT/SparseMultiSet.h:342</a></p><h3 id="7292A80014DF87D2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7292A80014DF87D2">¶</a><code class="hdoc-function-code language-cpp">bool contains(
    const llvm::SparseMultiSet::KeyT&amp; Key) const</code></pre></h3><h4>Description</h4><p>Returns true if this set contains an element identified by Key.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L395">llvm/include/llvm/ADT/SparseMultiSet.h:395</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const llvm::SparseMultiSet::KeyT&amp;<b> Key</b></dt></dl><h3 id="122246DFD388D586"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#122246DFD388D586">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::size_type count(
    const llvm::SparseMultiSet::KeyT&amp; Key) const</code></pre></h3><h4>Description</h4><p>Returns the number of elements identified by Key. This will be linear in the number of elements of that key.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L386">llvm/include/llvm/ADT/SparseMultiSet.h:386</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const llvm::SparseMultiSet::KeyT&amp;<b> Key</b></dt></dl><h3 id="C72BF6C6CFA9F68A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C72BF6C6CFA9F68A">¶</a><code class="hdoc-function-code language-cpp">bool empty() const</code></pre></h3><h4>Description</h4><p>Returns true if the set is empty. This is not the same as BitVector::empty().</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L328">llvm/include/llvm/ADT/SparseMultiSet.h:328</a></p><h3 id="EC8A65082779080A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EC8A65082779080A">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::iterator end()</code></pre></h3><h4>Description</h4><p>Returns an iterator past this container. Note that such an iterator cannot be decremented, but will compare equal to other end iterators.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L319">llvm/include/llvm/ADT/SparseMultiSet.h:319</a></p><h3 id="7598E088256C54C7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7598E088256C54C7">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::const_iterator end() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L320">llvm/include/llvm/ADT/SparseMultiSet.h:320</a></p><h3 id="F15A774663006270"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F15A774663006270">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::RangePair equal_range(
    const llvm::SparseMultiSet::KeyT&amp; K)</code></pre></h3><h4>Description</h4><p>The bounds of the range of items sharing Key K. First member is the head of the list, and the second member is a decrementable end iterator for that key.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L411">llvm/include/llvm/ADT/SparseMultiSet.h:411</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const llvm::SparseMultiSet::KeyT&amp;<b> K</b></dt></dl><h3 id="684D25270D58E682"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#684D25270D58E682">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::iterator erase(
    llvm::SparseMultiSet::iterator I)</code></pre></h3><h4>Description</h4><p>Erases an existing element identified by a valid iterator. This invalidates iterators pointing at the same entry, but erase() returns an iterator pointing to the next element in the subset&apos;s list. This makes it possible to erase selected elements while iterating over the subset: tie(I, E) = Set.equal_range(Key); while (I != E) if (test(*I)) I = Set.erase(I); else ++I; Note that if the last element in the subset list is erased, this will return an end iterator which can be decremented to get the new tail (if it exists): tie(B, I) = Set.equal_range(Key); for (bool isBegin = B == I; !isBegin; /* empty */) { isBegin = (--I) == B; if (test(I)) break; I = erase(I); }</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L466">llvm/include/llvm/ADT/SparseMultiSet.h:466</a></p><h4>Parameters</h4><dl><dt class="is-family-code">llvm::SparseMultiSet::iterator<b> I</b></dt></dl><h3 id="6286CF915F7A0F1B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6286CF915F7A0F1B">¶</a><code class="hdoc-function-code language-cpp">void eraseAll(const llvm::SparseMultiSet::KeyT&amp; K)</code></pre></h3><h4>Description</h4><p>Erase all elements with the given key. This invalidates all iterators of that key.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L482">llvm/include/llvm/ADT/SparseMultiSet.h:482</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const llvm::SparseMultiSet::KeyT&amp;<b> K</b></dt></dl><h3 id="8EC9D13B99DC28B0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8EC9D13B99DC28B0">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::const_iterator find(
    const llvm::SparseMultiSet::KeyT&amp; Key) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L379">llvm/include/llvm/ADT/SparseMultiSet.h:379</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const llvm::SparseMultiSet::KeyT&amp;<b> Key</b></dt></dl><h3 id="71D5205774162E0D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#71D5205774162E0D">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::iterator find(
    const llvm::SparseMultiSet::KeyT&amp; Key)</code></pre></h3><h4>Description</h4><p>Find an element by its key.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L375">llvm/include/llvm/ADT/SparseMultiSet.h:375</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const llvm::SparseMultiSet::KeyT&amp;<b> Key</b></dt><dd>A valid key to find.</dd></dl><h4>Returns</h4><p>An iterator to the element identified by key, or end().</p><h3 id="398570B5A8745CA1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#398570B5A8745CA1">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::iterator findIndex(
    unsigned int Idx)</code></pre></h3><h4>Description</h4><p>Find an element by its index.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L354">llvm/include/llvm/ADT/SparseMultiSet.h:354</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Idx</b></dt><dd>A valid index to find.</dd></dl><h4>Returns</h4><p>An iterator to the element identified by key, or end().</p><h3 id="7AE087601B79FAC1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7AE087601B79FAC1">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::iterator getHead(
    const llvm::SparseMultiSet::KeyT&amp; Key)</code></pre></h3><h4>Description</h4><p>Return the head and tail of the subset&apos;s list, otherwise returns end().</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L400">llvm/include/llvm/ADT/SparseMultiSet.h:400</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const llvm::SparseMultiSet::KeyT&amp;<b> Key</b></dt></dl><h3 id="08DEA5C3EBD8D126"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#08DEA5C3EBD8D126">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::iterator getTail(
    const llvm::SparseMultiSet::KeyT&amp; Key)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L401">llvm/include/llvm/ADT/SparseMultiSet.h:401</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const llvm::SparseMultiSet::KeyT&amp;<b> Key</b></dt></dl><h3 id="5B0DFC37E8198EE9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5B0DFC37E8198EE9">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::iterator insert(
    const ValueT&amp; Val)</code></pre></h3><h4>Description</h4><p>Insert a new element at the tail of the subset list. Returns an iterator to the newly added entry.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L419">llvm/include/llvm/ADT/SparseMultiSet.h:419</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const ValueT&amp;<b> Val</b></dt></dl><h3 id="3B220E3903467D14"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3B220E3903467D14">¶</a><code class="hdoc-function-code language-cpp">void setUniverse(unsigned int U)</code></pre></h3><h4>Description</h4><p>Set the universe size which determines the largest key the set can hold. The universe must be sized before any elements can be added.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L202">llvm/include/llvm/ADT/SparseMultiSet.h:202</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> U</b></dt><dd>Universe size. All object keys must be less than U.</dd></dl><h3 id="92640EE93699B497"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#92640EE93699B497">¶</a><code class="hdoc-function-code language-cpp">llvm::SparseMultiSet::size_type size() const</code></pre></h3><h4>Description</h4><p>Returns the number of elements in the set. This is not the same as BitVector::size() which returns the size of the universe.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L335">llvm/include/llvm/ADT/SparseMultiSet.h:335</a></p><h3 id="ECB7BF21B5E3DFC9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#ECB7BF21B5E3DFC9">¶</a><code class="hdoc-function-code language-cpp">~SparseMultiSet&lt;ValueT, KeyFunctorT, SparseT&gt;()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/ADT/SparseMultiSet.h#L195">llvm/include/llvm/ADT/SparseMultiSet.h:195</a></p></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>