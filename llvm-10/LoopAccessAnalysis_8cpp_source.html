<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Analysis/LoopAccessAnalysis.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a25db018342d3ae6c7e6779086c18378.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">LoopAccessAnalysis.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="LoopAccessAnalysis_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="comment">//===- LoopAccessAnalysis.cpp - Loop Access Analysis Implementation --------==//</span></div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;<span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="comment">// The implementation for the loop memory dependence that was originally</span></div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="comment">// developed for the loop vectorizer.</span></div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;<span class="comment">//</span></div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;<span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="LoopAccessAnalysis_8h.html">llvm/Analysis/LoopAccessAnalysis.h</a>&quot;</span></div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="APInt_8h.html">llvm/ADT/APInt.h</a>&quot;</span></div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DenseMap_8h.html">llvm/ADT/DenseMap.h</a>&quot;</span></div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DepthFirstIterator_8h.html">llvm/ADT/DepthFirstIterator.h</a>&quot;</span></div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="EquivalenceClasses_8h.html">llvm/ADT/EquivalenceClasses.h</a>&quot;</span></div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="PointerIntPair_8h.html">llvm/ADT/PointerIntPair.h</a>&quot;</span></div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="STLExtras_8h.html">llvm/ADT/STLExtras.h</a>&quot;</span></div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="SetVector_8h.html">llvm/ADT/SetVector.h</a>&quot;</span></div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="SmallPtrSet_8h.html">llvm/ADT/SmallPtrSet.h</a>&quot;</span></div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="SmallSet_8h.html">llvm/ADT/SmallSet.h</a>&quot;</span></div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="SmallVector_8h.html">llvm/ADT/SmallVector.h</a>&quot;</span></div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="iterator__range_8h.html">llvm/ADT/iterator_range.h</a>&quot;</span></div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="AliasAnalysis_8h.html">llvm/Analysis/AliasAnalysis.h</a>&quot;</span></div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="AliasSetTracker_8h.html">llvm/Analysis/AliasSetTracker.h</a>&quot;</span></div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="LoopAnalysisManager_8h.html">llvm/Analysis/LoopAnalysisManager.h</a>&quot;</span></div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="LoopInfo_8h.html">llvm/Analysis/LoopInfo.h</a>&quot;</span></div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="MemoryLocation_8h.html">llvm/Analysis/MemoryLocation.h</a>&quot;</span></div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="OptimizationRemarkEmitter_8h.html">llvm/Analysis/OptimizationRemarkEmitter.h</a>&quot;</span></div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ScalarEvolution_8h.html">llvm/Analysis/ScalarEvolution.h</a>&quot;</span></div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ScalarEvolutionExpander_8h.html">llvm/Analysis/ScalarEvolutionExpander.h</a>&quot;</span></div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ScalarEvolutionExpressions_8h.html">llvm/Analysis/ScalarEvolutionExpressions.h</a>&quot;</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="TargetLibraryInfo_8h.html">llvm/Analysis/TargetLibraryInfo.h</a>&quot;</span></div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ValueTracking_8h.html">llvm/Analysis/ValueTracking.h</a>&quot;</span></div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="VectorUtils_8h.html">llvm/Analysis/VectorUtils.h</a>&quot;</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="BasicBlock_8h.html">llvm/IR/BasicBlock.h</a>&quot;</span></div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Constants_8h.html">llvm/IR/Constants.h</a>&quot;</span></div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DataLayout_8h.html">llvm/IR/DataLayout.h</a>&quot;</span></div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DebugLoc_8h.html">llvm/IR/DebugLoc.h</a>&quot;</span></div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DerivedTypes_8h.html">llvm/IR/DerivedTypes.h</a>&quot;</span></div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="DiagnosticInfo_8h.html">llvm/IR/DiagnosticInfo.h</a>&quot;</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Dominators_8h.html">llvm/IR/Dominators.h</a>&quot;</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Function_8h.html">llvm/IR/Function.h</a>&quot;</span></div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="IRBuilder_8h.html">llvm/IR/IRBuilder.h</a>&quot;</span></div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="InstrTypes_8h.html">llvm/IR/InstrTypes.h</a>&quot;</span></div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="IR_2Instruction_8h.html">llvm/IR/Instruction.h</a>&quot;</span></div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Instructions_8h.html">llvm/IR/Instructions.h</a>&quot;</span></div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Operator_8h.html">llvm/IR/Operator.h</a>&quot;</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="PassManager_8h.html">llvm/IR/PassManager.h</a>&quot;</span></div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Type_8h.html">llvm/IR/Type.h</a>&quot;</span></div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Value_8h.html">llvm/IR/Value.h</a>&quot;</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="ValueHandle_8h.html">llvm/IR/ValueHandle.h</a>&quot;</span></div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="InitializePasses_8h.html">llvm/InitializePasses.h</a>&quot;</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Pass_8h.html">llvm/Pass.h</a>&quot;</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Casting_8h.html">llvm/Support/Casting.h</a>&quot;</span></div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="CommandLine_8h.html">llvm/Support/CommandLine.h</a>&quot;</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Debug_8h.html">llvm/Support/Debug.h</a>&quot;</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="Support_2ErrorHandling_8h.html">llvm/Support/ErrorHandling.h</a>&quot;</span></div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="raw__ostream_8h.html">llvm/Support/raw_ostream.h</a>&quot;</span></div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="preprocessor">#include &lt;algorithm&gt;</span></div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="preprocessor">#include &lt;cstdint&gt;</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;<span class="preprocessor">#include &lt;cstdlib&gt;</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="preprocessor">#include &lt;iterator&gt;</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="preprocessor">#include &lt;utility&gt;</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;<span class="keyword">using namespace </span><a class="code" href="namespacellvm.html">llvm</a>;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;</div><div class="line"><a name="l00072"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">   72</a></span>&#160;<span class="preprocessor">#define DEBUG_TYPE &quot;loop-accesses&quot;</span></div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1cl_1_1opt.html">cl::opt&lt;unsigned, true&gt;</a></div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<a class="code" href="LoopAccessAnalysis_8cpp.html#ad6964f44e23ed8dd24b0dd628c0a9933">VectorizationFactor</a>(<span class="stringliteral">&quot;force-vector-width&quot;</span>, <a class="code" href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">cl::Hidden</a>,</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;                    <a class="code" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(<span class="stringliteral">&quot;Sets the SIMD width. Zero is autoselect.&quot;</span>),</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;                    <a class="code" href="namespacellvm_1_1cl.html#aed47e4757f3240146f8ad40c2cdbf2d1">cl::location</a>(<a class="code" href="structllvm_1_1VectorizerParams.html#a22854382d27cb43d471731779195e9a8">VectorizerParams::VectorizationFactor</a>));</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;<span class="keywordtype">unsigned</span> <a class="code" href="structllvm_1_1VectorizerParams.html#a22854382d27cb43d471731779195e9a8">VectorizerParams::VectorizationFactor</a>;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1cl_1_1opt.html">cl::opt&lt;unsigned, true&gt;</a></div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;<a class="code" href="LoopAccessAnalysis_8cpp.html#a095d2abc4fa2ce11453eaeece2200cbe">VectorizationInterleave</a>(<span class="stringliteral">&quot;force-vector-interleave&quot;</span>, <a class="code" href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">cl::Hidden</a>,</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;                        <a class="code" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(<span class="stringliteral">&quot;Sets the vectorization interleave count. &quot;</span></div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                                 <span class="stringliteral">&quot;Zero is autoselect.&quot;</span>),</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;                        <a class="code" href="namespacellvm_1_1cl.html#aed47e4757f3240146f8ad40c2cdbf2d1">cl::location</a>(</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                            <a class="code" href="structllvm_1_1VectorizerParams.html#a6a8f6b7564d1df823a8d8e8dcecf6802">VectorizerParams::VectorizationInterleave</a>));</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;<span class="keywordtype">unsigned</span> <a class="code" href="structllvm_1_1VectorizerParams.html#a6a8f6b7564d1df823a8d8e8dcecf6802">VectorizerParams::VectorizationInterleave</a>;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1cl_1_1opt.html">cl::opt&lt;unsigned, true&gt;</a> <a class="code" href="LoopAccessAnalysis_8cpp.html#a7adfee307ee23c8055467ddb7369dc16">RuntimeMemoryCheckThreshold</a>(</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;    <span class="stringliteral">&quot;runtime-memory-check-threshold&quot;</span>, <a class="code" href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">cl::Hidden</a>,</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    <a class="code" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(<span class="stringliteral">&quot;When performing memory disambiguation checks at runtime do not &quot;</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;             <span class="stringliteral">&quot;generate more than this number of comparisons (default = 8).&quot;</span>),</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    <a class="code" href="namespacellvm_1_1cl.html#aed47e4757f3240146f8ad40c2cdbf2d1">cl::location</a>(<a class="code" href="structllvm_1_1VectorizerParams.html#a43a5cafabe566a957f39d39f2edb411b">VectorizerParams::RuntimeMemoryCheckThreshold</a>), <a class="code" href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">cl::init</a>(8));</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;<span class="keywordtype">unsigned</span> <a class="code" href="structllvm_1_1VectorizerParams.html#a43a5cafabe566a957f39d39f2edb411b">VectorizerParams::RuntimeMemoryCheckThreshold</a>;</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">/// The maximum iterations used to merge memory checks</span></div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1cl_1_1opt.html">cl::opt&lt;unsigned&gt;</a> <a class="code" href="LoopAccessAnalysis_8cpp.html#ab62603cc7bc570ef4688112c0a7fa0c0">MemoryCheckMergeThreshold</a>(</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    <span class="stringliteral">&quot;memory-check-merge-threshold&quot;</span>, <a class="code" href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">cl::Hidden</a>,</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;    <a class="code" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(<span class="stringliteral">&quot;Maximum number of comparisons done when trying to merge &quot;</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;             <span class="stringliteral">&quot;runtime memory checks. (default = 100)&quot;</span>),</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    <a class="code" href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">cl::init</a>(100));</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="comment">/// Maximum SIMD width.</span></div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;<span class="comment"></span><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code" href="structllvm_1_1VectorizerParams.html#a122bb2d8a6d57352811c1a7aa72771be">VectorizerParams::MaxVectorWidth</a> = 64;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;<span class="comment">/// We collect dependences up to this threshold.</span></div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1cl_1_1opt.html">cl::opt&lt;unsigned&gt;</a></div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    <a class="code" href="LoopAccessAnalysis_8cpp.html#ab815434ba412e9565ad40caa0413cc26">MaxDependences</a>(<span class="stringliteral">&quot;max-dependences&quot;</span>, <a class="code" href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">cl::Hidden</a>,</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;                   <a class="code" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(<span class="stringliteral">&quot;Maximum number of dependences collected by &quot;</span></div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;                            <span class="stringliteral">&quot;loop-access analysis (default = 100)&quot;</span>),</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                   <a class="code" href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">cl::init</a>(100));</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;<span class="comment">/// This enables versioning on the strides of symbolically striding memory</span></div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;<span class="comment">/// accesses in code like the following.</span></div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;<span class="comment">///   for (i = 0; i &lt; N; ++i)</span></div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;<span class="comment">///     A[i * Stride1] += B[i * Stride2] ...</span></div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">/// Will be roughly translated to</span></div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;<span class="comment">///    if (Stride1 == 1 &amp;&amp; Stride2 == 1) {</span></div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">///      for (i = 0; i &lt; N; i+=4)</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">///       A[i:i+3] += ...</span></div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="comment">///    } else</span></div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;<span class="comment">///      ...</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1cl_1_1opt.html">cl::opt&lt;bool&gt;</a> <a class="code" href="LoopAccessAnalysis_8cpp.html#a7b58e159e9c7683ba37043d4288d643a">EnableMemAccessVersioning</a>(</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;    <span class="stringliteral">&quot;enable-mem-access-versioning&quot;</span>, <a class="code" href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">cl::init</a>(<span class="keyword">true</span>), <a class="code" href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">cl::Hidden</a>,</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    <a class="code" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(<span class="stringliteral">&quot;Enable symbolic stride memory access versioning&quot;</span>));</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">/// Enable store-to-load forwarding conflict detection. This option can</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">/// be disabled for correctness testing.</span></div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1cl_1_1opt.html">cl::opt&lt;bool&gt;</a> <a class="code" href="LoopAccessAnalysis_8cpp.html#aca99374d317f84dc3b73915b7f2e955c">EnableForwardingConflictDetection</a>(</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;    <span class="stringliteral">&quot;store-to-load-forwarding-conflict-detection&quot;</span>, <a class="code" href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">cl::Hidden</a>,</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    <a class="code" href="structllvm_1_1cl_1_1desc.html">cl::desc</a>(<span class="stringliteral">&quot;Enable conflict detection in loop-access analysis&quot;</span>),</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;    <a class="code" href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">cl::init</a>(<span class="keyword">true</span>));</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno"><a class="line" href="structllvm_1_1VectorizerParams.html#a5ccaa3f1275b2e841f5c23852d61b872">  134</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="structllvm_1_1VectorizerParams.html#a5ccaa3f1275b2e841f5c23852d61b872">VectorizerParams::isInterleaveForced</a>() {</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  <a class="code" href="LoopAccessAnalysis_8cpp.html#a095d2abc4fa2ce11453eaeece2200cbe">return ::VectorizationInterleave</a>.getNumOccurrences() &gt; 0;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;}</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;</div><div class="line"><a name="l00138"></a><span class="lineno"><a class="line" href="namespacellvm.html#a62fbc6c535baa6d7d82bbf63f6c2621f">  138</a></span>&#160;<a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="namespacellvm.html#a62fbc6c535baa6d7d82bbf63f6c2621f">llvm::stripIntegerCast</a>(<a class="code" href="classllvm_1_1Value.html">Value</a> *V) {</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> *CI = dyn_cast&lt;CastInst&gt;(V))</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;    <span class="keywordflow">if</span> (CI-&gt;getOperand(0)-&gt;getType()-&gt;isIntegerTy())</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;      <span class="keywordflow">return</span> CI-&gt;getOperand(0);</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="keywordflow">return</span> V;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;}</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno"><a class="line" href="namespacellvm.html#aa92a7ada2797ca16a2c0c540faafd7e1">  145</a></span>&#160;<span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *<a class="code" href="namespacellvm.html#aa92a7ada2797ca16a2c0c540faafd7e1">llvm::replaceSymbolicStrideSCEV</a>(<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE,</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;                                            <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;PtrToStride,</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;                                            <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="code" href="classllvm_1_1Value.html">Value</a> *OrigPtr) {</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *OrigSCEV = PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#ae0994d8207b94ad22ecebc1a6bc580f1">getSCEV</a>(Ptr);</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;  <span class="comment">// If there is an entry in the map return the SCEV of the pointer with the</span></div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;  <span class="comment">// symbolic stride replaced by one.</span></div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;  <a class="code" href="classllvm_1_1DenseMapIterator.html">ValueToValueMap::const_iterator</a> <a class="code" href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a> =</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;      PtrToStride.<a class="code" href="classllvm_1_1DenseMapBase.html#a0c047f127ed4380a6f383d70bec4eb94">find</a>(OrigPtr ? OrigPtr : Ptr);</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  <span class="keywordflow">if</span> (SI != PtrToStride.<a class="code" href="classllvm_1_1DenseMapBase.html#a65520b9c67759099e313d0f4e7b5ff9e">end</a>()) {</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *StrideVal = SI-&gt;second;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;    <span class="comment">// Strip casts.</span></div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    StrideVal = <a class="code" href="namespacellvm.html#a62fbc6c535baa6d7d82bbf63f6c2621f">stripIntegerCast</a>(StrideVal);</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;    <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE = PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a872704344573663359494dca7554c198">getSE</a>();</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> *U = cast&lt;SCEVUnknown&gt;(SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49">getSCEV</a>(StrideVal));</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> *CT =</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;        <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classllvm_1_1SCEVConstant.html">SCEVConstant</a> *<span class="keyword">&gt;</span>(SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#ac93dd46031b1e2f9fdb0cee7a99681df">getOne</a>(StrideVal-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()));</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;    PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a0b369e991301543c2120405809119d36">addPredicate</a>(*SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a29cffc9779968caccc3dd405819e55f5">getEqualPredicate</a>(U, CT));</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="keyword">auto</span> *Expr = PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#ae0994d8207b94ad22ecebc1a6bc580f1">getSCEV</a>(Ptr);</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Replacing SCEV: &quot;</span> &lt;&lt; *OrigSCEV</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;                      &lt;&lt; <span class="stringliteral">&quot; by: &quot;</span> &lt;&lt; *Expr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;    <span class="keywordflow">return</span> Expr;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;  }</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;  <span class="comment">// Otherwise, just return the SCEV of the original pointer.</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="keywordflow">return</span> OrigSCEV;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;}</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="comment">/// Calculate Start and End points of memory access.</span></div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;<span class="comment">/// Let&#39;s assume A is the first access and B is a memory access on N-th loop</span></div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">/// iteration. Then B is calculated as:</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="comment">///   B = A + Step*N .</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;<span class="comment">/// Step value may be positive or negative.</span></div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">/// N is a calculated back-edge taken count:</span></div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="comment">///     N = (TripCount &gt; 0) ? RoundDown(TripCount -1 , VF) : 0</span></div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;<span class="comment">/// Start and End points are calculated in the following way:</span></div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;<span class="comment">/// Start = UMIN(A, B) ; End = UMAX(A, B) + SizeOfElt,</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;<span class="comment">/// where SizeOfElt is the size of single memory access in bytes.</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;<span class="comment">/// There is no conflict when the intervals are disjoint:</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;<span class="comment">/// NoConflict = (P2.Start &gt;= P1.End) || (P1.Start &gt;= P2.End)</span></div><div class="line"><a name="l00190"></a><span class="lineno"><a class="line" href="classllvm_1_1RuntimePointerChecking.html#af4009b07ade042922fe2f94d32b47844">  190</a></span>&#160;<span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="classllvm_1_1RuntimePointerChecking.html#af4009b07ade042922fe2f94d32b47844">RuntimePointerChecking::insert</a>(<a class="code" href="classllvm_1_1Loop.html">Loop</a> *Lp, <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr, <span class="keywordtype">bool</span> WritePtr,</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;                                    <span class="keywordtype">unsigned</span> DepSetId, <span class="keywordtype">unsigned</span> ASId,</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                                    <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;Strides,</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                                    <a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE) {</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  <span class="comment">// Get the stride replaced scev.</span></div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Sc = <a class="code" href="namespacellvm.html#aa92a7ada2797ca16a2c0c540faafd7e1">replaceSymbolicStrideSCEV</a>(PSE, Strides, Ptr);</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE = PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a872704344573663359494dca7554c198">getSE</a>();</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *ScStart;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *ScEnd;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;  <span class="keywordflow">if</span> (SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a5a19768af81df7e5fe571bc08dcd48b3">isLoopInvariant</a>(Sc, Lp))</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;    ScStart = ScEnd = Sc;</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  <span class="keywordflow">else</span> {</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a> *AR = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a>&gt;(Sc);</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(AR &amp;&amp; <span class="stringliteral">&quot;Invalid addrec expression&quot;</span>);</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Ex = PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#ada1db826f3d2266fe2c4d06218d8d342">getBackedgeTakenCount</a>();</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;    ScStart = AR-&gt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html#a1d3a0e869e478018c481a577ed9d25ee">getStart</a>();</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;    ScEnd = AR-&gt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html#a33583576f220997d1c415df033559a57">evaluateAtIteration</a>(Ex, *SE);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Step = AR-&gt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html#a7eec28400b00678b1fb2b5f55ef7ac1b">getStepRecurrence</a>(*SE);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;    <span class="comment">// For expressions with negative step, the upper bound is ScStart and the</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;    <span class="comment">// lower bound is ScEnd.</span></div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> *CStep = dyn_cast&lt;SCEVConstant&gt;(Step)) {</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      <span class="keywordflow">if</span> (CStep-&gt;getValue()-&gt;isNegative())</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <a class="code" href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(ScStart, ScEnd);</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      <span class="comment">// Fallback case: the step is not constant, but we can still</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      <span class="comment">// get the upper and lower bounds of the interval by using min/max</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      <span class="comment">// expressions.</span></div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;      ScStart = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#ac4acab35ff407510f8b4cf9a17c8c022">getUMinExpr</a>(ScStart, ScEnd);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;      ScEnd = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a238566881f41b81cd8ff51eb1b3f4a8b">getUMaxExpr</a>(AR-&gt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html#a1d3a0e869e478018c481a577ed9d25ee">getStart</a>(), ScEnd);</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    }</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    <span class="comment">// Add the size of the pointed element to ScEnd.</span></div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    <span class="keywordtype">unsigned</span> EltSize =</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;      Ptr-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#ae61f17d62c8a79bc5cffa63a2f152311">getPointerElementType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a9f382207d841377156d4c7868b66b9a5">getScalarSizeInBits</a>() / 8;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *EltSizeSCEV = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a2eb94d079d8416118f4aaed865ab05d7">getConstant</a>(ScEnd-&gt;<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>(), EltSize);</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;    ScEnd = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a83f34da3409085dd69e2da4a7f85e0f7">getAddExpr</a>(ScEnd, EltSizeSCEV);</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  }</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;  Pointers.emplace_back(Ptr, ScStart, ScEnd, WritePtr, DepSetId, ASId, Sc);</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;}</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;<a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;RuntimePointerChecking::PointerCheck, 4&gt;</a></div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;RuntimePointerChecking::generateChecks()<span class="keyword"> const </span>{</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;PointerCheck, 4&gt;</a> Checks;</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = 0; <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> &lt; CheckingGroups.size(); ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> J = <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> + 1; J &lt; CheckingGroups.size(); ++J) {</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;      <span class="keyword">const</span> <a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html">RuntimePointerChecking::CheckingPtrGroup</a> &amp;CGI = CheckingGroups[<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>];</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;      <span class="keyword">const</span> <a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html">RuntimePointerChecking::CheckingPtrGroup</a> &amp;CGJ = CheckingGroups[J];</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;      <span class="keywordflow">if</span> (needsChecking(CGI, CGJ))</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        Checks.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#af42bfbc067df27c19ee2fc859df58799">push_back</a>(std::make_pair(&amp;CGI, &amp;CGJ));</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;  }</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  <span class="keywordflow">return</span> Checks;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;}</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno"><a class="line" href="classllvm_1_1RuntimePointerChecking.html#a799b2020cc896db04085849aed060f20">  250</a></span>&#160;<span class="keywordtype">void</span> RuntimePointerChecking::generateChecks(</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    <a class="code" href="classllvm_1_1EquivalenceClasses.html">MemoryDepChecker::DepCandidates</a> &amp;DepCands, <span class="keywordtype">bool</span> UseDependencies) {</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(Checks.empty() &amp;&amp; <span class="stringliteral">&quot;Checks is not empty&quot;</span>);</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  groupChecks(DepCands, UseDependencies);</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  Checks = generateChecks();</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;}</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno"><a class="line" href="classllvm_1_1RuntimePointerChecking.html#ac5b4263fea4de0564c41099b43bd72a7">  257</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1RuntimePointerChecking.html#ac5b4263fea4de0564c41099b43bd72a7">RuntimePointerChecking::needsChecking</a>(<span class="keyword">const</span> <a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html">CheckingPtrGroup</a> &amp;M,</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;                                           <span class="keyword">const</span> <a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html">CheckingPtrGroup</a> &amp;<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>)<span class="keyword"> const </span>{</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = 0, EI = M.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a90bc32387fd6351a131d06f1e0ed4a37">Members</a>.<a class="code" href="classllvm_1_1SmallVectorBase.html#ac8624043115fb3a5076c964820001b61">size</a>(); EI != <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>; ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> J = 0, EJ = N.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a90bc32387fd6351a131d06f1e0ed4a37">Members</a>.<a class="code" href="classllvm_1_1SmallVectorBase.html#ac8624043115fb3a5076c964820001b61">size</a>(); EJ != J; ++J)</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;      <span class="keywordflow">if</span> (needsChecking(M.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a90bc32387fd6351a131d06f1e0ed4a37">Members</a>[<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>], N.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a90bc32387fd6351a131d06f1e0ed4a37">Members</a>[J]))</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;}</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;<span class="comment">/// Compare \p I and \p J and return the minimum.</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">/// Return nullptr in case we couldn&#39;t find an answer.</span></div><div class="line"><a name="l00268"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#ac2ba67bd461a728fbe186ef76f089a3a">  268</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *<a class="code" href="LoopAccessAnalysis_8cpp.html#ac2ba67bd461a728fbe186ef76f089a3a">getMinFromExprs</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *J,</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;                                   <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE) {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Diff = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a8bcb86d8d126d95b0dc05f09e8f3df96">getMinusSCEV</a>(J, I);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEVConstant.html">SCEVConstant</a> *<a class="code" href="NVVMIntrRange_8cpp.html#a2ae53ee71b2ccbb52b883c0b4f59f8c2">C</a> = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEVConstant.html">SCEVConstant</a>&gt;(Diff);</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="keywordflow">if</span> (!C)</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <span class="keywordflow">if</span> (C-&gt;<a class="code" href="classllvm_1_1SCEVConstant.html#ab319aacb4209aeca2c72d50a0d585b47">getValue</a>()-&gt;<a class="code" href="classllvm_1_1ConstantInt.html#a2a8c8be274f3bd351e083ab3828c14c7">isNegative</a>())</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;    <span class="keywordflow">return</span> J;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>;</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;}</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div><div class="line"><a name="l00280"></a><span class="lineno"><a class="line" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a79314926b75a22c414c8ce073e332dc0">  280</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a79314926b75a22c414c8ce073e332dc0">RuntimePointerChecking::CheckingPtrGroup::addPointer</a>(<span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>) {</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Start = RtCheck.Pointers[<a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>].Start;</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *End = RtCheck.Pointers[<a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>].End;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;  <span class="comment">// Compare the starts and ends with the known minimum and maximum</span></div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;  <span class="comment">// of this set. We need to know how we compare against the min/max</span></div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;  <span class="comment">// of the set in order to be able to emit memchecks.</span></div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Min0 = <a class="code" href="LoopAccessAnalysis_8cpp.html#ac2ba67bd461a728fbe186ef76f089a3a">getMinFromExprs</a>(Start, Low, RtCheck.SE);</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  <span class="keywordflow">if</span> (!Min0)</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Min1 = <a class="code" href="LoopAccessAnalysis_8cpp.html#ac2ba67bd461a728fbe186ef76f089a3a">getMinFromExprs</a>(End, <a class="code" href="NVVMIntrRange_8cpp.html#a7df34dbf636f2fbbb00f2b86eccdb1eb">High</a>, RtCheck.SE);</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;  <span class="keywordflow">if</span> (!Min1)</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  <span class="comment">// Update the low bound  expression if we&#39;ve found a new min value.</span></div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;  <span class="keywordflow">if</span> (Min0 == Start)</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;    Low = Start;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;  <span class="comment">// Update the high bound expression if we&#39;ve found a new max value.</span></div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;  <span class="keywordflow">if</span> (Min1 != End)</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;    <a class="code" href="NVVMIntrRange_8cpp.html#a7df34dbf636f2fbbb00f2b86eccdb1eb">High</a> = End;</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;  Members.push_back(Index);</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;}</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="keywordtype">void</span> RuntimePointerChecking::groupChecks(</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;    <a class="code" href="classllvm_1_1EquivalenceClasses.html">MemoryDepChecker::DepCandidates</a> &amp;DepCands, <span class="keywordtype">bool</span> UseDependencies) {</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  <span class="comment">// We build the groups from dependency candidates equivalence classes</span></div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;  <span class="comment">// because:</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;  <span class="comment">//    - We know that pointers in the same equivalence class share</span></div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;  <span class="comment">//      the same underlying object and therefore there is a chance</span></div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;  <span class="comment">//      that we can compare pointers</span></div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;  <span class="comment">//    - We wouldn&#39;t be able to merge two pointers for which we need</span></div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;  <span class="comment">//      to emit a memcheck. The classes in DepCands are already</span></div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;  <span class="comment">//      conveniently built such that no two pointers in the same</span></div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;  <span class="comment">//      class need checking against each other.</span></div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;  <span class="comment">// We use the following (greedy) algorithm to construct the groups</span></div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;  <span class="comment">// For every pointer in the equivalence class:</span></div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;  <span class="comment">//   For each existing group:</span></div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  <span class="comment">//   - if the difference between this pointer and the min/max bounds</span></div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;  <span class="comment">//     of the group is a constant, then make the pointer part of the</span></div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;  <span class="comment">//     group and update the min/max bounds of that group as required.</span></div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  CheckingGroups.clear();</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;  <span class="comment">// If we need to check two pointers to the same underlying object</span></div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;  <span class="comment">// with a non-constant difference, we shouldn&#39;t perform any pointer</span></div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;  <span class="comment">// grouping with those pointers. This is because we can easily get</span></div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;  <span class="comment">// into cases where the resulting check would return false, even when</span></div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;  <span class="comment">// the accesses are safe.</span></div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;  <span class="comment">// The following example shows this:</span></div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;  <span class="comment">// for (i = 0; i &lt; 1000; ++i)</span></div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;  <span class="comment">//   a[5000 + i * m] = a[i] + a[i + 9000]</span></div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;  <span class="comment">// Here grouping gives a check of (5000, 5000 + 1000 * m) against</span></div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;  <span class="comment">// (0, 10000) which is always false. However, if m is 1, there is no</span></div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;  <span class="comment">// dependence. Not grouping the checks for a[i] and a[i + 9000] allows</span></div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;  <span class="comment">// us to perform an accurate check in this case.</span></div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;  <span class="comment">// The above case requires that we have an UnknownDependence between</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;  <span class="comment">// accesses to the same underlying object. This cannot happen unless</span></div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;  <span class="comment">// FoundNonConstantDistanceDependence is set, and therefore UseDependencies</span></div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;  <span class="comment">// is also false. In this case we will use the fallback path and create</span></div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;  <span class="comment">// separate checking groups for all pointers.</span></div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  <span class="comment">// If we don&#39;t have the dependency partitions, construct a new</span></div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  <span class="comment">// checking pointer group for each pointer. This is also required</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  <span class="comment">// for correctness, because in this case we can have checking between</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;  <span class="comment">// pointers to the same underlying object.</span></div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  <span class="keywordflow">if</span> (!UseDependencies) {</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = 0; <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> &lt; Pointers.size(); ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;      CheckingGroups.push_back(<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html">CheckingPtrGroup</a>(<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, *<span class="keyword">this</span>));</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  }</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  <span class="keywordtype">unsigned</span> TotalComparisons = 0;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Value *, unsigned&gt;</a> PositionMap;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a> = 0; <a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a> &lt; Pointers.size(); ++<a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>)</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;    PositionMap[Pointers[<a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>].PointerValue] = <a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;  <span class="comment">// We need to keep track of what pointers we&#39;ve already seen so we</span></div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;  <span class="comment">// don&#39;t process them twice.</span></div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  <a class="code" href="classllvm_1_1SmallSet.html">SmallSet&lt;unsigned, 2&gt;</a> Seen;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  <span class="comment">// Go through all equivalence classes, get the &quot;pointer check groups&quot;</span></div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  <span class="comment">// and add them to the overall solution. We use the order in which accesses</span></div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;  <span class="comment">// appear in &#39;Pointers&#39; to enforce determinism.</span></div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = 0; <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> &lt; Pointers.size(); ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="comment">// We&#39;ve seen this pointer before, and therefore already processed</span></div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;    <span class="comment">// its equivalence class.</span></div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    <span class="keywordflow">if</span> (Seen.<a class="code" href="classllvm_1_1SmallSet.html#a2a98f19750ba941ce791b75ca6d77e48">count</a>(<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>))</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    <a class="code" href="classllvm_1_1PointerIntPair.html">MemoryDepChecker::MemAccessInfo</a> Access(Pointers[<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>].PointerValue,</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                                           Pointers[<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>].IsWritePtr);</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;CheckingPtrGroup, 2&gt;</a> <a class="code" href="X86InstrFMA3Info_8cpp.html#ab138684de9096eb96683328900f78e48">Groups</a>;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;    <span class="keyword">auto</span> LeaderI = DepCands.<a class="code" href="classllvm_1_1EquivalenceClasses.html#a1445a41f4405069e553c6a91ab7d6df0">findValue</a>(DepCands.<a class="code" href="classllvm_1_1EquivalenceClasses.html#a72c29f11de2d94ba0589624b00fac90a">getLeaderValue</a>(Access));</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;    <span class="comment">// Because DepCands is constructed by visiting accesses in the order in</span></div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;    <span class="comment">// which they appear in alias sets (which is deterministic) and the</span></div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;    <span class="comment">// iteration order within an equivalence class member is only dependent on</span></div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;    <span class="comment">// the order in which unions and insertions are performed on the</span></div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;    <span class="comment">// equivalence class, the iteration order is deterministic.</span></div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <a class="code" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a> = DepCands.<a class="code" href="classllvm_1_1EquivalenceClasses.html#afa7f2c45050e420ca2c11e339d869c20">member_begin</a>(LeaderI), ME = DepCands.<a class="code" href="classllvm_1_1EquivalenceClasses.html#a82ecd46540fecf164bcea31530a1bd02">member_end</a>();</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;         <a class="code" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a> != ME; ++<a class="code" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>) {</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;      <span class="keywordtype">unsigned</span> Pointer = PositionMap[<a class="code" href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a>-&gt;getPointer()];</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;      <span class="keywordtype">bool</span> Merged = <span class="keyword">false</span>;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;      <span class="comment">// Mark this pointer as seen.</span></div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;      Seen.<a class="code" href="classllvm_1_1SmallSet.html#a892daa20eb21173ba89e9fe9702e7f6c">insert</a>(Pointer);</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;      <span class="comment">// Go through all the existing sets and see if we can find one</span></div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;      <span class="comment">// which can include this pointer.</span></div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;      <span class="keywordflow">for</span> (<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html">CheckingPtrGroup</a> &amp;Group : Groups) {</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        <span class="comment">// Don&#39;t perform more than a certain amount of comparisons.</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;        <span class="comment">// This should limit the cost of grouping the pointers to something</span></div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="comment">// reasonable.  If we do end up hitting this threshold, the algorithm</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        <span class="comment">// will create separate groups for all remaining pointers.</span></div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        <span class="keywordflow">if</span> (TotalComparisons &gt; <a class="code" href="LoopAccessAnalysis_8cpp.html#ab62603cc7bc570ef4688112c0a7fa0c0">MemoryCheckMergeThreshold</a>)</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;        TotalComparisons++;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;        <span class="keywordflow">if</span> (Group.addPointer(Pointer)) {</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;          Merged = <span class="keyword">true</span>;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;      }</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;      <span class="keywordflow">if</span> (!Merged)</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        <span class="comment">// We couldn&#39;t add this pointer to any existing set or the threshold</span></div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="comment">// for the number of comparisons has been reached. Create a new group</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <span class="comment">// to hold the current pointer.</span></div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        Groups.push_back(<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html">CheckingPtrGroup</a>(Pointer, *<span class="keyword">this</span>));</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;    }</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="comment">// We&#39;ve computed the grouped checks for this partition.</span></div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;    <span class="comment">// Save the results and continue with the next one.</span></div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;    <a class="code" href="namespacellvm.html#abb650e853db0ddbb60411b885c499737">llvm::copy</a>(Groups, std::back_inserter(CheckingGroups));</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;  }</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;}</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div><div class="line"><a name="l00427"></a><span class="lineno"><a class="line" href="classllvm_1_1RuntimePointerChecking.html#a8ebeb3910d03eaa4e30ef67edc21df0b">  427</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1RuntimePointerChecking.html#a8ebeb3910d03eaa4e30ef67edc21df0b">RuntimePointerChecking::arePointersInSamePartition</a>(</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;int&gt;</a> &amp;PtrToPartition, <span class="keywordtype">unsigned</span> PtrIdx1,</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    <span class="keywordtype">unsigned</span> PtrIdx2) {</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;  <span class="keywordflow">return</span> (PtrToPartition[PtrIdx1] != -1 &amp;&amp;</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;          PtrToPartition[PtrIdx1] == PtrToPartition[PtrIdx2]);</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;}</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;</div><div class="line"><a name="l00434"></a><span class="lineno"><a class="line" href="classllvm_1_1RuntimePointerChecking.html#aea9847642d2da97fd896d4e79187f990">  434</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1RuntimePointerChecking.html#ac5b4263fea4de0564c41099b43bd72a7">RuntimePointerChecking::needsChecking</a>(<span class="keywordtype">unsigned</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, <span class="keywordtype">unsigned</span> J)<span class="keyword"> const </span>{</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;  <span class="keyword">const</span> <a class="code" href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html">PointerInfo</a> &amp;PointerI = Pointers[<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>];</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;  <span class="keyword">const</span> <a class="code" href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html">PointerInfo</a> &amp;PointerJ = Pointers[J];</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;  <span class="comment">// No need to check if two readonly pointers intersect.</span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  <span class="keywordflow">if</span> (!PointerI.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html#a6ddd46705dc2cd974b46450d7d37759e">IsWritePtr</a> &amp;&amp; !PointerJ.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html#a6ddd46705dc2cd974b46450d7d37759e">IsWritePtr</a>)</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;  <span class="comment">// Only need to check pointers between two different dependency sets.</span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;  <span class="keywordflow">if</span> (PointerI.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html#a80a449988c5d5b47f20c1b3bbd2e2a31">DependencySetId</a> == PointerJ.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html#a80a449988c5d5b47f20c1b3bbd2e2a31">DependencySetId</a>)</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;  <span class="comment">// Only need to check pointers in the same alias set.</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;  <span class="keywordflow">if</span> (PointerI.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html#aa4ba7560118a4dcd0907b66f9a58384d">AliasSetId</a> != PointerJ.<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html#aa4ba7560118a4dcd0907b66f9a58384d">AliasSetId</a>)</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;}</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div><div class="line"><a name="l00453"></a><span class="lineno"><a class="line" href="classllvm_1_1RuntimePointerChecking.html#a2607c6b8fad0ecefaaa5db14a4be340e">  453</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classllvm_1_1RuntimePointerChecking.html#a2607c6b8fad0ecefaaa5db14a4be340e">RuntimePointerChecking::printChecks</a>(</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, <span class="keyword">const</span> <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;PointerCheck&gt;</a> &amp;Checks,</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    <span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm.html#a1eb5609345b906d024fbf9e4bc1adc06afe578efb7ca235af77fb0eef7edcf639">Depth</a>)<span class="keyword"> const </span>{</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;  <span class="keywordtype">unsigned</span> <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a> = 0;</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a> : Checks) {</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;First = <a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a>.first-&gt;Members, &amp;Second = <a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a>.second-&gt;Members;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Check &quot;</span> &lt;&lt; N++ &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth + 2) &lt;&lt; <span class="stringliteral">&quot;Comparing group (&quot;</span> &lt;&lt; <a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a>.first &lt;&lt; <span class="stringliteral">&quot;):\n&quot;</span>;</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> K = 0; K &lt; First.size(); ++K)</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;      OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth + 2) &lt;&lt; *Pointers[First[K]].PointerValue &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth + 2) &lt;&lt; <span class="stringliteral">&quot;Against group (&quot;</span> &lt;&lt; <a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a>.second &lt;&lt; <span class="stringliteral">&quot;):\n&quot;</span>;</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> K = 0; K &lt; Second.size(); ++K)</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;      OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth + 2) &lt;&lt; *Pointers[Second[K]].PointerValue &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  }</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;}</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno"><a class="line" href="classllvm_1_1RuntimePointerChecking.html#a616cdd740bc8d7ccbed42ce872ca86c4">  472</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classllvm_1_1RuntimePointerChecking.html#a616cdd740bc8d7ccbed42ce872ca86c4">RuntimePointerChecking::print</a>(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, <span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm.html#a1eb5609345b906d024fbf9e4bc1adc06afe578efb7ca235af77fb0eef7edcf639">Depth</a>)<span class="keyword"> const </span>{</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;  OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Run-time memory checks:\n&quot;</span>;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  printChecks(OS, Checks, Depth);</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Grouped accesses:\n&quot;</span>;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> = 0; <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> &lt; CheckingGroups.size(); ++<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;CG = CheckingGroups[<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>];</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth + 2) &lt;&lt; <span class="stringliteral">&quot;Group &quot;</span> &lt;&lt; &amp;CG &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth + 4) &lt;&lt; <span class="stringliteral">&quot;(Low: &quot;</span> &lt;&lt; *CG.Low &lt;&lt; <span class="stringliteral">&quot; High: &quot;</span> &lt;&lt; *CG.High</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;                         &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> J = 0; J &lt; CG.Members.size(); ++J) {</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;      OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth + 6) &lt;&lt; <span class="stringliteral">&quot;Member: &quot;</span> &lt;&lt; *Pointers[CG.Members[J]].Expr</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;                           &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;    }</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;  }</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;}</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;<span class="keyword">namespace </span>{</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;<span class="comment">/// Analyses memory accesses in a loop.</span></div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;<span class="comment">/// Checks whether run time pointer checks are needed and builds sets for data</span></div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;<span class="comment">/// dependence checking.</span></div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;<span class="comment"></span><span class="keyword">class </span>AccessAnalysis {</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;<span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;<span class="comment">  /// Read or write access location.</span></div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;<span class="comment"></span>  <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1PointerIntPair.html">PointerIntPair&lt;Value *, 1, bool&gt;</a> MemAccessInfo;</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;  <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;MemAccessInfo, 8&gt;</a> MemAccessInfoList;</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;  AccessAnalysis(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;Dl, <a class="code" href="classllvm_1_1Loop.html">Loop</a> *TheLoop, <a class="code" href="classllvm_1_1AAResults.html">AliasAnalysis</a> *AA,</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                 <a class="code" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI, <a class="code" href="classllvm_1_1EquivalenceClasses.html">MemoryDepChecker::DepCandidates</a> &amp;DA,</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                 <a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE)</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;      : DL(Dl), TheLoop(TheLoop), AST(*AA), LI(LI), DepCands(DA),</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        IsRTCheckAnalysisNeeded(<span class="keyword">false</span>), PSE(PSE) {}</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;<span class="comment">  /// Register a load  and whether it is only read from.</span></div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> addLoad(<a class="code" href="classllvm_1_1MemoryLocation.html">MemoryLocation</a> &amp;Loc, <span class="keywordtype">bool</span> IsReadOnly) {</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr = <span class="keyword">const_cast&lt;</span><a class="code" href="classllvm_1_1Value.html">Value</a>*<span class="keyword">&gt;</span>(Loc.<a class="code" href="classllvm_1_1MemoryLocation.html#a9550ce4a179e46db37f653ce28feca7a">Ptr</a>);</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;    AST.add(Ptr, <a class="code" href="classllvm_1_1LocationSize.html#a3de0002f6ad965b6bc1ad4591dbebeb5">LocationSize::unknown</a>(), Loc.<a class="code" href="classllvm_1_1MemoryLocation.html#a926099ca5ca5db6ba2de398c2487b725">AATags</a>);</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;    Accesses.insert(MemAccessInfo(Ptr, <span class="keyword">false</span>));</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;    <span class="keywordflow">if</span> (IsReadOnly)</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;      ReadOnlyPtr.insert(Ptr);</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;  }</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;<span class="comment">  /// Register a store.</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> addStore(<a class="code" href="classllvm_1_1MemoryLocation.html">MemoryLocation</a> &amp;Loc) {</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr = <span class="keyword">const_cast&lt;</span><a class="code" href="classllvm_1_1Value.html">Value</a>*<span class="keyword">&gt;</span>(Loc.<a class="code" href="classllvm_1_1MemoryLocation.html#a9550ce4a179e46db37f653ce28feca7a">Ptr</a>);</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;    AST.add(Ptr, <a class="code" href="classllvm_1_1LocationSize.html#a3de0002f6ad965b6bc1ad4591dbebeb5">LocationSize::unknown</a>(), Loc.<a class="code" href="classllvm_1_1MemoryLocation.html#a926099ca5ca5db6ba2de398c2487b725">AATags</a>);</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;    Accesses.insert(MemAccessInfo(Ptr, <span class="keyword">true</span>));</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;  }</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;<span class="comment">  /// Check if we can emit a run-time no-alias check for \p Access.</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;<span class="comment">  /// Returns true if we can emit a run-time no alias check for \p Access.</span></div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;<span class="comment">  /// If we can check this access, this also adds it to a dependence set and</span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;<span class="comment">  /// adds a run-time to check for it to \p RtCheck. If \p Assume is true,</span></div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;<span class="comment">  /// we will attempt to use additional run-time checks in order to get</span></div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;<span class="comment">  /// the bounds of the pointer.</span></div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> createCheckForAccess(<a class="code" href="classllvm_1_1RuntimePointerChecking.html">RuntimePointerChecking</a> &amp;RtCheck,</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;                            MemAccessInfo Access,</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;                            <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;Strides,</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;                            <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Value *, unsigned&gt;</a> &amp;DepSetId,</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;                            <a class="code" href="classllvm_1_1Loop.html">Loop</a> *TheLoop, <span class="keywordtype">unsigned</span> &amp;RunningDepId,</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;                            <span class="keywordtype">unsigned</span> ASId, <span class="keywordtype">bool</span> ShouldCheckStride,</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;                            <span class="keywordtype">bool</span> Assume);</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;<span class="comment">  /// Check whether we can check the pointers at runtime for</span></div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;<span class="comment">  /// non-intersection.</span></div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;<span class="comment">  /// Returns true if we need no check or if we do and we can generate them</span></div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;<span class="comment">  /// (i.e. the pointers have computable bounds).</span></div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> canCheckPtrAtRT(<a class="code" href="classllvm_1_1RuntimePointerChecking.html">RuntimePointerChecking</a> &amp;RtCheck, <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE,</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;                       <a class="code" href="classllvm_1_1Loop.html">Loop</a> *TheLoop, <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;Strides,</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;                       <span class="keywordtype">bool</span> ShouldCheckWrap = <span class="keyword">false</span>);</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;<span class="comment">  /// Goes over all memory accesses, checks whether a RT check is needed</span></div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;<span class="comment">  /// and builds sets of dependent accesses.</span></div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> buildDependenceSets() {</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;    processMemAccesses();</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;  }</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;<span class="comment">  /// Initial processing of memory accesses determined that we need to</span></div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;<span class="comment">  /// perform dependency checking.</span></div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;<span class="comment">  /// Note that this can later be cleared if we retry memcheck analysis without</span></div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;<span class="comment">  /// dependency checking (i.e. FoundNonConstantDistanceDependence).</span></div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> isDependencyCheckNeeded() { <span class="keywordflow">return</span> !CheckDeps.empty(); }</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;<span class="comment">  /// We decided that no dependence analysis would be used.  Reset the state.</span></div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> resetDepChecks(<a class="code" href="classllvm_1_1MemoryDepChecker.html">MemoryDepChecker</a> &amp;DepChecker) {</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;    CheckDeps.clear();</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;    DepChecker.<a class="code" href="classllvm_1_1MemoryDepChecker.html#a67819b448429b42f3558c9b2e4ae4b45">clearDependences</a>();</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;  }</div><div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;</div><div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;  MemAccessInfoList &amp;getDependenciesToCheck() { <span class="keywordflow">return</span> CheckDeps; }</div><div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;</div><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;<span class="keyword">private</span>:</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;  <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1SetVector.html">SetVector&lt;MemAccessInfo&gt;</a> PtrAccessSet;</div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;<span class="comment">  /// Go over all memory access and check whether runtime pointer checks</span></div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;<span class="comment">  /// are needed and build sets of dependency check candidates.</span></div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;<span class="comment"></span>  <span class="keywordtype">void</span> processMemAccesses();</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;<span class="comment">  /// Set of all accesses.</span></div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;<span class="comment"></span>  PtrAccessSet Accesses;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;</div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL;</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;<span class="comment">  /// The loop being checked.</span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;<span class="comment"></span>  <span class="keyword">const</span> <a class="code" href="classllvm_1_1Loop.html">Loop</a> *TheLoop;</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;<span class="comment">  /// List of accesses that need a further dependence check.</span></div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;<span class="comment"></span>  MemAccessInfoList CheckDeps;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;<span class="comment">  /// Set of pointers that are read only.</span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;Value*, 16&gt;</a> ReadOnlyPtr;</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;<span class="comment">  /// An alias set tracker to partition the access set by underlying object and</span></div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;<span class="comment"></span>  <span class="comment">//intrinsic property (such as TBAA metadata).</span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;  <a class="code" href="classllvm_1_1AliasSetTracker.html">AliasSetTracker</a> AST;</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;  <a class="code" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI;</div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;<span class="comment">  /// Sets of potentially dependent accesses - members of one set share an</span></div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;<span class="comment">  /// underlying pointer. The set &quot;CheckDeps&quot; identfies which sets really need a</span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;<span class="comment">  /// dependence check.</span></div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1EquivalenceClasses.html">MemoryDepChecker::DepCandidates</a> &amp;DepCands;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;<span class="comment">  /// Initial processing of memory accesses determined that we may need</span></div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;<span class="comment">  /// to add memchecks.  Perform the analysis to determine the necessary checks.</span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;<span class="comment">  ///</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;<span class="comment">  /// Note that, this is different from isDependencyCheckNeeded.  When we retry</span></div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;<span class="comment">  /// memcheck analysis without dependency checking</span></div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;<span class="comment">  /// (i.e. FoundNonConstantDistanceDependence), isDependencyCheckNeeded is</span></div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;<span class="comment">  /// cleared while this remains set if we have potentially dependent accesses.</span></div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="comment"></span>  <span class="keywordtype">bool</span> IsRTCheckAnalysisNeeded;</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;<span class="comment">  /// The SCEV predicate containing all the SCEV-related assumptions.</span></div><div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;<span class="comment"></span>  <a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE;</div><div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;};</div><div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;</div><div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;} <span class="comment">// end anonymous namespace</span></div><div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;<span class="comment">/// Check whether a pointer can participate in a runtime bounds check.</span></div><div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;<span class="comment">/// If \p Assume, try harder to prove that we can compute the bounds of \p Ptr</span></div><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;<span class="comment">/// by adding run-time checks (overflow checks) if necessary.</span></div><div class="line"><a name="l00620"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#a607583a4185a380ea70c4d32ab3c872f">  620</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="LoopAccessAnalysis_8cpp.html#a607583a4185a380ea70c4d32ab3c872f">hasComputableBounds</a>(<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE,</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                                <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;Strides, <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr,</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;                                <a class="code" href="classllvm_1_1Loop.html">Loop</a> *L, <span class="keywordtype">bool</span> Assume) {</div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *PtrScev = <a class="code" href="namespacellvm.html#aa92a7ada2797ca16a2c0c540faafd7e1">replaceSymbolicStrideSCEV</a>(PSE, Strides, Ptr);</div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;</div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;  <span class="comment">// The bounds for loop-invariant pointer is trivial.</span></div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;  <span class="keywordflow">if</span> (PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a872704344573663359494dca7554c198">getSE</a>()-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a5a19768af81df7e5fe571bc08dcd48b3">isLoopInvariant</a>(PtrScev, L))</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;</div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a> *AR = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a>&gt;(PtrScev);</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;  <span class="keywordflow">if</span> (!AR &amp;&amp; Assume)</div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    AR = PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#aa364810e8fe30937277d9dd8a301c4c9">getAsAddRec</a>(Ptr);</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  <span class="keywordflow">if</span> (!AR)</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;  <span class="keywordflow">return</span> AR-&gt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html#a54bb7394d874cbbef1d81e6bea89d4f3">isAffine</a>();</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;}</div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;<span class="comment">/// Check whether a pointer address cannot wrap.</span></div><div class="line"><a name="l00641"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#afa2510327b4f778a5926fc3bbd6fa58e">  641</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="LoopAccessAnalysis_8cpp.html#afa2510327b4f778a5926fc3bbd6fa58e">isNoWrap</a>(<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE,</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;                     <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;Strides, <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="code" href="classllvm_1_1Loop.html">Loop</a> *L) {</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *PtrScev = PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#ae0994d8207b94ad22ecebc1a6bc580f1">getSCEV</a>(Ptr);</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;  <span class="keywordflow">if</span> (PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a872704344573663359494dca7554c198">getSE</a>()-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a5a19768af81df7e5fe571bc08dcd48b3">isLoopInvariant</a>(PtrScev, L))</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;</div><div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  int64_t Stride = <a class="code" href="namespacellvm.html#ab7f1b8ad3b5b4cb2cb19c2291dcf3cf1">getPtrStride</a>(PSE, Ptr, L, Strides);</div><div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  <span class="keywordflow">if</span> (Stride == 1 || PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a6fb96c9b4d017d69818db581dae5bd96">hasNoOverflow</a>(Ptr, <a class="code" href="classllvm_1_1SCEVWrapPredicate.html#a0cfd938ff9c572d287e5e7923624db70a17e825823d4b6a92c1b221c4460c91a3">SCEVWrapPredicate::IncrementNUSW</a>))</div><div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;</div><div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;}</div><div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;</div><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;<span class="keywordtype">bool</span> AccessAnalysis::createCheckForAccess(<a class="code" href="classllvm_1_1RuntimePointerChecking.html">RuntimePointerChecking</a> &amp;RtCheck,</div><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                                          MemAccessInfo Access,</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;                                          <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;StridesMap,</div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;                                          <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Value *, unsigned&gt;</a> &amp;DepSetId,</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;                                          <a class="code" href="classllvm_1_1Loop.html">Loop</a> *TheLoop, <span class="keywordtype">unsigned</span> &amp;RunningDepId,</div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;                                          <span class="keywordtype">unsigned</span> ASId, <span class="keywordtype">bool</span> ShouldCheckWrap,</div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;                                          <span class="keywordtype">bool</span> Assume) {</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr = Access.getPointer();</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="LoopAccessAnalysis_8cpp.html#a607583a4185a380ea70c4d32ab3c872f">hasComputableBounds</a>(PSE, StridesMap, Ptr, TheLoop, Assume))</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;  <span class="comment">// When we run after a failing dependency check we have to make sure</span></div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  <span class="comment">// we don&#39;t have wrapping pointers.</span></div><div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;  <span class="keywordflow">if</span> (ShouldCheckWrap &amp;&amp; !<a class="code" href="LoopAccessAnalysis_8cpp.html#afa2510327b4f778a5926fc3bbd6fa58e">isNoWrap</a>(PSE, StridesMap, Ptr, TheLoop)) {</div><div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;    <span class="keyword">auto</span> *Expr = PSE.getSCEV(Ptr);</div><div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;    <span class="keywordflow">if</span> (!Assume || !isa&lt;SCEVAddRecExpr&gt;(Expr))</div><div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;    PSE.setNoOverflow(Ptr, <a class="code" href="classllvm_1_1SCEVWrapPredicate.html#a0cfd938ff9c572d287e5e7923624db70a17e825823d4b6a92c1b221c4460c91a3">SCEVWrapPredicate::IncrementNUSW</a>);</div><div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;  }</div><div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div><div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;  <span class="comment">// The id of the dependence set.</span></div><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;  <span class="keywordtype">unsigned</span> DepId;</div><div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;</div><div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  <span class="keywordflow">if</span> (isDependencyCheckNeeded()) {</div><div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Leader = DepCands.<a class="code" href="classllvm_1_1EquivalenceClasses.html#a72c29f11de2d94ba0589624b00fac90a">getLeaderValue</a>(Access).getPointer();</div><div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;    <span class="keywordtype">unsigned</span> &amp;LeaderId = DepSetId[Leader];</div><div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;    <span class="keywordflow">if</span> (!LeaderId)</div><div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;      LeaderId = RunningDepId++;</div><div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;    DepId = LeaderId;</div><div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;  } <span class="keywordflow">else</span></div><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;    <span class="comment">// Each access has its own dependence set.</span></div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;    DepId = RunningDepId++;</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;  <span class="keywordtype">bool</span> IsWrite = Access.getInt();</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#af4009b07ade042922fe2f94d32b47844">insert</a>(TheLoop, Ptr, IsWrite, DepId, ASId, StridesMap, PSE);</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Found a runtime check ptr:&quot;</span> &lt;&lt; *Ptr &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>);</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160; }</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;<span class="keywordtype">bool</span> AccessAnalysis::canCheckPtrAtRT(<a class="code" href="classllvm_1_1RuntimePointerChecking.html">RuntimePointerChecking</a> &amp;RtCheck,</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;                                     <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE, <a class="code" href="classllvm_1_1Loop.html">Loop</a> *TheLoop,</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;                                     <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;StridesMap,</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;                                     <span class="keywordtype">bool</span> ShouldCheckWrap) {</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;  <span class="comment">// Find pointers with computable bounds. We are going to use this information</span></div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;  <span class="comment">// to place a runtime bound check.</span></div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;  <span class="keywordtype">bool</span> CanDoRT = <span class="keyword">true</span>;</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;</div><div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;  <span class="keywordtype">bool</span> NeedRTCheck = <span class="keyword">false</span>;</div><div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  <span class="keywordflow">if</span> (!IsRTCheckAnalysisNeeded) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;</div><div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;  <span class="keywordtype">bool</span> IsDepCheckNeeded = isDependencyCheckNeeded();</div><div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;</div><div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;  <span class="comment">// We assign a consecutive id to access from different alias sets.</span></div><div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;  <span class="comment">// Accesses between different groups doesn&#39;t need to be checked.</span></div><div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;  <span class="keywordtype">unsigned</span> ASId = 1;</div><div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;AS : AST) {</div><div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;    <span class="keywordtype">int</span> NumReadPtrChecks = 0;</div><div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;    <span class="keywordtype">int</span> NumWritePtrChecks = 0;</div><div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;    <span class="keywordtype">bool</span> CanDoAliasSetRT = <span class="keyword">true</span>;</div><div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;</div><div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;    <span class="comment">// We assign consecutive id to access from different dependence sets.</span></div><div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;    <span class="comment">// Accesses within the same set don&#39;t need a runtime check.</span></div><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;    <span class="keywordtype">unsigned</span> RunningDepId = 1;</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;    <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;Value *, unsigned&gt;</a> DepSetId;</div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;    <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;MemAccessInfo, 4&gt;</a> Retries;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;</div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> A : AS) {</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr = A.getValue();</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;      <span class="keywordtype">bool</span> IsWrite = Accesses.count(MemAccessInfo(Ptr, <span class="keyword">true</span>));</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;      MemAccessInfo Access(Ptr, IsWrite);</div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;      <span class="keywordflow">if</span> (IsWrite)</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;        ++NumWritePtrChecks;</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;      <span class="keywordflow">else</span></div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;        ++NumReadPtrChecks;</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;</div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;      <span class="keywordflow">if</span> (!createCheckForAccess(RtCheck, Access, StridesMap, DepSetId, TheLoop,</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;                                RunningDepId, ASId, ShouldCheckWrap, <span class="keyword">false</span>)) {</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;        <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Can&#39;t find bounds for ptr:&quot;</span> &lt;&lt; *Ptr &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>);</div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;        Retries.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#af42bfbc067df27c19ee2fc859df58799">push_back</a>(Access);</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;        CanDoAliasSetRT = <span class="keyword">false</span>;</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;      }</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    }</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    <span class="comment">// If we have at least two writes or one write and a read then we need to</span></div><div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;    <span class="comment">// check them.  But there is no need to checks if there is only one</span></div><div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;    <span class="comment">// dependence set for this alias set.</span></div><div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;    <span class="comment">// Note that this function computes CanDoRT and NeedRTCheck independently.</span></div><div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;    <span class="comment">// For example CanDoRT=false, NeedRTCheck=false means that we have a pointer</span></div><div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;    <span class="comment">// for which we couldn&#39;t find the bounds but we don&#39;t actually need to emit</span></div><div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;    <span class="comment">// any checks so it does not matter.</span></div><div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;    <span class="keywordtype">bool</span> NeedsAliasSetRTCheck = <span class="keyword">false</span>;</div><div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;    <span class="keywordflow">if</span> (!(IsDepCheckNeeded &amp;&amp; CanDoAliasSetRT &amp;&amp; RunningDepId == 2))</div><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;      NeedsAliasSetRTCheck = (NumWritePtrChecks &gt;= 2 ||</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;                             (NumReadPtrChecks &gt;= 1 &amp;&amp; NumWritePtrChecks &gt;= 1));</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;    <span class="comment">// We need to perform run-time alias checks, but some pointers had bounds</span></div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;    <span class="comment">// that couldn&#39;t be checked.</span></div><div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;    <span class="keywordflow">if</span> (NeedsAliasSetRTCheck &amp;&amp; !CanDoAliasSetRT) {</div><div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;      <span class="comment">// Reset the CanDoSetRt flag and retry all accesses that have failed.</span></div><div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;      <span class="comment">// We know that we need these checks, so we can now be more aggressive</span></div><div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;      <span class="comment">// and add further checks if required (overflow checks).</span></div><div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;      CanDoAliasSetRT = <span class="keyword">true</span>;</div><div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> Access : Retries)</div><div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;        <span class="keywordflow">if</span> (!createCheckForAccess(RtCheck, Access, StridesMap, DepSetId,</div><div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;                                  TheLoop, RunningDepId, ASId,</div><div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;                                  ShouldCheckWrap, <span class="comment">/*Assume=*/</span><span class="keyword">true</span>)) {</div><div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;          CanDoAliasSetRT = <span class="keyword">false</span>;</div><div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;          <span class="keywordflow">break</span>;</div><div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;        }</div><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;    }</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;    CanDoRT &amp;= CanDoAliasSetRT;</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    NeedRTCheck |= NeedsAliasSetRTCheck;</div><div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;    ++ASId;</div><div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;  }</div><div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;</div><div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;  <span class="comment">// If the pointers that we would use for the bounds comparison have different</span></div><div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;  <span class="comment">// address spaces, assume the values aren&#39;t directly comparable, so we can&#39;t</span></div><div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;  <span class="comment">// use them for the runtime check. We also have to assume they could</span></div><div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;  <span class="comment">// overlap. In the future there should be metadata for whether address spaces</span></div><div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;  <span class="comment">// are disjoint.</span></div><div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;  <span class="keywordtype">unsigned</span> NumPointers = RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#aa6ad96a1c2591e0a61c92e0be5776978">Pointers</a>.size();</div><div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> i = 0; i &lt; NumPointers; ++i) {</div><div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> j = i + 1; j &lt; NumPointers; ++j) {</div><div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;      <span class="comment">// Only need to check pointers between two different dependency sets.</span></div><div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;      <span class="keywordflow">if</span> (RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#aa6ad96a1c2591e0a61c92e0be5776978">Pointers</a>[i].DependencySetId ==</div><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;          RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#aa6ad96a1c2591e0a61c92e0be5776978">Pointers</a>[j].DependencySetId)</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;       <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;      <span class="comment">// Only need to check pointers in the same alias set.</span></div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;      <span class="keywordflow">if</span> (RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#aa6ad96a1c2591e0a61c92e0be5776978">Pointers</a>[i].AliasSetId != RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#aa6ad96a1c2591e0a61c92e0be5776978">Pointers</a>[j].AliasSetId)</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;</div><div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *PtrI = RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#aa6ad96a1c2591e0a61c92e0be5776978">Pointers</a>[i].PointerValue;</div><div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;      <a class="code" href="classllvm_1_1Value.html">Value</a> *PtrJ = RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#aa6ad96a1c2591e0a61c92e0be5776978">Pointers</a>[j].PointerValue;</div><div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div><div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;      <span class="keywordtype">unsigned</span> ASi = PtrI-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a5ab2d0b0f0b8ceec3b907184e7567197">getPointerAddressSpace</a>();</div><div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;      <span class="keywordtype">unsigned</span> ASj = PtrJ-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a5ab2d0b0f0b8ceec3b907184e7567197">getPointerAddressSpace</a>();</div><div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;      <span class="keywordflow">if</span> (ASi != ASj) {</div><div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;        <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;            <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Runtime check would require comparison between&quot;</span></div><div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;                      <span class="stringliteral">&quot; different address spaces\n&quot;</span>);</div><div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;      }</div><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;    }</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;  }</div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;  <span class="keywordflow">if</span> (NeedRTCheck &amp;&amp; CanDoRT)</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;    RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#a799b2020cc896db04085849aed060f20">generateChecks</a>(DepCands, IsDepCheckNeeded);</div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: We need to do &quot;</span> &lt;&lt; RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#a24e5c89884a8b7b92a1d27da4e94e230">getNumberOfChecks</a>()</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;                    &lt;&lt; <span class="stringliteral">&quot; pointer comparisons.\n&quot;</span>);</div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;  RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#a177df4fcdf758fb57ca59102c15d30c3">Need</a> = NeedRTCheck;</div><div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;</div><div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;  <span class="keywordtype">bool</span> CanDoRTIfNeeded = !NeedRTCheck || CanDoRT;</div><div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;  <span class="keywordflow">if</span> (!CanDoRTIfNeeded)</div><div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;    RtCheck.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#a1b570db2adb62a2c7ffca1869987682b">reset</a>();</div><div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;  <span class="keywordflow">return</span> CanDoRTIfNeeded;</div><div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;}</div><div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;</div><div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="keywordtype">void</span> AccessAnalysis::processMemAccesses() {</div><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;  <span class="comment">// We process the set twice: first we process read-write pointers, last we</span></div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;  <span class="comment">// process read-only pointers. This allows us to skip dependence tests for</span></div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;  <span class="comment">// read-only pointers.</span></div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Processing memory accesses...\n&quot;</span>);</div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  AST: &quot;</span>; AST.dump());</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA:   Accesses(&quot;</span> &lt;&lt; Accesses.size() &lt;&lt; <span class="stringliteral">&quot;):\n&quot;</span>);</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>({</div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> A : Accesses)</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;      <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; *A.getPointer() &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt;</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;                (A.getInt() ? <span class="stringliteral">&quot;write&quot;</span> : (ReadOnlyPtr.count(A.getPointer()) ?</div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;                                         <span class="stringliteral">&quot;read-only&quot;</span> : <span class="stringliteral">&quot;read&quot;</span>)) &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>;</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;  });</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;</div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;  <span class="comment">// The AliasSetTracker has nicely partitioned our pointers by metadata</span></div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;  <span class="comment">// compatibility and potential for underlying-object overlap. As a result, we</span></div><div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;  <span class="comment">// only need to check for potential pointer dependencies within each alias</span></div><div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;  <span class="comment">// set.</span></div><div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;AS : AST) {</div><div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;    <span class="comment">// Note that both the alias-set tracker and the alias sets themselves used</span></div><div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;    <span class="comment">// linked lists internally and so the iteration order here is deterministic</span></div><div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;    <span class="comment">// (matching the original instruction order within each set).</span></div><div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;</div><div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;    <span class="keywordtype">bool</span> SetHasWrite = <span class="keyword">false</span>;</div><div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;</div><div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;    <span class="comment">// Map of pointers to last access encountered.</span></div><div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;    <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1DenseMap.html">DenseMap&lt;const Value*, MemAccessInfo&gt;</a> UnderlyingObjToAccessMap;</div><div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;    UnderlyingObjToAccessMap ObjToLastAccess;</div><div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;</div><div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;    <span class="comment">// Set of access to check after all writes have been processed.</span></div><div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;    PtrAccessSet DeferredAccesses;</div><div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;</div><div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;    <span class="comment">// Iterate over each alias set twice, once to process read/write pointers,</span></div><div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;    <span class="comment">// and then to process read-only pointers.</span></div><div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> SetIteration = 0; SetIteration &lt; 2; ++SetIteration) {</div><div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;      <span class="keywordtype">bool</span> UseDeferred = SetIteration &gt; 0;</div><div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;      PtrAccessSet &amp;S = UseDeferred ? DeferredAccesses : Accesses;</div><div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;</div><div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;      <span class="keywordflow">for</span> (<span class="keyword">auto</span> AV : AS) {</div><div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;        <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr = AV.getValue();</div><div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;</div><div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;        <span class="comment">// For a single memory access in AliasSetTracker, Accesses may contain</span></div><div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;        <span class="comment">// both read and write, and they both need to be handled for CheckDeps.</span></div><div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;        <span class="keywordflow">for</span> (<span class="keyword">auto</span> AC : S) {</div><div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;          <span class="keywordflow">if</span> (AC.getPointer() != Ptr)</div><div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;</div><div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;          <span class="keywordtype">bool</span> IsWrite = AC.getInt();</div><div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;</div><div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;          <span class="comment">// If we&#39;re using the deferred access set, then it contains only</span></div><div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;          <span class="comment">// reads.</span></div><div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;          <span class="keywordtype">bool</span> IsReadOnlyPtr = ReadOnlyPtr.count(Ptr) &amp;&amp; !IsWrite;</div><div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;          <span class="keywordflow">if</span> (UseDeferred &amp;&amp; !IsReadOnlyPtr)</div><div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;          <span class="comment">// Otherwise, the pointer must be in the PtrAccessSet, either as a</span></div><div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;          <span class="comment">// read or a write.</span></div><div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;          <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(((IsReadOnlyPtr &amp;&amp; UseDeferred) || IsWrite ||</div><div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;                  S.count(MemAccessInfo(Ptr, <span class="keyword">false</span>))) &amp;&amp;</div><div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;                 <span class="stringliteral">&quot;Alias-set pointer not in the access set?&quot;</span>);</div><div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;</div><div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;          MemAccessInfo Access(Ptr, IsWrite);</div><div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;          DepCands.<a class="code" href="classllvm_1_1EquivalenceClasses.html#a902c4503f25e4565da04114268650985">insert</a>(Access);</div><div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;</div><div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;          <span class="comment">// Memorize read-only pointers for later processing and skip them in</span></div><div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;          <span class="comment">// the first round (they need to be checked after we have seen all</span></div><div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;          <span class="comment">// write pointers). Note: we also mark pointer that are not</span></div><div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;          <span class="comment">// consecutive as &quot;read-only&quot; pointers (so that we check</span></div><div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;          <span class="comment">// &quot;a[b[i]] +=&quot;). Hence, we need the second check for &quot;!IsWrite&quot;.</span></div><div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;          <span class="keywordflow">if</span> (!UseDeferred &amp;&amp; IsReadOnlyPtr) {</div><div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;            DeferredAccesses.insert(Access);</div><div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;            <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;          }</div><div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;</div><div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;          <span class="comment">// If this is a write - check other reads and writes for conflicts. If</span></div><div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;          <span class="comment">// this is a read only check other writes for conflicts (but only if</span></div><div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;          <span class="comment">// there is no other write to the ptr - this is an optimization to</span></div><div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;          <span class="comment">// catch &quot;a[i] = a[i] + &quot; without having to do a dependence check).</span></div><div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;          <span class="keywordflow">if</span> ((IsWrite || IsReadOnlyPtr) &amp;&amp; SetHasWrite) {</div><div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;            CheckDeps.push_back(Access);</div><div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;            IsRTCheckAnalysisNeeded = <span class="keyword">true</span>;</div><div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;          }</div><div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;</div><div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;          <span class="keywordflow">if</span> (IsWrite)</div><div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;            SetHasWrite = <span class="keyword">true</span>;</div><div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;</div><div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;          <span class="comment">// Create sets of pointers connected by a shared alias set and</span></div><div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;          <span class="comment">// underlying object.</span></div><div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;          <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;const Value *, 16&gt;</a> ValueVector;</div><div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;          ValueVector TempObjects;</div><div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;</div><div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;          <a class="code" href="namespacellvm.html#ad3428471506e6c03e9395a697a897a83">GetUnderlyingObjects</a>(Ptr, TempObjects, DL, LI);</div><div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;          <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>()</div><div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;                     &lt;&lt; <span class="stringliteral">&quot;Underlying objects for pointer &quot;</span> &lt;&lt; *Ptr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;          <span class="keywordflow">for</span> (<span class="keyword">const</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *UnderlyingObj : TempObjects) {</div><div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;            <span class="comment">// nullptr never alias, don&#39;t join sets for pointer that have &quot;null&quot;</span></div><div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;            <span class="comment">// in their UnderlyingObjects list.</span></div><div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;            <span class="keywordflow">if</span> (isa&lt;ConstantPointerNull&gt;(UnderlyingObj) &amp;&amp;</div><div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;                !<a class="code" href="namespacellvm.html#a7b03ed78a8e299bde6d26a8793cd4e06">NullPointerIsDefined</a>(</div><div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;                    TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>()-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#a38bee869ad41aebfef3de2641b12004c">getParent</a>(),</div><div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;                    UnderlyingObj-&gt;<a class="code" href="classllvm_1_1GlobalValue.html#a92041fc7f781ba4fe708eec99139b72f">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a5ab2d0b0f0b8ceec3b907184e7567197">getPointerAddressSpace</a>()))</div><div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;              <span class="keywordflow">continue</span>;</div><div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;</div><div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;            UnderlyingObjToAccessMap::iterator Prev =</div><div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;                ObjToLastAccess.find(UnderlyingObj);</div><div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;            <span class="keywordflow">if</span> (Prev != ObjToLastAccess.end())</div><div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;              DepCands.<a class="code" href="classllvm_1_1EquivalenceClasses.html#aef0dc9d4f28e4982cfd008cc4b53e479">unionSets</a>(Access, Prev-&gt;second);</div><div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;</div><div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;            ObjToLastAccess[UnderlyingObj] = Access;</div><div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;            <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  &quot;</span> &lt;&lt; *UnderlyingObj &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;          }</div><div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;        }</div><div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;      }</div><div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;    }</div><div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;  }</div><div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;}</div><div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div><div class="line"><a name="l00936"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#abe6d015febd4845fa107ab9c87c031c0">  936</a></span>&#160;<span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="LoopAccessAnalysis_8cpp.html#abe6d015febd4845fa107ab9c87c031c0">isInBoundsGep</a>(<a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr) {</div><div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1GetElementPtrInst.html">GetElementPtrInst</a> *<a class="code" href="HexagonCommonGEP_8cpp.html#ad532e8710e50302e0a376b61c91fa91d">GEP</a> = dyn_cast&lt;GetElementPtrInst&gt;(Ptr))</div><div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="HexagonCommonGEP_8cpp.html#ad532e8710e50302e0a376b61c91fa91d">GEP</a>-&gt;isInBounds();</div><div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;}</div><div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;<span class="comment">/// Return true if an AddRec pointer \p Ptr is unsigned non-wrapping,</span></div><div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;<span class="comment">/// i.e. monotonically increasing/decreasing.</span></div><div class="line"><a name="l00944"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#a9d9847ba3ad2bc2837b041581277a8fb">  944</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="LoopAccessAnalysis_8cpp.html#a9d9847ba3ad2bc2837b041581277a8fb">isNoWrapAddRec</a>(<a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr, <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a> *AR,</div><div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;                           <a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE, <span class="keyword">const</span> <a class="code" href="classllvm_1_1Loop.html">Loop</a> *L) {</div><div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;  <span class="comment">// FIXME: This should probably only return true for NUW.</span></div><div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;  <span class="keywordflow">if</span> (AR-&gt;<a class="code" href="classllvm_1_1SCEVNAryExpr.html#a7275347a4dce174f4fecd548fd3255dc">getNoWrapFlags</a>(<a class="code" href="classllvm_1_1SCEV.html#af43000d4dcb7d6d63cb6e36933ed3f6fae022582ed4b56bdb108b4488809e11e6">SCEV::NoWrapMask</a>))</div><div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;</div><div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;  <span class="comment">// Scalar evolution does not propagate the non-wrapping flags to values that</span></div><div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;  <span class="comment">// are derived from a non-wrapping induction variable because non-wrapping</span></div><div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;  <span class="comment">// could be flow-sensitive.</span></div><div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;  <span class="comment">// Look through the potentially overflowing instruction to try to prove</span></div><div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;  <span class="comment">// non-wrapping for the *specific* value of Ptr.</span></div><div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;</div><div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;  <span class="comment">// The arithmetic implied by an inbounds GEP can&#39;t overflow.</span></div><div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;  <span class="keyword">auto</span> *<a class="code" href="HexagonCommonGEP_8cpp.html#ad532e8710e50302e0a376b61c91fa91d">GEP</a> = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1GetElementPtrInst.html">GetElementPtrInst</a>&gt;(Ptr);</div><div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;  <span class="keywordflow">if</span> (!<a class="code" href="HexagonCommonGEP_8cpp.html#ad532e8710e50302e0a376b61c91fa91d">GEP</a> || !<a class="code" href="HexagonCommonGEP_8cpp.html#ad532e8710e50302e0a376b61c91fa91d">GEP</a>-&gt;isInBounds())</div><div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;</div><div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;  <span class="comment">// Make sure there is only one non-const index and analyze that.</span></div><div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *NonConstIndex = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a> : <a class="code" href="namespacellvm.html#ad1a91b49e0c092818a0b82f6cc130a1b">make_range</a>(<a class="code" href="HexagonCommonGEP_8cpp.html#ad532e8710e50302e0a376b61c91fa91d">GEP</a>-&gt;idx_begin(), <a class="code" href="HexagonCommonGEP_8cpp.html#ad532e8710e50302e0a376b61c91fa91d">GEP</a>-&gt;idx_end()))</div><div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;    <span class="keywordflow">if</span> (!isa&lt;ConstantInt&gt;(<a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>)) {</div><div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;      <span class="keywordflow">if</span> (NonConstIndex)</div><div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;      NonConstIndex = <a class="code" href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">Index</a>;</div><div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;    }</div><div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;  <span class="keywordflow">if</span> (!NonConstIndex)</div><div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;    <span class="comment">// The recurrence is on the pointer, ignore for now.</span></div><div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;</div><div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;  <span class="comment">// The index in GEP is signed.  It is non-wrapping if it&#39;s derived from a NSW</span></div><div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;  <span class="comment">// AddRec using a NSW operation.</span></div><div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> *OBO = dyn_cast&lt;OverflowingBinaryOperator&gt;(NonConstIndex))</div><div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;    <span class="keywordflow">if</span> (OBO-&gt;hasNoSignedWrap() &amp;&amp;</div><div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;        <span class="comment">// Assume constant for other the operand so that the AddRec can be</span></div><div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;        <span class="comment">// easily found.</span></div><div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;        isa&lt;ConstantInt&gt;(OBO-&gt;getOperand(1))) {</div><div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;      <span class="keyword">auto</span> *OpScev = PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#ae0994d8207b94ad22ecebc1a6bc580f1">getSCEV</a>(OBO-&gt;getOperand(0));</div><div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;</div><div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">auto</span> *OpAR = dyn_cast&lt;SCEVAddRecExpr&gt;(OpScev))</div><div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;        <span class="keywordflow">return</span> OpAR-&gt;getLoop() == L &amp;&amp; OpAR-&gt;getNoWrapFlags(<a class="code" href="classllvm_1_1SCEV.html#af43000d4dcb7d6d63cb6e36933ed3f6fa2f7a8775a783f7ea3ad24b3f9cb5d949">SCEV::FlagNSW</a>);</div><div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;    }</div><div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;</div><div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;}</div><div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;<span class="comment"></span></div><div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;<span class="comment">/// Check whether the access through \p Ptr has a constant stride.</span></div><div class="line"><a name="l00991"></a><span class="lineno"><a class="line" href="namespacellvm.html#ab7f1b8ad3b5b4cb2cb19c2291dcf3cf1">  991</a></span>&#160;<span class="comment"></span>int64_t <a class="code" href="namespacellvm.html#ab7f1b8ad3b5b4cb2cb19c2291dcf3cf1">llvm::getPtrStride</a>(<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a> &amp;PSE, <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr,</div><div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;                           <span class="keyword">const</span> <a class="code" href="classllvm_1_1Loop.html">Loop</a> *Lp, <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;StridesMap,</div><div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;                           <span class="keywordtype">bool</span> Assume, <span class="keywordtype">bool</span> ShouldCheckWrap) {</div><div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *Ty = Ptr-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>();</div><div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(Ty-&gt;<a class="code" href="classllvm_1_1Type.html#a3b996fbf8458aafffc86cb98a68d0a47">isPointerTy</a>() &amp;&amp; <span class="stringliteral">&quot;Unexpected non-ptr&quot;</span>);</div><div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;</div><div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;  <span class="comment">// Make sure that the pointer does not point to aggregate types.</span></div><div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;  <span class="keyword">auto</span> *PtrTy = cast&lt;PointerType&gt;(Ty);</div><div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;  <span class="keywordflow">if</span> (PtrTy-&gt;getElementType()-&gt;isAggregateType()) {</div><div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Bad stride - Not a pointer to a scalar type&quot;</span></div><div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;                      &lt;&lt; *Ptr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;  }</div><div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;</div><div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *PtrScev = <a class="code" href="namespacellvm.html#aa92a7ada2797ca16a2c0c540faafd7e1">replaceSymbolicStrideSCEV</a>(PSE, StridesMap, Ptr);</div><div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;</div><div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a> *AR = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html">SCEVAddRecExpr</a>&gt;(PtrScev);</div><div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;  <span class="keywordflow">if</span> (Assume &amp;&amp; !AR)</div><div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;    AR = PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#aa364810e8fe30937277d9dd8a301c4c9">getAsAddRec</a>(Ptr);</div><div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;</div><div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;  <span class="keywordflow">if</span> (!AR) {</div><div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Bad stride - Not an AddRecExpr pointer &quot;</span> &lt;&lt; *Ptr</div><div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;                      &lt;&lt; <span class="stringliteral">&quot; SCEV: &quot;</span> &lt;&lt; *PtrScev &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;  }</div><div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;</div><div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;  <span class="comment">// The access function must stride over the innermost loop.</span></div><div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;  <span class="keywordflow">if</span> (Lp != AR-&gt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html#af6314c51a3cc5a619beb697246177bf0">getLoop</a>()) {</div><div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Bad stride - Not striding over innermost loop &quot;</span></div><div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;                      &lt;&lt; *Ptr &lt;&lt; <span class="stringliteral">&quot; SCEV: &quot;</span> &lt;&lt; *AR &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;  }</div><div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;</div><div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;  <span class="comment">// The address calculation must not wrap. Otherwise, a dependence could be</span></div><div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;  <span class="comment">// inverted.</span></div><div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;  <span class="comment">// An inbounds getelementptr that is a AddRec with a unit stride</span></div><div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;  <span class="comment">// cannot wrap per definition. The unit stride requirement is checked later.</span></div><div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;  <span class="comment">// An getelementptr without an inbounds attribute and unit stride would have</span></div><div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;  <span class="comment">// to access the pointer value &quot;0&quot; which is undefined behavior in address</span></div><div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;  <span class="comment">// space 0, therefore we can also vectorize this case.</span></div><div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;  <span class="keywordtype">bool</span> IsInBoundsGEP = <a class="code" href="LoopAccessAnalysis_8cpp.html#abe6d015febd4845fa107ab9c87c031c0">isInBoundsGep</a>(Ptr);</div><div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;  <span class="keywordtype">bool</span> IsNoWrapAddRec = !ShouldCheckWrap ||</div><div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;    PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a6fb96c9b4d017d69818db581dae5bd96">hasNoOverflow</a>(Ptr, <a class="code" href="classllvm_1_1SCEVWrapPredicate.html#a0cfd938ff9c572d287e5e7923624db70a17e825823d4b6a92c1b221c4460c91a3">SCEVWrapPredicate::IncrementNUSW</a>) ||</div><div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;    <a class="code" href="LoopAccessAnalysis_8cpp.html#a9d9847ba3ad2bc2837b041581277a8fb">isNoWrapAddRec</a>(Ptr, AR, PSE, Lp);</div><div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;  <span class="keywordflow">if</span> (!IsNoWrapAddRec &amp;&amp; !IsInBoundsGEP &amp;&amp;</div><div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;      <a class="code" href="namespacellvm.html#a7b03ed78a8e299bde6d26a8793cd4e06">NullPointerIsDefined</a>(Lp-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>()-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#a38bee869ad41aebfef3de2641b12004c">getParent</a>(),</div><div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;                           PtrTy-&gt;<a class="code" href="classllvm_1_1GlobalValue.html#a0557bd873ed2afae533faa02e3168d70">getAddressSpace</a>())) {</div><div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;    <span class="keywordflow">if</span> (Assume) {</div><div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;      PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a757ce31dd838b17c024287ce9d17c4c2">setNoOverflow</a>(Ptr, <a class="code" href="classllvm_1_1SCEVWrapPredicate.html#a0cfd938ff9c572d287e5e7923624db70a17e825823d4b6a92c1b221c4460c91a3">SCEVWrapPredicate::IncrementNUSW</a>);</div><div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;      IsNoWrapAddRec = <span class="keyword">true</span>;</div><div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;      <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Pointer may wrap in the address space:\n&quot;</span></div><div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;                        &lt;&lt; <span class="stringliteral">&quot;LAA:   Pointer: &quot;</span> &lt;&lt; *Ptr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;                        &lt;&lt; <span class="stringliteral">&quot;LAA:   SCEV: &quot;</span> &lt;&lt; *AR &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;                        &lt;&lt; <span class="stringliteral">&quot;LAA:   Added an overflow assumption\n&quot;</span>);</div><div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;    } <span class="keywordflow">else</span> {</div><div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;      <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;          <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Bad stride - Pointer may wrap in the address space &quot;</span></div><div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;                 &lt;&lt; *Ptr &lt;&lt; <span class="stringliteral">&quot; SCEV: &quot;</span> &lt;&lt; *AR &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;      <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;    }</div><div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;  }</div><div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;</div><div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;  <span class="comment">// Check the step is constant.</span></div><div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Step = AR-&gt;<a class="code" href="classllvm_1_1SCEVAddRecExpr.html#a7eec28400b00678b1fb2b5f55ef7ac1b">getStepRecurrence</a>(*PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a872704344573663359494dca7554c198">getSE</a>());</div><div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;</div><div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;  <span class="comment">// Calculate the pointer stride and check if it is constant.</span></div><div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEVConstant.html">SCEVConstant</a> *<a class="code" href="NVVMIntrRange_8cpp.html#a2ae53ee71b2ccbb52b883c0b4f59f8c2">C</a> = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1SCEVConstant.html">SCEVConstant</a>&gt;(Step);</div><div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;  <span class="keywordflow">if</span> (!C) {</div><div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Bad stride - Not a constant strided &quot;</span> &lt;&lt; *Ptr</div><div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;                      &lt;&lt; <span class="stringliteral">&quot; SCEV: &quot;</span> &lt;&lt; *AR &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;  }</div><div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;</div><div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;  <span class="keyword">auto</span> &amp;DL = Lp-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>()-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#afc70e919c88c86159cc94cea29b6c210">getModule</a>()-&gt;<a class="code" href="classllvm_1_1Module.html#a6d883605206368bc536cc9ded97209b8">getDataLayout</a>();</div><div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;  int64_t <a class="code" href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a> = DL.getTypeAllocSize(PtrTy-&gt;getElementType());</div><div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1APInt.html">APInt</a> &amp;APStepVal = C-&gt;<a class="code" href="classllvm_1_1SCEVConstant.html#a17304ab072a5b259c03e766a2b78a30b">getAPInt</a>();</div><div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;</div><div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;  <span class="comment">// Huge step value - give up.</span></div><div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;  <span class="keywordflow">if</span> (APStepVal.<a class="code" href="classllvm_1_1APInt.html#a512fe2c15ea651294688eeec1341644c">getBitWidth</a>() &gt; 64)</div><div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;</div><div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;  int64_t StepVal = APStepVal.<a class="code" href="classllvm_1_1APInt.html#af2daa0ee117afefed4c82eee55bf97b7">getSExtValue</a>();</div><div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;</div><div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;  <span class="comment">// Strided access.</span></div><div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;  int64_t Stride = StepVal / <a class="code" href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a>;</div><div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;  int64_t Rem = StepVal % <a class="code" href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a>;</div><div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;  <span class="keywordflow">if</span> (Rem)</div><div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;    <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;</div><div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;  <span class="comment">// If the SCEV could wrap but we have an inbounds gep with a unit stride we</span></div><div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;  <span class="comment">// know we can&#39;t &quot;wrap around the address space&quot;. In case of address space</span></div><div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;  <span class="comment">// zero we know that this won&#39;t happen without triggering undefined behavior.</span></div><div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;  <span class="keywordflow">if</span> (!IsNoWrapAddRec &amp;&amp; Stride != 1 &amp;&amp; Stride != -1 &amp;&amp;</div><div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;      (IsInBoundsGEP || !<a class="code" href="namespacellvm.html#a7b03ed78a8e299bde6d26a8793cd4e06">NullPointerIsDefined</a>(Lp-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>()-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#a38bee869ad41aebfef3de2641b12004c">getParent</a>(),</div><div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;                                              PtrTy-&gt;<a class="code" href="classllvm_1_1GlobalValue.html#a0557bd873ed2afae533faa02e3168d70">getAddressSpace</a>()))) {</div><div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;    <span class="keywordflow">if</span> (Assume) {</div><div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;      <span class="comment">// We can avoid this case by adding a run-time check.</span></div><div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;      <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Non unit strided pointer which is not either &quot;</span></div><div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;                        &lt;&lt; <span class="stringliteral">&quot;inbounds or in address space 0 may wrap:\n&quot;</span></div><div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;                        &lt;&lt; <span class="stringliteral">&quot;LAA:   Pointer: &quot;</span> &lt;&lt; *Ptr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;                        &lt;&lt; <span class="stringliteral">&quot;LAA:   SCEV: &quot;</span> &lt;&lt; *AR &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span></div><div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;                        &lt;&lt; <span class="stringliteral">&quot;LAA:   Added an overflow assumption\n&quot;</span>);</div><div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;      PSE.<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html#a757ce31dd838b17c024287ce9d17c4c2">setNoOverflow</a>(Ptr, <a class="code" href="classllvm_1_1SCEVWrapPredicate.html#a0cfd938ff9c572d287e5e7923624db70a17e825823d4b6a92c1b221c4460c91a3">SCEVWrapPredicate::IncrementNUSW</a>);</div><div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;    } <span class="keywordflow">else</span></div><div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;      <span class="keywordflow">return</span> 0;</div><div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;  }</div><div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;</div><div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;  <span class="keywordflow">return</span> Stride;</div><div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;}</div><div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;</div><div class="line"><a name="l01101"></a><span class="lineno"><a class="line" href="namespacellvm.html#ad93acb4fcb5adbd7e5f41deb092cb26d"> 1101</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#ad93acb4fcb5adbd7e5f41deb092cb26d">llvm::sortPtrAccesses</a>(<a class="code" href="classllvm_1_1ArrayRef.html">ArrayRef&lt;Value *&gt;</a> VL, <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL,</div><div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;                           <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE,</div><div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;                           <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;unsigned&gt;</a> &amp;SortedIndices) {</div><div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(<a class="code" href="namespacellvm.html#a0d10fe510ced2849a8074fe81e5d04ce">llvm::all_of</a>(</div><div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;             VL, [](<span class="keyword">const</span> <a class="code" href="classllvm_1_1Value.html">Value</a> *V) { <span class="keywordflow">return</span> V-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a3b996fbf8458aafffc86cb98a68d0a47">isPointerTy</a>(); }) &amp;&amp;</div><div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;         <span class="stringliteral">&quot;Expected list of pointer operands.&quot;</span>);</div><div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;std::pair&lt;int64_t, Value *&gt;</a>, 4&gt; OffValPairs;</div><div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;  OffValPairs.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a499ea32ca1b8d16cedfe01d1e5b08f29">reserve</a>(VL.<a class="code" href="classllvm_1_1ArrayRef.html#a85ffb6531d4cda988ea81f18d4e56fb7">size</a>());</div><div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;</div><div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;  <span class="comment">// Walk over the pointers, and map each of them to an offset relative to</span></div><div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;  <span class="comment">// first pointer in the array.</span></div><div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr0 = VL[0];</div><div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Scev0 = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49">getSCEV</a>(Ptr0);</div><div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *Obj0 = <a class="code" href="namespacellvm.html#a5a8d41e9958a4ff2156f1f03f26a2eb3">GetUnderlyingObject</a>(Ptr0, DL);</div><div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;</div><div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;  <a class="code" href="classllvm_1_1SmallSet.html">llvm::SmallSet&lt;int64_t, 4&gt;</a> <a class="code" href="namespacellvm_1_1SI_1_1KernelInputOffsets.html#a58b4eae4b0a45d478c7c0f3959b04612">Offsets</a>;</div><div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">auto</span> *Ptr : VL) {</div><div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    <span class="comment">// TODO: Outline this code as a special, more time consuming, version of</span></div><div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;    <span class="comment">// computeConstantDifference() function.</span></div><div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    <span class="keywordflow">if</span> (Ptr-&gt;getType()-&gt;getPointerAddressSpace() !=</div><div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;        Ptr0-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a5ab2d0b0f0b8ceec3b907184e7567197">getPointerAddressSpace</a>())</div><div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;    <span class="comment">// If a pointer refers to a different underlying object, bail - the</span></div><div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;    <span class="comment">// pointers are by definition incomparable.</span></div><div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *CurrObj = <a class="code" href="namespacellvm.html#a5a8d41e9958a4ff2156f1f03f26a2eb3">GetUnderlyingObject</a>(Ptr, DL);</div><div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;    <span class="keywordflow">if</span> (CurrObj != Obj0)</div><div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;</div><div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Scev = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49">getSCEV</a>(Ptr);</div><div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;    <span class="keyword">const</span> <span class="keyword">auto</span> *Diff = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1SCEVConstant.html">SCEVConstant</a>&gt;(SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a8bcb86d8d126d95b0dc05f09e8f3df96">getMinusSCEV</a>(Scev, Scev0));</div><div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;    <span class="comment">// The pointers may not have a constant offset from each other, or SCEV</span></div><div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;    <span class="comment">// may just not be smart enough to figure out they do. Regardless,</span></div><div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;    <span class="comment">// there&#39;s nothing we can do.</span></div><div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;    <span class="keywordflow">if</span> (!Diff)</div><div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;</div><div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;    <span class="comment">// Check if the pointer with the same offset is found.</span></div><div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;    int64_t <a class="code" href="namespacellvm_1_1AMDGPU_1_1Hwreg.html#a6110fc30bc7311a6cf99814530362e21">Offset</a> = Diff-&gt;getAPInt().getSExtValue();</div><div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    <span class="keywordflow">if</span> (!Offsets.<a class="code" href="classllvm_1_1SmallSet.html#a892daa20eb21173ba89e9fe9702e7f6c">insert</a>(Offset).second)</div><div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;    OffValPairs.<a class="code" href="classllvm_1_1SmallVectorImpl.html#a396fcfee6914c76974b73c3d203da6a5">emplace_back</a>(Offset, Ptr);</div><div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;  }</div><div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;  SortedIndices.<a class="code" href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">clear</a>();</div><div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;  SortedIndices.<a class="code" href="classllvm_1_1SmallVectorImpl.html#ad0b3d8447f88377b62d9c019f3c4e118">resize</a>(VL.size());</div><div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;  std::iota(SortedIndices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a8a045d250952c0867382a9840ee18fdf">begin</a>(), SortedIndices.<a class="code" href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">end</a>(), 0);</div><div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;</div><div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;  <span class="comment">// Sort the memory accesses and keep the order of their uses in UseOrder.</span></div><div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;  <a class="code" href="namespacellvm.html#a076f93c387f454f0db13d4bc7d4e7f9c">llvm::stable_sort</a>(SortedIndices, [&amp;](<span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm.html#a2554a96c67bdd7d0a62855a844ec55b0a945d5e233cf7d6240f6b783b36a374ff">Left</a>, <span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm.html#a2554a96c67bdd7d0a62855a844ec55b0a92b09c7c48c520c3c55e497875da437c">Right</a>) {</div><div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;    <span class="keywordflow">return</span> OffValPairs[<a class="code" href="namespacellvm.html#a2554a96c67bdd7d0a62855a844ec55b0a945d5e233cf7d6240f6b783b36a374ff">Left</a>].first &lt; OffValPairs[<a class="code" href="namespacellvm.html#a2554a96c67bdd7d0a62855a844ec55b0a92b09c7c48c520c3c55e497875da437c">Right</a>].first;</div><div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;  });</div><div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;</div><div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;  <span class="comment">// Check if the order is consecutive already.</span></div><div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacellvm.html#a0d10fe510ced2849a8074fe81e5d04ce">llvm::all_of</a>(SortedIndices, [&amp;SortedIndices](<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;        <span class="keywordflow">return</span> I == SortedIndices[<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>];</div><div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;      }))</div><div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;    SortedIndices.<a class="code" href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">clear</a>();</div><div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;</div><div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;}</div><div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;<span class="comment">/// Take the address space operand from the Load/Store instruction.</span></div><div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;<span class="comment">/// Returns -1 if this is not a valid Load/Store instruction.</span></div><div class="line"><a name="l01163"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#a1ae9014fe6a94e931a9568117ce24dcf"> 1163</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <a class="code" href="LoopAccessAnalysis_8cpp.html#a1ae9014fe6a94e931a9568117ce24dcf">getAddressSpaceOperand</a>(<a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *L = dyn_cast&lt;LoadInst&gt;(I))</div><div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;    <span class="keywordflow">return</span> L-&gt;getPointerAddressSpace();</div><div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *S = dyn_cast&lt;StoreInst&gt;(I))</div><div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;    <span class="keywordflow">return</span> S-&gt;getPointerAddressSpace();</div><div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;  <span class="keywordflow">return</span> -1;</div><div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;}</div><div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;<span class="comment">/// Returns true if the memory operations \p A and \p B are consecutive.</span></div><div class="line"><a name="l01172"></a><span class="lineno"><a class="line" href="namespacellvm.html#ab1b85be3cd0fffad1d76673016015e02"> 1172</a></span>&#160;<span class="comment"></span><span class="keywordtype">bool</span> <a class="code" href="namespacellvm.html#ab1b85be3cd0fffad1d76673016015e02">llvm::isConsecutiveAccess</a>(<a class="code" href="classllvm_1_1Value.html">Value</a> *A, <a class="code" href="classllvm_1_1Value.html">Value</a> *<a class="code" href="BuiltinGCs_8cpp.html#a7abf5fb4071cb25dbce06dfb5ee3c937">B</a>, <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL,</div><div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;                               <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE, <span class="keywordtype">bool</span> <a class="code" href="SelectionDAGISel_8cpp.html#abe05d8ada7c1d48c65399af261ed3d67">CheckType</a>) {</div><div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *PtrA = <a class="code" href="namespacellvm.html#aee44336886a06f3c1b8c35c701ba8316">getLoadStorePointerOperand</a>(A);</div><div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *PtrB = <a class="code" href="namespacellvm.html#aee44336886a06f3c1b8c35c701ba8316">getLoadStorePointerOperand</a>(B);</div><div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;  <span class="keywordtype">unsigned</span> ASA = <a class="code" href="LoopAccessAnalysis_8cpp.html#a1ae9014fe6a94e931a9568117ce24dcf">getAddressSpaceOperand</a>(A);</div><div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;  <span class="keywordtype">unsigned</span> ASB = <a class="code" href="LoopAccessAnalysis_8cpp.html#a1ae9014fe6a94e931a9568117ce24dcf">getAddressSpaceOperand</a>(B);</div><div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;</div><div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;  <span class="comment">// Check that the address spaces match and that the pointers are valid.</span></div><div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;  <span class="keywordflow">if</span> (!PtrA || !PtrB || (ASA != ASB))</div><div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;</div><div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;  <span class="comment">// Make sure that A and B are different pointers.</span></div><div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;  <span class="keywordflow">if</span> (PtrA == PtrB)</div><div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;</div><div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;  <span class="comment">// Make sure that A and B have the same type if required.</span></div><div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;  <span class="keywordflow">if</span> (CheckType &amp;&amp; PtrA-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>() != PtrB-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>())</div><div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;</div><div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;  <span class="keywordtype">unsigned</span> IdxWidth = DL.<a class="code" href="classllvm_1_1DataLayout.html#ac9e61b1a68b91217d3d10a61a1f0fbb9">getIndexSizeInBits</a>(ASA);</div><div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *Ty = cast&lt;PointerType&gt;(PtrA-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>())-&gt;getElementType();</div><div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;</div><div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;  <a class="code" href="classllvm_1_1APInt.html">APInt</a> OffsetA(IdxWidth, 0), OffsetB(IdxWidth, 0);</div><div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;  PtrA = PtrA-&gt;<a class="code" href="classllvm_1_1Value.html#ae7a4de5d3c7d0f2ba56e3933fb2007bf">stripAndAccumulateInBoundsConstantOffsets</a>(DL, OffsetA);</div><div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;  PtrB = PtrB-&gt;<a class="code" href="classllvm_1_1Value.html#ae7a4de5d3c7d0f2ba56e3933fb2007bf">stripAndAccumulateInBoundsConstantOffsets</a>(DL, OffsetB);</div><div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;</div><div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;  <span class="comment">// Retrieve the address space again as pointer stripping now tracks through</span></div><div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;  <span class="comment">// `addrspacecast`.</span></div><div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;  ASA = cast&lt;PointerType&gt;(PtrA-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>())-&gt;getAddressSpace();</div><div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;  ASB = cast&lt;PointerType&gt;(PtrB-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>())-&gt;getAddressSpace();</div><div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;  <span class="comment">// Check that the address spaces match and that the pointers are valid.</span></div><div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;  <span class="keywordflow">if</span> (ASA != ASB)</div><div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;</div><div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;  IdxWidth = DL.<a class="code" href="classllvm_1_1DataLayout.html#ac9e61b1a68b91217d3d10a61a1f0fbb9">getIndexSizeInBits</a>(ASA);</div><div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;  OffsetA = OffsetA.sextOrTrunc(IdxWidth);</div><div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;  OffsetB = OffsetB.<a class="code" href="classllvm_1_1APInt.html#a9b5fc98b47d44d1150d3610bdfab1430">sextOrTrunc</a>(IdxWidth);</div><div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;</div><div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;  <a class="code" href="classllvm_1_1APInt.html">APInt</a> <a class="code" href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a>(IdxWidth, DL.<a class="code" href="classllvm_1_1DataLayout.html#acfcd22eb38dbfe1acbf138754297437a">getTypeStoreSize</a>(Ty));</div><div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;</div><div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;  <span class="comment">//  OffsetDelta = OffsetB - OffsetA;</span></div><div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *OffsetSCEVA = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a2eb94d079d8416118f4aaed865ab05d7">getConstant</a>(OffsetA);</div><div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *OffsetSCEVB = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a2eb94d079d8416118f4aaed865ab05d7">getConstant</a>(OffsetB);</div><div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *OffsetDeltaSCEV = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a8bcb86d8d126d95b0dc05f09e8f3df96">getMinusSCEV</a>(OffsetSCEVB, OffsetSCEVA);</div><div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1APInt.html">APInt</a> &amp;OffsetDelta = cast&lt;SCEVConstant&gt;(OffsetDeltaSCEV)-&gt;getAPInt();</div><div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;</div><div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;  <span class="comment">// Check if they are based on the same pointer. That makes the offsets</span></div><div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;  <span class="comment">// sufficient.</span></div><div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;  <span class="keywordflow">if</span> (PtrA == PtrB)</div><div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;    <span class="keywordflow">return</span> OffsetDelta == <a class="code" href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a>;</div><div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;</div><div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;  <span class="comment">// Compute the necessary base pointer delta to have the necessary final delta</span></div><div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;  <span class="comment">// equal to the size.</span></div><div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;  <span class="comment">// BaseDelta = Size - OffsetDelta;</span></div><div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *SizeSCEV = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a2eb94d079d8416118f4aaed865ab05d7">getConstant</a>(<a class="code" href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a>);</div><div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *BaseDelta = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a8bcb86d8d126d95b0dc05f09e8f3df96">getMinusSCEV</a>(SizeSCEV, OffsetDeltaSCEV);</div><div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;</div><div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;  <span class="comment">// Otherwise compute the distance with SCEV between the base pointers.</span></div><div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *PtrSCEVA = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49">getSCEV</a>(PtrA);</div><div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *PtrSCEVB = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49">getSCEV</a>(PtrB);</div><div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *<a class="code" href="ErlangGCPrinter_8cpp.html#a74b474c0616ab55c1d9487f11fd31d26">X</a> = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a83f34da3409085dd69e2da4a7f85e0f7">getAddExpr</a>(PtrSCEVA, BaseDelta);</div><div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;  <span class="keywordflow">return</span> X == PtrSCEVB;</div><div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;}</div><div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;</div><div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;<a class="code" href="classllvm_1_1MemoryDepChecker.html#ac661dd363bcde8b1e9516390eff1c400">MemoryDepChecker::VectorizationSafetyStatus</a></div><div class="line"><a name="l01237"></a><span class="lineno"><a class="line" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#af7e624cd937996851e961d72cdca670d"> 1237</a></span>&#160;<a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#af7e624cd937996851e961d72cdca670d">MemoryDepChecker::Dependence::isSafeForVectorization</a>(<a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#ae336b0e8514b99a44e73c3e2494c3cea">DepType</a> <a class="code" href="classllvm_1_1Type.html">Type</a>) {</div><div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;  <span class="keywordflow">switch</span> (Type) {</div><div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;  <span class="keywordflow">case</span> NoDep:</div><div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;  <span class="keywordflow">case</span> Forward:</div><div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;  <span class="keywordflow">case</span> BackwardVectorizable:</div><div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;    <span class="keywordflow">return</span> VectorizationSafetyStatus::Safe;</div><div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;</div><div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;  <span class="keywordflow">case</span> <a class="code" href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>:</div><div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;    <span class="keywordflow">return</span> VectorizationSafetyStatus::PossiblySafeWithRtChecks;</div><div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;  <span class="keywordflow">case</span> ForwardButPreventsForwarding:</div><div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;  <span class="keywordflow">case</span> Backward:</div><div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;  <span class="keywordflow">case</span> BackwardVectorizableButPreventsForwarding:</div><div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;    <span class="keywordflow">return</span> VectorizationSafetyStatus::Unsafe;</div><div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;  }</div><div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;  <a class="code" href="Support_2ErrorHandling_8h.html#ace243f5c25697a1107cce46626b3dc94">llvm_unreachable</a>(<span class="stringliteral">&quot;unexpected DepType!&quot;</span>);</div><div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;}</div><div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;</div><div class="line"><a name="l01254"></a><span class="lineno"><a class="line" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a68f3caaf7ba7f284e0feb00ae907e4c2"> 1254</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a68f3caaf7ba7f284e0feb00ae907e4c2">MemoryDepChecker::Dependence::isBackward</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;  <span class="keywordflow">switch</span> (<a class="code" href="classllvm_1_1Type.html">Type</a>) {</div><div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;  <span class="keywordflow">case</span> NoDep:</div><div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;  <span class="keywordflow">case</span> Forward:</div><div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;  <span class="keywordflow">case</span> ForwardButPreventsForwarding:</div><div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;  <span class="keywordflow">case</span> <a class="code" href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>:</div><div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;</div><div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;  <span class="keywordflow">case</span> BackwardVectorizable:</div><div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;  <span class="keywordflow">case</span> Backward:</div><div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;  <span class="keywordflow">case</span> BackwardVectorizableButPreventsForwarding:</div><div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;  }</div><div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;  <a class="code" href="Support_2ErrorHandling_8h.html#ace243f5c25697a1107cce46626b3dc94">llvm_unreachable</a>(<span class="stringliteral">&quot;unexpected DepType!&quot;</span>);</div><div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;}</div><div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;</div><div class="line"><a name="l01270"></a><span class="lineno"><a class="line" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a4cbfae0900c7bc2adb637840e589ed4e"> 1270</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a4cbfae0900c7bc2adb637840e589ed4e">MemoryDepChecker::Dependence::isPossiblyBackward</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;  <span class="keywordflow">return</span> isBackward() || <a class="code" href="classllvm_1_1Type.html">Type</a> == <a class="code" href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>;</div><div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;}</div><div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;</div><div class="line"><a name="l01274"></a><span class="lineno"><a class="line" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a623aabb69f601ada6b290ac7d15e69a5"> 1274</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a623aabb69f601ada6b290ac7d15e69a5">MemoryDepChecker::Dependence::isForward</a>()<span class="keyword"> const </span>{</div><div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;  <span class="keywordflow">switch</span> (<a class="code" href="classllvm_1_1Type.html">Type</a>) {</div><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;  <span class="keywordflow">case</span> Forward:</div><div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;  <span class="keywordflow">case</span> ForwardButPreventsForwarding:</div><div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;</div><div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;  <span class="keywordflow">case</span> NoDep:</div><div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;  <span class="keywordflow">case</span> <a class="code" href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">Unknown</a>:</div><div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;  <span class="keywordflow">case</span> BackwardVectorizable:</div><div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;  <span class="keywordflow">case</span> Backward:</div><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;  <span class="keywordflow">case</span> BackwardVectorizableButPreventsForwarding:</div><div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;  }</div><div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;  <a class="code" href="Support_2ErrorHandling_8h.html#ace243f5c25697a1107cce46626b3dc94">llvm_unreachable</a>(<span class="stringliteral">&quot;unexpected DepType!&quot;</span>);</div><div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;}</div><div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;</div><div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;<span class="keywordtype">bool</span> MemoryDepChecker::couldPreventStoreLoadForward(uint64_t Distance,</div><div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;                                                    uint64_t TypeByteSize) {</div><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;  <span class="comment">// If loads occur at a distance that is not a multiple of a feasible vector</span></div><div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;  <span class="comment">// factor store-load forwarding does not take place.</span></div><div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;  <span class="comment">// Positive dependences might cause troubles because vectorizing them might</span></div><div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;  <span class="comment">// prevent store-load forwarding making vectorized code run a lot slower.</span></div><div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;  <span class="comment">//   a[i] = a[i-3] ^ a[i-8];</span></div><div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;  <span class="comment">//   The stores to a[i:i+1] don&#39;t align with the stores to a[i-3:i-2] and</span></div><div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;  <span class="comment">//   hence on your typical architecture store-load forwarding does not take</span></div><div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;  <span class="comment">//   place. Vectorizing in such cases does not make sense.</span></div><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;  <span class="comment">// Store-load forwarding distance.</span></div><div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;</div><div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;  <span class="comment">// After this many iterations store-to-load forwarding conflicts should not</span></div><div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;  <span class="comment">// cause any slowdowns.</span></div><div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;  <span class="keyword">const</span> uint64_t NumItersForStoreLoadThroughMemory = 8 * TypeByteSize;</div><div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;  <span class="comment">// Maximum vector factor.</span></div><div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;  uint64_t MaxVFWithoutSLForwardIssues = std::min(</div><div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;      VectorizerParams::MaxVectorWidth * TypeByteSize, MaxSafeDepDistBytes);</div><div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;</div><div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;  <span class="comment">// Compute the smallest VF at which the store and load would be misaligned.</span></div><div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;  <span class="keywordflow">for</span> (uint64_t VF = 2 * TypeByteSize; VF &lt;= MaxVFWithoutSLForwardIssues;</div><div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;       VF *= 2) {</div><div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;    <span class="comment">// If the number of vector iteration between the store and the load are</span></div><div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;    <span class="comment">// small we could incur conflicts.</span></div><div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;    <span class="keywordflow">if</span> (Distance % VF &amp;&amp; Distance / VF &lt; NumItersForStoreLoadThroughMemory) {</div><div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;      MaxVFWithoutSLForwardIssues = (VF &gt;&gt;= 1);</div><div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;      <span class="keywordflow">break</span>;</div><div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;    }</div><div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;  }</div><div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;</div><div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;  <span class="keywordflow">if</span> (MaxVFWithoutSLForwardIssues &lt; 2 * TypeByteSize) {</div><div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;        <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Distance &quot;</span> &lt;&lt; Distance</div><div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;               &lt;&lt; <span class="stringliteral">&quot; that could cause a store-load forwarding conflict\n&quot;</span>);</div><div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;  }</div><div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;</div><div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;  <span class="keywordflow">if</span> (MaxVFWithoutSLForwardIssues &lt; MaxSafeDepDistBytes &amp;&amp;</div><div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;      MaxVFWithoutSLForwardIssues !=</div><div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;          VectorizerParams::MaxVectorWidth * TypeByteSize)</div><div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;    MaxSafeDepDistBytes = MaxVFWithoutSLForwardIssues;</div><div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;}</div><div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;</div><div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;<span class="keywordtype">void</span> MemoryDepChecker::mergeInStatus(<a class="code" href="classllvm_1_1MemoryDepChecker.html#ac661dd363bcde8b1e9516390eff1c400">VectorizationSafetyStatus</a> S) {</div><div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="structStatus.html">Status</a> &lt; S)</div><div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;    <a class="code" href="structStatus.html">Status</a> = S;</div><div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;}</div><div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;<span class="comment">/// Given a non-constant (unknown) dependence-distance \p Dist between two</span></div><div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;<span class="comment">/// memory accesses, that have the same stride whose absolute value is given</span></div><div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;<span class="comment">/// in \p Stride, and that have the same type size \p TypeByteSize,</span></div><div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;<span class="comment">/// in a loop whose takenCount is \p BackedgeTakenCount, check if it is</span></div><div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;<span class="comment">/// possible to prove statically that the dependence distance is larger</span></div><div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;<span class="comment">/// than the range that the accesses will travel through the execution of</span></div><div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;<span class="comment">/// the loop. If so, return true; false otherwise. This is useful for</span></div><div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;<span class="comment">/// example in loops such as the following (PR31098):</span></div><div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;<span class="comment">///     for (i = 0; i &lt; D; ++i) {</span></div><div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;<span class="comment">///                = out[i];</span></div><div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;<span class="comment">///       out[i+D] =</span></div><div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;<span class="comment">///     }</span></div><div class="line"><a name="l01351"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#ab6cdd949c43218910fff41875a194e9f"> 1351</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="LoopAccessAnalysis_8cpp.html#ab6cdd949c43218910fff41875a194e9f">isSafeDependenceDistance</a>(<span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> &amp;SE,</div><div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;                                     <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> &amp;BackedgeTakenCount,</div><div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;                                     <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> &amp;Dist, uint64_t Stride,</div><div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;                                     uint64_t TypeByteSize) {</div><div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;</div><div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;  <span class="comment">// If we can prove that</span></div><div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;  <span class="comment">//      (**) |Dist| &gt; BackedgeTakenCount * Step</span></div><div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;  <span class="comment">// where Step is the absolute stride of the memory accesses in bytes,</span></div><div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;  <span class="comment">// then there is no dependence.</span></div><div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;  <span class="comment">// Rationale:</span></div><div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;  <span class="comment">// We basically want to check if the absolute distance (|Dist/Step|)</span></div><div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;  <span class="comment">// is &gt;= the loop iteration count (or &gt; BackedgeTakenCount).</span></div><div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;  <span class="comment">// This is equivalent to the Strong SIV Test (Practical Dependence Testing,</span></div><div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;  <span class="comment">// Section 4.2.1); Note, that for vectorization it is sufficient to prove</span></div><div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;  <span class="comment">// that the dependence distance is &gt;= VF; This is checked elsewhere.</span></div><div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;  <span class="comment">// But in some cases we can prune unknown dependence distances early, and</span></div><div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;  <span class="comment">// even before selecting the VF, and without a runtime test, by comparing</span></div><div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;  <span class="comment">// the distance against the loop iteration count. Since the vectorized code</span></div><div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;  <span class="comment">// will be executed only if LoopCount &gt;= VF, proving distance &gt;= LoopCount</span></div><div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;  <span class="comment">// also guarantees that distance &gt;= VF.</span></div><div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;  <span class="keyword">const</span> uint64_t ByteStride = Stride * TypeByteSize;</div><div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Step = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a2eb94d079d8416118f4aaed865ab05d7">getConstant</a>(BackedgeTakenCount.<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>(), ByteStride);</div><div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Product = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a805c8bc133a45fce61c32ee6c0ce01b9">getMulExpr</a>(&amp;BackedgeTakenCount, Step);</div><div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;</div><div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *CastedDist = &amp;Dist;</div><div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *CastedProduct = Product;</div><div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;  uint64_t DistTypeSize = DL.<a class="code" href="classllvm_1_1DataLayout.html#aa48b3b7e554b44f4e513d5dd8d9f9343">getTypeAllocSize</a>(Dist.<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>());</div><div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;  uint64_t ProductTypeSize = DL.<a class="code" href="classllvm_1_1DataLayout.html#aa48b3b7e554b44f4e513d5dd8d9f9343">getTypeAllocSize</a>(Product-&gt;<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>());</div><div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;</div><div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;  <span class="comment">// The dependence distance can be positive/negative, so we sign extend Dist;</span></div><div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;  <span class="comment">// The multiplication of the absolute stride in bytes and the</span></div><div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;  <span class="comment">// backedgeTakenCount is non-negative, so we zero extend Product.</span></div><div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;  <span class="keywordflow">if</span> (DistTypeSize &gt; ProductTypeSize)</div><div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;    CastedProduct = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a6d745b25efdc69435508f1e936919f8b">getZeroExtendExpr</a>(Product, Dist.<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>());</div><div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;    CastedDist = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a38c440751f1bf5f19bc12b95f8f0f2a6">getNoopOrSignExtend</a>(&amp;Dist, Product-&gt;<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>());</div><div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;</div><div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;  <span class="comment">// Is  Dist - (BackedgeTakenCount * Step) &gt; 0 ?</span></div><div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;  <span class="comment">// (If so, then we have proven (**) because |Dist| &gt;= Dist)</span></div><div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Minus = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a8bcb86d8d126d95b0dc05f09e8f3df96">getMinusSCEV</a>(CastedDist, CastedProduct);</div><div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;  <span class="keywordflow">if</span> (SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a5a672708a81ae8da8fb56e32638ca9b3">isKnownPositive</a>(Minus))</div><div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;</div><div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;  <span class="comment">// Second try: Is  -Dist - (BackedgeTakenCount * Step) &gt; 0 ?</span></div><div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;  <span class="comment">// (If so, then we have proven (**) because |Dist| &gt;= -1*Dist)</span></div><div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *NegDist = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a083bb1deb1d2ba244a99ceae9e734bc1">getNegativeSCEV</a>(CastedDist);</div><div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;  Minus = SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a8bcb86d8d126d95b0dc05f09e8f3df96">getMinusSCEV</a>(NegDist, CastedProduct);</div><div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;  <span class="keywordflow">if</span> (SE.<a class="code" href="classllvm_1_1ScalarEvolution.html#a5a672708a81ae8da8fb56e32638ca9b3">isKnownPositive</a>(Minus))</div><div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;</div><div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;}</div><div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;<span class="comment"></span></div><div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;<span class="comment">/// Check the dependence for two accesses with the same stride \p Stride.</span></div><div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;<span class="comment">/// \p Distance is the positive distance and \p TypeByteSize is type size in</span></div><div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;<span class="comment">/// bytes.</span></div><div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<span class="comment">///</span></div><div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;<span class="comment">/// \returns true if they are independent.</span></div><div class="line"><a name="l01411"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#abb0442118037e1a5cf98ecead9627a5e"> 1411</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="LoopAccessAnalysis_8cpp.html#abb0442118037e1a5cf98ecead9627a5e">areStridedAccessesIndependent</a>(uint64_t Distance, uint64_t Stride,</div><div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;                                          uint64_t TypeByteSize) {</div><div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(Stride &gt; 1 &amp;&amp; <span class="stringliteral">&quot;The stride must be greater than 1&quot;</span>);</div><div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(TypeByteSize &gt; 0 &amp;&amp; <span class="stringliteral">&quot;The type size in byte must be non-zero&quot;</span>);</div><div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(Distance &gt; 0 &amp;&amp; <span class="stringliteral">&quot;The distance must be non-zero&quot;</span>);</div><div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;</div><div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;  <span class="comment">// Skip if the distance is not multiple of type byte size.</span></div><div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;  <span class="keywordflow">if</span> (Distance % TypeByteSize)</div><div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;</div><div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;  uint64_t ScaledDist = Distance / TypeByteSize;</div><div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;</div><div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;  <span class="comment">// No dependence if the scaled distance is not multiple of the stride.</span></div><div class="line"><a name="l01424"></a><span class="lineno"> 1424</span>&#160;  <span class="comment">// E.g.</span></div><div class="line"><a name="l01425"></a><span class="lineno"> 1425</span>&#160;  <span class="comment">//      for (i = 0; i &lt; 1024 ; i += 4)</span></div><div class="line"><a name="l01426"></a><span class="lineno"> 1426</span>&#160;  <span class="comment">//        A[i+2] = A[i] + 1;</span></div><div class="line"><a name="l01427"></a><span class="lineno"> 1427</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01428"></a><span class="lineno"> 1428</span>&#160;  <span class="comment">// Two accesses in memory (scaled distance is 2, stride is 4):</span></div><div class="line"><a name="l01429"></a><span class="lineno"> 1429</span>&#160;  <span class="comment">//     | A[0] |      |      |      | A[4] |      |      |      |</span></div><div class="line"><a name="l01430"></a><span class="lineno"> 1430</span>&#160;  <span class="comment">//     |      |      | A[2] |      |      |      | A[6] |      |</span></div><div class="line"><a name="l01431"></a><span class="lineno"> 1431</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01432"></a><span class="lineno"> 1432</span>&#160;  <span class="comment">// E.g.</span></div><div class="line"><a name="l01433"></a><span class="lineno"> 1433</span>&#160;  <span class="comment">//      for (i = 0; i &lt; 1024 ; i += 3)</span></div><div class="line"><a name="l01434"></a><span class="lineno"> 1434</span>&#160;  <span class="comment">//        A[i+4] = A[i] + 1;</span></div><div class="line"><a name="l01435"></a><span class="lineno"> 1435</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01436"></a><span class="lineno"> 1436</span>&#160;  <span class="comment">// Two accesses in memory (scaled distance is 4, stride is 3):</span></div><div class="line"><a name="l01437"></a><span class="lineno"> 1437</span>&#160;  <span class="comment">//     | A[0] |      |      | A[3] |      |      | A[6] |      |      |</span></div><div class="line"><a name="l01438"></a><span class="lineno"> 1438</span>&#160;  <span class="comment">//     |      |      |      |      | A[4] |      |      | A[7] |      |</span></div><div class="line"><a name="l01439"></a><span class="lineno"> 1439</span>&#160;  <span class="keywordflow">return</span> ScaledDist % Stride;</div><div class="line"><a name="l01440"></a><span class="lineno"> 1440</span>&#160;}</div><div class="line"><a name="l01441"></a><span class="lineno"> 1441</span>&#160;</div><div class="line"><a name="l01442"></a><span class="lineno"> 1442</span>&#160;<a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#ae336b0e8514b99a44e73c3e2494c3cea">MemoryDepChecker::Dependence::DepType</a></div><div class="line"><a name="l01443"></a><span class="lineno"> 1443</span>&#160;MemoryDepChecker::isDependent(<span class="keyword">const</span> MemAccessInfo &amp;A, <span class="keywordtype">unsigned</span> AIdx,</div><div class="line"><a name="l01444"></a><span class="lineno"> 1444</span>&#160;                              <span class="keyword">const</span> MemAccessInfo &amp;<a class="code" href="BuiltinGCs_8cpp.html#a7abf5fb4071cb25dbce06dfb5ee3c937">B</a>, <span class="keywordtype">unsigned</span> BIdx,</div><div class="line"><a name="l01445"></a><span class="lineno"> 1445</span>&#160;                              <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;Strides) {</div><div class="line"><a name="l01446"></a><span class="lineno"> 1446</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a> (AIdx &lt; BIdx &amp;&amp; <span class="stringliteral">&quot;Must pass arguments in program order&quot;</span>);</div><div class="line"><a name="l01447"></a><span class="lineno"> 1447</span>&#160;</div><div class="line"><a name="l01448"></a><span class="lineno"> 1448</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *APtr = A.getPointer();</div><div class="line"><a name="l01449"></a><span class="lineno"> 1449</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *BPtr = B.getPointer();</div><div class="line"><a name="l01450"></a><span class="lineno"> 1450</span>&#160;  <span class="keywordtype">bool</span> AIsWrite = A.getInt();</div><div class="line"><a name="l01451"></a><span class="lineno"> 1451</span>&#160;  <span class="keywordtype">bool</span> BIsWrite = B.getInt();</div><div class="line"><a name="l01452"></a><span class="lineno"> 1452</span>&#160;</div><div class="line"><a name="l01453"></a><span class="lineno"> 1453</span>&#160;  <span class="comment">// Two reads are independent.</span></div><div class="line"><a name="l01454"></a><span class="lineno"> 1454</span>&#160;  <span class="keywordflow">if</span> (!AIsWrite &amp;&amp; !BIsWrite)</div><div class="line"><a name="l01455"></a><span class="lineno"> 1455</span>&#160;    <span class="keywordflow">return</span> Dependence::NoDep;</div><div class="line"><a name="l01456"></a><span class="lineno"> 1456</span>&#160;</div><div class="line"><a name="l01457"></a><span class="lineno"> 1457</span>&#160;  <span class="comment">// We cannot check pointers in different address spaces.</span></div><div class="line"><a name="l01458"></a><span class="lineno"> 1458</span>&#160;  <span class="keywordflow">if</span> (APtr-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a5ab2d0b0f0b8ceec3b907184e7567197">getPointerAddressSpace</a>() !=</div><div class="line"><a name="l01459"></a><span class="lineno"> 1459</span>&#160;      BPtr-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a5ab2d0b0f0b8ceec3b907184e7567197">getPointerAddressSpace</a>())</div><div class="line"><a name="l01460"></a><span class="lineno"> 1460</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">Dependence::Unknown</a>;</div><div class="line"><a name="l01461"></a><span class="lineno"> 1461</span>&#160;</div><div class="line"><a name="l01462"></a><span class="lineno"> 1462</span>&#160;  int64_t StrideAPtr = <a class="code" href="namespacellvm.html#ab7f1b8ad3b5b4cb2cb19c2291dcf3cf1">getPtrStride</a>(PSE, APtr, InnermostLoop, Strides, <span class="keyword">true</span>);</div><div class="line"><a name="l01463"></a><span class="lineno"> 1463</span>&#160;  int64_t StrideBPtr = <a class="code" href="namespacellvm.html#ab7f1b8ad3b5b4cb2cb19c2291dcf3cf1">getPtrStride</a>(PSE, BPtr, InnermostLoop, Strides, <span class="keyword">true</span>);</div><div class="line"><a name="l01464"></a><span class="lineno"> 1464</span>&#160;</div><div class="line"><a name="l01465"></a><span class="lineno"> 1465</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Src = PSE.getSCEV(APtr);</div><div class="line"><a name="l01466"></a><span class="lineno"> 1466</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *<a class="code" href="namespacellvm_1_1cl.html#ac96f30ba8b117dbd380b88ab8a03732ba1e82b710efc2f25cc275e53b3833e6fa">Sink</a> = PSE.getSCEV(BPtr);</div><div class="line"><a name="l01467"></a><span class="lineno"> 1467</span>&#160;</div><div class="line"><a name="l01468"></a><span class="lineno"> 1468</span>&#160;  <span class="comment">// If the induction step is negative we have to invert source and sink of the</span></div><div class="line"><a name="l01469"></a><span class="lineno"> 1469</span>&#160;  <span class="comment">// dependence.</span></div><div class="line"><a name="l01470"></a><span class="lineno"> 1470</span>&#160;  <span class="keywordflow">if</span> (StrideAPtr &lt; 0) {</div><div class="line"><a name="l01471"></a><span class="lineno"> 1471</span>&#160;    <a class="code" href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(APtr, BPtr);</div><div class="line"><a name="l01472"></a><span class="lineno"> 1472</span>&#160;    <a class="code" href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(Src, Sink);</div><div class="line"><a name="l01473"></a><span class="lineno"> 1473</span>&#160;    <a class="code" href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(AIsWrite, BIsWrite);</div><div class="line"><a name="l01474"></a><span class="lineno"> 1474</span>&#160;    <a class="code" href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(AIdx, BIdx);</div><div class="line"><a name="l01475"></a><span class="lineno"> 1475</span>&#160;    <a class="code" href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(StrideAPtr, StrideBPtr);</div><div class="line"><a name="l01476"></a><span class="lineno"> 1476</span>&#160;  }</div><div class="line"><a name="l01477"></a><span class="lineno"> 1477</span>&#160;</div><div class="line"><a name="l01478"></a><span class="lineno"> 1478</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Dist = PSE.getSE()-&gt;getMinusSCEV(Sink, Src);</div><div class="line"><a name="l01479"></a><span class="lineno"> 1479</span>&#160;</div><div class="line"><a name="l01480"></a><span class="lineno"> 1480</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Src Scev: &quot;</span> &lt;&lt; *Src &lt;&lt; <span class="stringliteral">&quot;Sink Scev: &quot;</span> &lt;&lt; *Sink</div><div class="line"><a name="l01481"></a><span class="lineno"> 1481</span>&#160;                    &lt;&lt; <span class="stringliteral">&quot;(Induction step: &quot;</span> &lt;&lt; StrideAPtr &lt;&lt; <span class="stringliteral">&quot;)\n&quot;</span>);</div><div class="line"><a name="l01482"></a><span class="lineno"> 1482</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Distance for &quot;</span> &lt;&lt; *InstMap[AIdx] &lt;&lt; <span class="stringliteral">&quot; to &quot;</span></div><div class="line"><a name="l01483"></a><span class="lineno"> 1483</span>&#160;                    &lt;&lt; *InstMap[BIdx] &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; *Dist &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01484"></a><span class="lineno"> 1484</span>&#160;</div><div class="line"><a name="l01485"></a><span class="lineno"> 1485</span>&#160;  <span class="comment">// Need accesses with constant stride. We don&#39;t want to vectorize</span></div><div class="line"><a name="l01486"></a><span class="lineno"> 1486</span>&#160;  <span class="comment">// &quot;A[B[i]] += ...&quot; and similar code or pointer arithmetic that could wrap in</span></div><div class="line"><a name="l01487"></a><span class="lineno"> 1487</span>&#160;  <span class="comment">// the address space.</span></div><div class="line"><a name="l01488"></a><span class="lineno"> 1488</span>&#160;  <span class="keywordflow">if</span> (!StrideAPtr || !StrideBPtr || StrideAPtr != StrideBPtr){</div><div class="line"><a name="l01489"></a><span class="lineno"> 1489</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;Pointer access with non-constant stride\n&quot;</span>);</div><div class="line"><a name="l01490"></a><span class="lineno"> 1490</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">Dependence::Unknown</a>;</div><div class="line"><a name="l01491"></a><span class="lineno"> 1491</span>&#160;  }</div><div class="line"><a name="l01492"></a><span class="lineno"> 1492</span>&#160;</div><div class="line"><a name="l01493"></a><span class="lineno"> 1493</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *ATy = APtr-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#ae61f17d62c8a79bc5cffa63a2f152311">getPointerElementType</a>();</div><div class="line"><a name="l01494"></a><span class="lineno"> 1494</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *BTy = BPtr-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#ae61f17d62c8a79bc5cffa63a2f152311">getPointerElementType</a>();</div><div class="line"><a name="l01495"></a><span class="lineno"> 1495</span>&#160;  <span class="keyword">auto</span> &amp;DL = InnermostLoop-&gt;getHeader()-&gt;getModule()-&gt;getDataLayout();</div><div class="line"><a name="l01496"></a><span class="lineno"> 1496</span>&#160;  uint64_t TypeByteSize = DL.getTypeAllocSize(ATy);</div><div class="line"><a name="l01497"></a><span class="lineno"> 1497</span>&#160;  uint64_t Stride = <a class="code" href="namespacellvm.html#a2816e84a08c108d18bc4665bc1817e01">std::abs</a>(StrideAPtr);</div><div class="line"><a name="l01498"></a><span class="lineno"> 1498</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEVConstant.html">SCEVConstant</a> *<a class="code" href="NVVMIntrRange_8cpp.html#a2ae53ee71b2ccbb52b883c0b4f59f8c2">C</a> = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1SCEVConstant.html">SCEVConstant</a>&gt;(Dist);</div><div class="line"><a name="l01499"></a><span class="lineno"> 1499</span>&#160;  <span class="keywordflow">if</span> (!C) {</div><div class="line"><a name="l01500"></a><span class="lineno"> 1500</span>&#160;    <span class="keywordflow">if</span> (TypeByteSize == DL.getTypeAllocSize(BTy) &amp;&amp;</div><div class="line"><a name="l01501"></a><span class="lineno"> 1501</span>&#160;        <a class="code" href="LoopAccessAnalysis_8cpp.html#ab6cdd949c43218910fff41875a194e9f">isSafeDependenceDistance</a>(DL, *(PSE.getSE()),</div><div class="line"><a name="l01502"></a><span class="lineno"> 1502</span>&#160;                                 *(PSE.getBackedgeTakenCount()), *Dist, Stride,</div><div class="line"><a name="l01503"></a><span class="lineno"> 1503</span>&#160;                                 TypeByteSize))</div><div class="line"><a name="l01504"></a><span class="lineno"> 1504</span>&#160;      <span class="keywordflow">return</span> Dependence::NoDep;</div><div class="line"><a name="l01505"></a><span class="lineno"> 1505</span>&#160;</div><div class="line"><a name="l01506"></a><span class="lineno"> 1506</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Dependence because of non-constant distance\n&quot;</span>);</div><div class="line"><a name="l01507"></a><span class="lineno"> 1507</span>&#160;    FoundNonConstantDistanceDependence = <span class="keyword">true</span>;</div><div class="line"><a name="l01508"></a><span class="lineno"> 1508</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">Dependence::Unknown</a>;</div><div class="line"><a name="l01509"></a><span class="lineno"> 1509</span>&#160;  }</div><div class="line"><a name="l01510"></a><span class="lineno"> 1510</span>&#160;</div><div class="line"><a name="l01511"></a><span class="lineno"> 1511</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1APInt.html">APInt</a> &amp;Val = C-&gt;<a class="code" href="classllvm_1_1SCEVConstant.html#a17304ab072a5b259c03e766a2b78a30b">getAPInt</a>();</div><div class="line"><a name="l01512"></a><span class="lineno"> 1512</span>&#160;  int64_t Distance = Val.<a class="code" href="classllvm_1_1APInt.html#af2daa0ee117afefed4c82eee55bf97b7">getSExtValue</a>();</div><div class="line"><a name="l01513"></a><span class="lineno"> 1513</span>&#160;</div><div class="line"><a name="l01514"></a><span class="lineno"> 1514</span>&#160;  <span class="comment">// Attempt to prove strided accesses independent.</span></div><div class="line"><a name="l01515"></a><span class="lineno"> 1515</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="namespacellvm.html#a2816e84a08c108d18bc4665bc1817e01">std::abs</a>(Distance) &gt; 0 &amp;&amp; Stride &gt; 1 &amp;&amp; ATy == BTy &amp;&amp;</div><div class="line"><a name="l01516"></a><span class="lineno"> 1516</span>&#160;      <a class="code" href="LoopAccessAnalysis_8cpp.html#abb0442118037e1a5cf98ecead9627a5e">areStridedAccessesIndependent</a>(<a class="code" href="namespacellvm.html#a2816e84a08c108d18bc4665bc1817e01">std::abs</a>(Distance), Stride, TypeByteSize)) {</div><div class="line"><a name="l01517"></a><span class="lineno"> 1517</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Strided accesses are independent\n&quot;</span>);</div><div class="line"><a name="l01518"></a><span class="lineno"> 1518</span>&#160;    <span class="keywordflow">return</span> Dependence::NoDep;</div><div class="line"><a name="l01519"></a><span class="lineno"> 1519</span>&#160;  }</div><div class="line"><a name="l01520"></a><span class="lineno"> 1520</span>&#160;</div><div class="line"><a name="l01521"></a><span class="lineno"> 1521</span>&#160;  <span class="comment">// Negative distances are not plausible dependencies.</span></div><div class="line"><a name="l01522"></a><span class="lineno"> 1522</span>&#160;  <span class="keywordflow">if</span> (Val.<a class="code" href="classllvm_1_1APInt.html#a6804d9caf15411f55e7b9e9f397f0422">isNegative</a>()) {</div><div class="line"><a name="l01523"></a><span class="lineno"> 1523</span>&#160;    <span class="keywordtype">bool</span> IsTrueDataDependence = (AIsWrite &amp;&amp; !BIsWrite);</div><div class="line"><a name="l01524"></a><span class="lineno"> 1524</span>&#160;    <span class="keywordflow">if</span> (IsTrueDataDependence &amp;&amp; <a class="code" href="LoopAccessAnalysis_8cpp.html#aca99374d317f84dc3b73915b7f2e955c">EnableForwardingConflictDetection</a> &amp;&amp;</div><div class="line"><a name="l01525"></a><span class="lineno"> 1525</span>&#160;        (couldPreventStoreLoadForward(Val.<a class="code" href="classllvm_1_1APInt.html#a38e964f0cadf077725453884734a6c99">abs</a>().<a class="code" href="classllvm_1_1APInt.html#a217e0207d9cc8e046c2dccbf0e4bb198">getZExtValue</a>(), TypeByteSize) ||</div><div class="line"><a name="l01526"></a><span class="lineno"> 1526</span>&#160;         ATy != BTy)) {</div><div class="line"><a name="l01527"></a><span class="lineno"> 1527</span>&#160;      <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Forward but may prevent st-&gt;ld forwarding\n&quot;</span>);</div><div class="line"><a name="l01528"></a><span class="lineno"> 1528</span>&#160;      <span class="keywordflow">return</span> Dependence::ForwardButPreventsForwarding;</div><div class="line"><a name="l01529"></a><span class="lineno"> 1529</span>&#160;    }</div><div class="line"><a name="l01530"></a><span class="lineno"> 1530</span>&#160;</div><div class="line"><a name="l01531"></a><span class="lineno"> 1531</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Dependence is negative\n&quot;</span>);</div><div class="line"><a name="l01532"></a><span class="lineno"> 1532</span>&#160;    <span class="keywordflow">return</span> Dependence::Forward;</div><div class="line"><a name="l01533"></a><span class="lineno"> 1533</span>&#160;  }</div><div class="line"><a name="l01534"></a><span class="lineno"> 1534</span>&#160;</div><div class="line"><a name="l01535"></a><span class="lineno"> 1535</span>&#160;  <span class="comment">// Write to the same location with the same size.</span></div><div class="line"><a name="l01536"></a><span class="lineno"> 1536</span>&#160;  <span class="comment">// Could be improved to assert type sizes are the same (i32 == float, etc).</span></div><div class="line"><a name="l01537"></a><span class="lineno"> 1537</span>&#160;  <span class="keywordflow">if</span> (Val == 0) {</div><div class="line"><a name="l01538"></a><span class="lineno"> 1538</span>&#160;    <span class="keywordflow">if</span> (ATy == BTy)</div><div class="line"><a name="l01539"></a><span class="lineno"> 1539</span>&#160;      <span class="keywordflow">return</span> Dependence::Forward;</div><div class="line"><a name="l01540"></a><span class="lineno"> 1540</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l01541"></a><span class="lineno"> 1541</span>&#160;        <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Zero dependence difference but different types\n&quot;</span>);</div><div class="line"><a name="l01542"></a><span class="lineno"> 1542</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">Dependence::Unknown</a>;</div><div class="line"><a name="l01543"></a><span class="lineno"> 1543</span>&#160;  }</div><div class="line"><a name="l01544"></a><span class="lineno"> 1544</span>&#160;</div><div class="line"><a name="l01545"></a><span class="lineno"> 1545</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(Val.<a class="code" href="classllvm_1_1APInt.html#aa17c104fbda554c818cf87e53f32f20a">isStrictlyPositive</a>() &amp;&amp; <span class="stringliteral">&quot;Expect a positive value&quot;</span>);</div><div class="line"><a name="l01546"></a><span class="lineno"> 1546</span>&#160;</div><div class="line"><a name="l01547"></a><span class="lineno"> 1547</span>&#160;  <span class="keywordflow">if</span> (ATy != BTy) {</div><div class="line"><a name="l01548"></a><span class="lineno"> 1548</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l01549"></a><span class="lineno"> 1549</span>&#160;        <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>()</div><div class="line"><a name="l01550"></a><span class="lineno"> 1550</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;LAA: ReadWrite-Write positive dependency with different types\n&quot;</span>);</div><div class="line"><a name="l01551"></a><span class="lineno"> 1551</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">Dependence::Unknown</a>;</div><div class="line"><a name="l01552"></a><span class="lineno"> 1552</span>&#160;  }</div><div class="line"><a name="l01553"></a><span class="lineno"> 1553</span>&#160;</div><div class="line"><a name="l01554"></a><span class="lineno"> 1554</span>&#160;  <span class="comment">// Bail out early if passed-in parameters make vectorization not feasible.</span></div><div class="line"><a name="l01555"></a><span class="lineno"> 1555</span>&#160;  <span class="keywordtype">unsigned</span> ForcedFactor = (VectorizerParams::VectorizationFactor ?</div><div class="line"><a name="l01556"></a><span class="lineno"> 1556</span>&#160;                           <a class="code" href="structllvm_1_1VectorizerParams.html#a22854382d27cb43d471731779195e9a8">VectorizerParams::VectorizationFactor</a> : 1);</div><div class="line"><a name="l01557"></a><span class="lineno"> 1557</span>&#160;  <span class="keywordtype">unsigned</span> ForcedUnroll = (VectorizerParams::VectorizationInterleave ?</div><div class="line"><a name="l01558"></a><span class="lineno"> 1558</span>&#160;                           <a class="code" href="structllvm_1_1VectorizerParams.html#a6a8f6b7564d1df823a8d8e8dcecf6802">VectorizerParams::VectorizationInterleave</a> : 1);</div><div class="line"><a name="l01559"></a><span class="lineno"> 1559</span>&#160;  <span class="comment">// The minimum number of iterations for a vectorized/unrolled version.</span></div><div class="line"><a name="l01560"></a><span class="lineno"> 1560</span>&#160;  <span class="keywordtype">unsigned</span> MinNumIter = <a class="code" href="namespacellvm.html#a81b52e18d84e3cc61df7e897bba1b259">std::max</a>(ForcedFactor * ForcedUnroll, 2U);</div><div class="line"><a name="l01561"></a><span class="lineno"> 1561</span>&#160;</div><div class="line"><a name="l01562"></a><span class="lineno"> 1562</span>&#160;  <span class="comment">// It&#39;s not vectorizable if the distance is smaller than the minimum distance</span></div><div class="line"><a name="l01563"></a><span class="lineno"> 1563</span>&#160;  <span class="comment">// needed for a vectroized/unrolled version. Vectorizing one iteration in</span></div><div class="line"><a name="l01564"></a><span class="lineno"> 1564</span>&#160;  <span class="comment">// front needs TypeByteSize * Stride. Vectorizing the last iteration needs</span></div><div class="line"><a name="l01565"></a><span class="lineno"> 1565</span>&#160;  <span class="comment">// TypeByteSize (No need to plus the last gap distance).</span></div><div class="line"><a name="l01566"></a><span class="lineno"> 1566</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01567"></a><span class="lineno"> 1567</span>&#160;  <span class="comment">// E.g. Assume one char is 1 byte in memory and one int is 4 bytes.</span></div><div class="line"><a name="l01568"></a><span class="lineno"> 1568</span>&#160;  <span class="comment">//      foo(int *A) {</span></div><div class="line"><a name="l01569"></a><span class="lineno"> 1569</span>&#160;  <span class="comment">//        int *B = (int *)((char *)A + 14);</span></div><div class="line"><a name="l01570"></a><span class="lineno"> 1570</span>&#160;  <span class="comment">//        for (i = 0 ; i &lt; 1024 ; i += 2)</span></div><div class="line"><a name="l01571"></a><span class="lineno"> 1571</span>&#160;  <span class="comment">//          B[i] = A[i] + 1;</span></div><div class="line"><a name="l01572"></a><span class="lineno"> 1572</span>&#160;  <span class="comment">//      }</span></div><div class="line"><a name="l01573"></a><span class="lineno"> 1573</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01574"></a><span class="lineno"> 1574</span>&#160;  <span class="comment">// Two accesses in memory (stride is 2):</span></div><div class="line"><a name="l01575"></a><span class="lineno"> 1575</span>&#160;  <span class="comment">//     | A[0] |      | A[2] |      | A[4] |      | A[6] |      |</span></div><div class="line"><a name="l01576"></a><span class="lineno"> 1576</span>&#160;  <span class="comment">//                              | B[0] |      | B[2] |      | B[4] |</span></div><div class="line"><a name="l01577"></a><span class="lineno"> 1577</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01578"></a><span class="lineno"> 1578</span>&#160;  <span class="comment">// Distance needs for vectorizing iterations except the last iteration:</span></div><div class="line"><a name="l01579"></a><span class="lineno"> 1579</span>&#160;  <span class="comment">// 4 * 2 * (MinNumIter - 1). Distance needs for the last iteration: 4.</span></div><div class="line"><a name="l01580"></a><span class="lineno"> 1580</span>&#160;  <span class="comment">// So the minimum distance needed is: 4 * 2 * (MinNumIter - 1) + 4.</span></div><div class="line"><a name="l01581"></a><span class="lineno"> 1581</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01582"></a><span class="lineno"> 1582</span>&#160;  <span class="comment">// If MinNumIter is 2, it is vectorizable as the minimum distance needed is</span></div><div class="line"><a name="l01583"></a><span class="lineno"> 1583</span>&#160;  <span class="comment">// 12, which is less than distance.</span></div><div class="line"><a name="l01584"></a><span class="lineno"> 1584</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01585"></a><span class="lineno"> 1585</span>&#160;  <span class="comment">// If MinNumIter is 4 (Say if a user forces the vectorization factor to be 4),</span></div><div class="line"><a name="l01586"></a><span class="lineno"> 1586</span>&#160;  <span class="comment">// the minimum distance needed is 28, which is greater than distance. It is</span></div><div class="line"><a name="l01587"></a><span class="lineno"> 1587</span>&#160;  <span class="comment">// not safe to do vectorization.</span></div><div class="line"><a name="l01588"></a><span class="lineno"> 1588</span>&#160;  uint64_t MinDistanceNeeded =</div><div class="line"><a name="l01589"></a><span class="lineno"> 1589</span>&#160;      TypeByteSize * Stride * (MinNumIter - 1) + TypeByteSize;</div><div class="line"><a name="l01590"></a><span class="lineno"> 1590</span>&#160;  <span class="keywordflow">if</span> (MinDistanceNeeded &gt; static_cast&lt;uint64_t&gt;(Distance)) {</div><div class="line"><a name="l01591"></a><span class="lineno"> 1591</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Failure because of positive distance &quot;</span></div><div class="line"><a name="l01592"></a><span class="lineno"> 1592</span>&#160;                      &lt;&lt; Distance &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>);</div><div class="line"><a name="l01593"></a><span class="lineno"> 1593</span>&#160;    <span class="keywordflow">return</span> Dependence::Backward;</div><div class="line"><a name="l01594"></a><span class="lineno"> 1594</span>&#160;  }</div><div class="line"><a name="l01595"></a><span class="lineno"> 1595</span>&#160;</div><div class="line"><a name="l01596"></a><span class="lineno"> 1596</span>&#160;  <span class="comment">// Unsafe if the minimum distance needed is greater than max safe distance.</span></div><div class="line"><a name="l01597"></a><span class="lineno"> 1597</span>&#160;  <span class="keywordflow">if</span> (MinDistanceNeeded &gt; MaxSafeDepDistBytes) {</div><div class="line"><a name="l01598"></a><span class="lineno"> 1598</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Failure because it needs at least &quot;</span></div><div class="line"><a name="l01599"></a><span class="lineno"> 1599</span>&#160;                      &lt;&lt; MinDistanceNeeded &lt;&lt; <span class="stringliteral">&quot; size in bytes&quot;</span>);</div><div class="line"><a name="l01600"></a><span class="lineno"> 1600</span>&#160;    <span class="keywordflow">return</span> Dependence::Backward;</div><div class="line"><a name="l01601"></a><span class="lineno"> 1601</span>&#160;  }</div><div class="line"><a name="l01602"></a><span class="lineno"> 1602</span>&#160;</div><div class="line"><a name="l01603"></a><span class="lineno"> 1603</span>&#160;  <span class="comment">// Positive distance bigger than max vectorization factor.</span></div><div class="line"><a name="l01604"></a><span class="lineno"> 1604</span>&#160;  <span class="comment">// FIXME: Should use max factor instead of max distance in bytes, which could</span></div><div class="line"><a name="l01605"></a><span class="lineno"> 1605</span>&#160;  <span class="comment">// not handle different types.</span></div><div class="line"><a name="l01606"></a><span class="lineno"> 1606</span>&#160;  <span class="comment">// E.g. Assume one char is 1 byte in memory and one int is 4 bytes.</span></div><div class="line"><a name="l01607"></a><span class="lineno"> 1607</span>&#160;  <span class="comment">//      void foo (int *A, char *B) {</span></div><div class="line"><a name="l01608"></a><span class="lineno"> 1608</span>&#160;  <span class="comment">//        for (unsigned i = 0; i &lt; 1024; i++) {</span></div><div class="line"><a name="l01609"></a><span class="lineno"> 1609</span>&#160;  <span class="comment">//          A[i+2] = A[i] + 1;</span></div><div class="line"><a name="l01610"></a><span class="lineno"> 1610</span>&#160;  <span class="comment">//          B[i+2] = B[i] + 1;</span></div><div class="line"><a name="l01611"></a><span class="lineno"> 1611</span>&#160;  <span class="comment">//        }</span></div><div class="line"><a name="l01612"></a><span class="lineno"> 1612</span>&#160;  <span class="comment">//      }</span></div><div class="line"><a name="l01613"></a><span class="lineno"> 1613</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l01614"></a><span class="lineno"> 1614</span>&#160;  <span class="comment">// This case is currently unsafe according to the max safe distance. If we</span></div><div class="line"><a name="l01615"></a><span class="lineno"> 1615</span>&#160;  <span class="comment">// analyze the two accesses on array B, the max safe dependence distance</span></div><div class="line"><a name="l01616"></a><span class="lineno"> 1616</span>&#160;  <span class="comment">// is 2. Then we analyze the accesses on array A, the minimum distance needed</span></div><div class="line"><a name="l01617"></a><span class="lineno"> 1617</span>&#160;  <span class="comment">// is 8, which is less than 2 and forbidden vectorization, But actually</span></div><div class="line"><a name="l01618"></a><span class="lineno"> 1618</span>&#160;  <span class="comment">// both A and B could be vectorized by 2 iterations.</span></div><div class="line"><a name="l01619"></a><span class="lineno"> 1619</span>&#160;  MaxSafeDepDistBytes =</div><div class="line"><a name="l01620"></a><span class="lineno"> 1620</span>&#160;      std::min(static_cast&lt;uint64_t&gt;(Distance), MaxSafeDepDistBytes);</div><div class="line"><a name="l01621"></a><span class="lineno"> 1621</span>&#160;</div><div class="line"><a name="l01622"></a><span class="lineno"> 1622</span>&#160;  <span class="keywordtype">bool</span> IsTrueDataDependence = (!AIsWrite &amp;&amp; BIsWrite);</div><div class="line"><a name="l01623"></a><span class="lineno"> 1623</span>&#160;  <span class="keywordflow">if</span> (IsTrueDataDependence &amp;&amp; <a class="code" href="LoopAccessAnalysis_8cpp.html#aca99374d317f84dc3b73915b7f2e955c">EnableForwardingConflictDetection</a> &amp;&amp;</div><div class="line"><a name="l01624"></a><span class="lineno"> 1624</span>&#160;      couldPreventStoreLoadForward(Distance, TypeByteSize))</div><div class="line"><a name="l01625"></a><span class="lineno"> 1625</span>&#160;    <span class="keywordflow">return</span> Dependence::BackwardVectorizableButPreventsForwarding;</div><div class="line"><a name="l01626"></a><span class="lineno"> 1626</span>&#160;</div><div class="line"><a name="l01627"></a><span class="lineno"> 1627</span>&#160;  uint64_t MaxVF = MaxSafeDepDistBytes / (TypeByteSize * Stride);</div><div class="line"><a name="l01628"></a><span class="lineno"> 1628</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Positive distance &quot;</span> &lt;&lt; Val.<a class="code" href="classllvm_1_1APInt.html#af2daa0ee117afefed4c82eee55bf97b7">getSExtValue</a>()</div><div class="line"><a name="l01629"></a><span class="lineno"> 1629</span>&#160;                    &lt;&lt; <span class="stringliteral">&quot; with max VF = &quot;</span> &lt;&lt; MaxVF &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>);</div><div class="line"><a name="l01630"></a><span class="lineno"> 1630</span>&#160;  uint64_t MaxVFInBits = MaxVF * TypeByteSize * 8;</div><div class="line"><a name="l01631"></a><span class="lineno"> 1631</span>&#160;  MaxSafeRegisterWidth = std::min(MaxSafeRegisterWidth, MaxVFInBits);</div><div class="line"><a name="l01632"></a><span class="lineno"> 1632</span>&#160;  <span class="keywordflow">return</span> Dependence::BackwardVectorizable;</div><div class="line"><a name="l01633"></a><span class="lineno"> 1633</span>&#160;}</div><div class="line"><a name="l01634"></a><span class="lineno"> 1634</span>&#160;</div><div class="line"><a name="l01635"></a><span class="lineno"><a class="line" href="classllvm_1_1MemoryDepChecker.html#acf3e8a08219f76d58762836fe99d4bec"> 1635</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1MemoryDepChecker.html#acf3e8a08219f76d58762836fe99d4bec">MemoryDepChecker::areDepsSafe</a>(<a class="code" href="classllvm_1_1EquivalenceClasses.html">DepCandidates</a> &amp;AccessSets,</div><div class="line"><a name="l01636"></a><span class="lineno"> 1636</span>&#160;                                   <a class="code" href="classllvm_1_1SmallVector.html">MemAccessInfoList</a> &amp;CheckDeps,</div><div class="line"><a name="l01637"></a><span class="lineno"> 1637</span>&#160;                                   <span class="keyword">const</span> <a class="code" href="classllvm_1_1DenseMap.html">ValueToValueMap</a> &amp;Strides) {</div><div class="line"><a name="l01638"></a><span class="lineno"> 1638</span>&#160;</div><div class="line"><a name="l01639"></a><span class="lineno"> 1639</span>&#160;  MaxSafeDepDistBytes = -1;</div><div class="line"><a name="l01640"></a><span class="lineno"> 1640</span>&#160;  <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;MemAccessInfo, 8&gt;</a> Visited;</div><div class="line"><a name="l01641"></a><span class="lineno"> 1641</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1PointerIntPair.html">MemAccessInfo</a> CurAccess : CheckDeps) {</div><div class="line"><a name="l01642"></a><span class="lineno"> 1642</span>&#160;    <span class="keywordflow">if</span> (Visited.<a class="code" href="classllvm_1_1SmallPtrSetImpl.html#a1f475b0df44ebd7169e720fa1bf9169e">count</a>(CurAccess))</div><div class="line"><a name="l01643"></a><span class="lineno"> 1643</span>&#160;      <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01644"></a><span class="lineno"> 1644</span>&#160;</div><div class="line"><a name="l01645"></a><span class="lineno"> 1645</span>&#160;    <span class="comment">// Get the relevant memory access set.</span></div><div class="line"><a name="l01646"></a><span class="lineno"> 1646</span>&#160;    <a class="code" href="classllvm_1_1EquivalenceClasses.html#ada7b2430928f6c94a0410f394c7d692b">EquivalenceClasses&lt;MemAccessInfo&gt;::iterator</a> <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> =</div><div class="line"><a name="l01647"></a><span class="lineno"> 1647</span>&#160;      AccessSets.<a class="code" href="classllvm_1_1EquivalenceClasses.html#a1445a41f4405069e553c6a91ab7d6df0">findValue</a>(AccessSets.<a class="code" href="classllvm_1_1EquivalenceClasses.html#a72c29f11de2d94ba0589624b00fac90a">getLeaderValue</a>(CurAccess));</div><div class="line"><a name="l01648"></a><span class="lineno"> 1648</span>&#160;</div><div class="line"><a name="l01649"></a><span class="lineno"> 1649</span>&#160;    <span class="comment">// Check accesses within this set.</span></div><div class="line"><a name="l01650"></a><span class="lineno"> 1650</span>&#160;    <a class="code" href="classllvm_1_1EquivalenceClasses_1_1member__iterator.html">EquivalenceClasses&lt;MemAccessInfo&gt;::member_iterator</a> AI =</div><div class="line"><a name="l01651"></a><span class="lineno"> 1651</span>&#160;        AccessSets.<a class="code" href="classllvm_1_1EquivalenceClasses.html#afa7f2c45050e420ca2c11e339d869c20">member_begin</a>(I);</div><div class="line"><a name="l01652"></a><span class="lineno"> 1652</span>&#160;    <a class="code" href="classllvm_1_1EquivalenceClasses_1_1member__iterator.html">EquivalenceClasses&lt;MemAccessInfo&gt;::member_iterator</a> AE =</div><div class="line"><a name="l01653"></a><span class="lineno"> 1653</span>&#160;        AccessSets.<a class="code" href="classllvm_1_1EquivalenceClasses.html#a82ecd46540fecf164bcea31530a1bd02">member_end</a>();</div><div class="line"><a name="l01654"></a><span class="lineno"> 1654</span>&#160;</div><div class="line"><a name="l01655"></a><span class="lineno"> 1655</span>&#160;    <span class="comment">// Check every access pair.</span></div><div class="line"><a name="l01656"></a><span class="lineno"> 1656</span>&#160;    <span class="keywordflow">while</span> (AI != AE) {</div><div class="line"><a name="l01657"></a><span class="lineno"> 1657</span>&#160;      Visited.<a class="code" href="classllvm_1_1SmallPtrSetImpl.html#a6bc6fb89fe2e91c25559a8631f56e27e">insert</a>(*AI);</div><div class="line"><a name="l01658"></a><span class="lineno"> 1658</span>&#160;      <span class="keywordtype">bool</span> AIIsWrite = AI-&gt;getInt();</div><div class="line"><a name="l01659"></a><span class="lineno"> 1659</span>&#160;      <span class="comment">// Check loads only against next equivalent class, but stores also against</span></div><div class="line"><a name="l01660"></a><span class="lineno"> 1660</span>&#160;      <span class="comment">// other stores in the same equivalence class - to the same address.</span></div><div class="line"><a name="l01661"></a><span class="lineno"> 1661</span>&#160;      <a class="code" href="classllvm_1_1EquivalenceClasses_1_1member__iterator.html">EquivalenceClasses&lt;MemAccessInfo&gt;::member_iterator</a> OI =</div><div class="line"><a name="l01662"></a><span class="lineno"> 1662</span>&#160;          (AIIsWrite ? AI : std::next(AI));</div><div class="line"><a name="l01663"></a><span class="lineno"> 1663</span>&#160;      <span class="keywordflow">while</span> (OI != AE) {</div><div class="line"><a name="l01664"></a><span class="lineno"> 1664</span>&#160;        <span class="comment">// Check every accessing instruction pair in program order.</span></div><div class="line"><a name="l01665"></a><span class="lineno"> 1665</span>&#160;        <span class="keywordflow">for</span> (std::vector&lt;unsigned&gt;::iterator I1 = Accesses[*AI].<a class="code" href="namespacellvm_1_1sys_1_1path.html#a00a76a729b319dc47beffbe07325565f">begin</a>(),</div><div class="line"><a name="l01666"></a><span class="lineno"> 1666</span>&#160;             I1E = Accesses[*AI].<a class="code" href="classllvm_1_1sys_1_1path_1_1const__iterator.html#a8a503d1cbee10d1b8c8f5ac2a03b90df">end</a>(); I1 != I1E; ++I1)</div><div class="line"><a name="l01667"></a><span class="lineno"> 1667</span>&#160;          <span class="comment">// Scan all accesses of another equivalence class, but only the next</span></div><div class="line"><a name="l01668"></a><span class="lineno"> 1668</span>&#160;          <span class="comment">// accesses of the same equivalent class.</span></div><div class="line"><a name="l01669"></a><span class="lineno"> 1669</span>&#160;          <span class="keywordflow">for</span> (std::vector&lt;unsigned&gt;::iterator</div><div class="line"><a name="l01670"></a><span class="lineno"> 1670</span>&#160;                   I2 = (OI == AI ? std::next(I1) : Accesses[*OI].<a class="code" href="namespacellvm_1_1sys_1_1path.html#a00a76a729b319dc47beffbe07325565f">begin</a>()),</div><div class="line"><a name="l01671"></a><span class="lineno"> 1671</span>&#160;                   I2E = (OI == AI ? I1E : Accesses[*OI].end());</div><div class="line"><a name="l01672"></a><span class="lineno"> 1672</span>&#160;               I2 != I2E; ++I2) {</div><div class="line"><a name="l01673"></a><span class="lineno"> 1673</span>&#160;            <span class="keyword">auto</span> A = std::make_pair(&amp;*AI, *I1);</div><div class="line"><a name="l01674"></a><span class="lineno"> 1674</span>&#160;            <span class="keyword">auto</span> B = std::make_pair(&amp;*OI, *I2);</div><div class="line"><a name="l01675"></a><span class="lineno"> 1675</span>&#160;</div><div class="line"><a name="l01676"></a><span class="lineno"> 1676</span>&#160;            <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(*I1 != *I2);</div><div class="line"><a name="l01677"></a><span class="lineno"> 1677</span>&#160;            <span class="keywordflow">if</span> (*I1 &gt; *I2)</div><div class="line"><a name="l01678"></a><span class="lineno"> 1678</span>&#160;              <a class="code" href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a>(A, B);</div><div class="line"><a name="l01679"></a><span class="lineno"> 1679</span>&#160;</div><div class="line"><a name="l01680"></a><span class="lineno"> 1680</span>&#160;            <a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#ae336b0e8514b99a44e73c3e2494c3cea">Dependence::DepType</a> <a class="code" href="classllvm_1_1Type.html">Type</a> =</div><div class="line"><a name="l01681"></a><span class="lineno"> 1681</span>&#160;                isDependent(*A.first, A.second, *B.first, B.second, Strides);</div><div class="line"><a name="l01682"></a><span class="lineno"> 1682</span>&#160;            mergeInStatus(Dependence::isSafeForVectorization(Type));</div><div class="line"><a name="l01683"></a><span class="lineno"> 1683</span>&#160;</div><div class="line"><a name="l01684"></a><span class="lineno"> 1684</span>&#160;            <span class="comment">// Gather dependences unless we accumulated MaxDependences</span></div><div class="line"><a name="l01685"></a><span class="lineno"> 1685</span>&#160;            <span class="comment">// dependences.  In that case return as soon as we find the first</span></div><div class="line"><a name="l01686"></a><span class="lineno"> 1686</span>&#160;            <span class="comment">// unsafe dependence.  This puts a limit on this quadratic</span></div><div class="line"><a name="l01687"></a><span class="lineno"> 1687</span>&#160;            <span class="comment">// algorithm.</span></div><div class="line"><a name="l01688"></a><span class="lineno"> 1688</span>&#160;            <span class="keywordflow">if</span> (RecordDependences) {</div><div class="line"><a name="l01689"></a><span class="lineno"> 1689</span>&#160;              <span class="keywordflow">if</span> (Type != Dependence::NoDep)</div><div class="line"><a name="l01690"></a><span class="lineno"> 1690</span>&#160;                Dependences.push_back(<a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html">Dependence</a>(A.second, B.second, Type));</div><div class="line"><a name="l01691"></a><span class="lineno"> 1691</span>&#160;</div><div class="line"><a name="l01692"></a><span class="lineno"> 1692</span>&#160;              <span class="keywordflow">if</span> (Dependences.size() &gt;= <a class="code" href="LoopAccessAnalysis_8cpp.html#ab815434ba412e9565ad40caa0413cc26">MaxDependences</a>) {</div><div class="line"><a name="l01693"></a><span class="lineno"> 1693</span>&#160;                RecordDependences = <span class="keyword">false</span>;</div><div class="line"><a name="l01694"></a><span class="lineno"> 1694</span>&#160;                Dependences.clear();</div><div class="line"><a name="l01695"></a><span class="lineno"> 1695</span>&#160;                <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>()</div><div class="line"><a name="l01696"></a><span class="lineno"> 1696</span>&#160;                           &lt;&lt; <span class="stringliteral">&quot;Too many dependences, stopped recording\n&quot;</span>);</div><div class="line"><a name="l01697"></a><span class="lineno"> 1697</span>&#160;              }</div><div class="line"><a name="l01698"></a><span class="lineno"> 1698</span>&#160;            }</div><div class="line"><a name="l01699"></a><span class="lineno"> 1699</span>&#160;            <span class="keywordflow">if</span> (!RecordDependences &amp;&amp; !isSafeForVectorization())</div><div class="line"><a name="l01700"></a><span class="lineno"> 1700</span>&#160;              <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01701"></a><span class="lineno"> 1701</span>&#160;          }</div><div class="line"><a name="l01702"></a><span class="lineno"> 1702</span>&#160;        ++OI;</div><div class="line"><a name="l01703"></a><span class="lineno"> 1703</span>&#160;      }</div><div class="line"><a name="l01704"></a><span class="lineno"> 1704</span>&#160;      AI++;</div><div class="line"><a name="l01705"></a><span class="lineno"> 1705</span>&#160;    }</div><div class="line"><a name="l01706"></a><span class="lineno"> 1706</span>&#160;  }</div><div class="line"><a name="l01707"></a><span class="lineno"> 1707</span>&#160;</div><div class="line"><a name="l01708"></a><span class="lineno"> 1708</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;Total Dependences: &quot;</span> &lt;&lt; Dependences.size() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l01709"></a><span class="lineno"> 1709</span>&#160;  <span class="keywordflow">return</span> isSafeForVectorization();</div><div class="line"><a name="l01710"></a><span class="lineno"> 1710</span>&#160;}</div><div class="line"><a name="l01711"></a><span class="lineno"> 1711</span>&#160;</div><div class="line"><a name="l01712"></a><span class="lineno"> 1712</span>&#160;<a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Instruction *, 4&gt;</a></div><div class="line"><a name="l01713"></a><span class="lineno"><a class="line" href="classllvm_1_1MemoryDepChecker.html#ac340403e4c2fd9116b74b7c2eb95633f"> 1713</a></span>&#160;<a class="code" href="classllvm_1_1MemoryDepChecker.html#ac340403e4c2fd9116b74b7c2eb95633f">MemoryDepChecker::getInstructionsForAccess</a>(<a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr, <span class="keywordtype">bool</span> isWrite)<span class="keyword"> const </span>{</div><div class="line"><a name="l01714"></a><span class="lineno"> 1714</span>&#160;  <a class="code" href="classllvm_1_1PointerIntPair.html">MemAccessInfo</a> Access(Ptr, isWrite);</div><div class="line"><a name="l01715"></a><span class="lineno"> 1715</span>&#160;  <span class="keyword">auto</span> &amp;IndexVector = Accesses.find(Access)-&gt;second;</div><div class="line"><a name="l01716"></a><span class="lineno"> 1716</span>&#160;</div><div class="line"><a name="l01717"></a><span class="lineno"> 1717</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;Instruction *, 4&gt;</a> Insts;</div><div class="line"><a name="l01718"></a><span class="lineno"> 1718</span>&#160;  <a class="code" href="namespacellvm.html#a0d9313480c51aa626d0ce527b45471e3">transform</a>(IndexVector,</div><div class="line"><a name="l01719"></a><span class="lineno"> 1719</span>&#160;                 std::back_inserter(Insts),</div><div class="line"><a name="l01720"></a><span class="lineno"> 1720</span>&#160;                 [&amp;](<span class="keywordtype">unsigned</span> Idx) { <span class="keywordflow">return</span> this-&gt;InstMap[Idx]; });</div><div class="line"><a name="l01721"></a><span class="lineno"> 1721</span>&#160;  <span class="keywordflow">return</span> Insts;</div><div class="line"><a name="l01722"></a><span class="lineno"> 1722</span>&#160;}</div><div class="line"><a name="l01723"></a><span class="lineno"> 1723</span>&#160;</div><div class="line"><a name="l01724"></a><span class="lineno"> 1724</span>&#160;<span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#af1ce4569bdd7d1341b095de3aeeb2765">MemoryDepChecker::Dependence::DepName</a>[] = {</div><div class="line"><a name="l01725"></a><span class="lineno"> 1725</span>&#160;    <span class="stringliteral">&quot;NoDep&quot;</span>, <span class="stringliteral">&quot;Unknown&quot;</span>, <span class="stringliteral">&quot;Forward&quot;</span>, <span class="stringliteral">&quot;ForwardButPreventsForwarding&quot;</span>, <span class="stringliteral">&quot;Backward&quot;</span>,</div><div class="line"><a name="l01726"></a><span class="lineno"> 1726</span>&#160;    <span class="stringliteral">&quot;BackwardVectorizable&quot;</span>, <span class="stringliteral">&quot;BackwardVectorizableButPreventsForwarding&quot;</span>};</div><div class="line"><a name="l01727"></a><span class="lineno"> 1727</span>&#160;</div><div class="line"><a name="l01728"></a><span class="lineno"><a class="line" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a490650c52b42bc9cac525437b364df29"> 1728</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a490650c52b42bc9cac525437b364df29">MemoryDepChecker::Dependence::print</a>(</div><div class="line"><a name="l01729"></a><span class="lineno"> 1729</span>&#160;    <a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, <span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm.html#a1eb5609345b906d024fbf9e4bc1adc06afe578efb7ca235af77fb0eef7edcf639">Depth</a>,</div><div class="line"><a name="l01730"></a><span class="lineno"> 1730</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;Instruction *&gt;</a> &amp;Instrs)<span class="keyword"> const </span>{</div><div class="line"><a name="l01731"></a><span class="lineno"> 1731</span>&#160;  OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; DepName[<a class="code" href="classllvm_1_1Type.html">Type</a>] &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div><div class="line"><a name="l01732"></a><span class="lineno"> 1732</span>&#160;  OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth + 2) &lt;&lt; *Instrs[<a class="code" href="namespacellvm_1_1Sched.html#ac1547cccaf660851fcd6863d1e60309eac13545a6345c7d5b3c9cc8932ad3b0e9">Source</a>] &lt;&lt; <span class="stringliteral">&quot; -&gt; \n&quot;</span>;</div><div class="line"><a name="l01733"></a><span class="lineno"> 1733</span>&#160;  OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth + 2) &lt;&lt; *Instrs[Destination] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l01734"></a><span class="lineno"> 1734</span>&#160;}</div><div class="line"><a name="l01735"></a><span class="lineno"> 1735</span>&#160;</div><div class="line"><a name="l01736"></a><span class="lineno"> 1736</span>&#160;<span class="keywordtype">bool</span> LoopAccessInfo::canAnalyzeLoop() {</div><div class="line"><a name="l01737"></a><span class="lineno"> 1737</span>&#160;  <span class="comment">// We need to have a loop header.</span></div><div class="line"><a name="l01738"></a><span class="lineno"> 1738</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Found a loop in &quot;</span></div><div class="line"><a name="l01739"></a><span class="lineno"> 1739</span>&#160;                    &lt;&lt; TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>()-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#a38bee869ad41aebfef3de2641b12004c">getParent</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#adb5c319f5905c1d3ca9eb5df546388c5">getName</a>() &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div><div class="line"><a name="l01740"></a><span class="lineno"> 1740</span>&#160;                    &lt;&lt; TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>()-&gt;<a class="code" href="classllvm_1_1Value.html#adb5c319f5905c1d3ca9eb5df546388c5">getName</a>() &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>);</div><div class="line"><a name="l01741"></a><span class="lineno"> 1741</span>&#160;</div><div class="line"><a name="l01742"></a><span class="lineno"> 1742</span>&#160;  <span class="comment">// We can only analyze innermost loops.</span></div><div class="line"><a name="l01743"></a><span class="lineno"> 1743</span>&#160;  <span class="keywordflow">if</span> (!TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#aa26f5f090ad68a30b5c33be53ef3e642">empty</a>()) {</div><div class="line"><a name="l01744"></a><span class="lineno"> 1744</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: loop is not the innermost loop\n&quot;</span>);</div><div class="line"><a name="l01745"></a><span class="lineno"> 1745</span>&#160;    recordAnalysis(<span class="stringliteral">&quot;NotInnerMostLoop&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;loop is not the innermost loop&quot;</span>;</div><div class="line"><a name="l01746"></a><span class="lineno"> 1746</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01747"></a><span class="lineno"> 1747</span>&#160;  }</div><div class="line"><a name="l01748"></a><span class="lineno"> 1748</span>&#160;</div><div class="line"><a name="l01749"></a><span class="lineno"> 1749</span>&#160;  <span class="comment">// We must have a single backedge.</span></div><div class="line"><a name="l01750"></a><span class="lineno"> 1750</span>&#160;  <span class="keywordflow">if</span> (TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a389bb3581ba3c8094b89642efaf8e514">getNumBackEdges</a>() != 1) {</div><div class="line"><a name="l01751"></a><span class="lineno"> 1751</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l01752"></a><span class="lineno"> 1752</span>&#160;        <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: loop control flow is not understood by analyzer\n&quot;</span>);</div><div class="line"><a name="l01753"></a><span class="lineno"> 1753</span>&#160;    recordAnalysis(<span class="stringliteral">&quot;CFGNotUnderstood&quot;</span>)</div><div class="line"><a name="l01754"></a><span class="lineno"> 1754</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;loop control flow is not understood by analyzer&quot;</span>;</div><div class="line"><a name="l01755"></a><span class="lineno"> 1755</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01756"></a><span class="lineno"> 1756</span>&#160;  }</div><div class="line"><a name="l01757"></a><span class="lineno"> 1757</span>&#160;</div><div class="line"><a name="l01758"></a><span class="lineno"> 1758</span>&#160;  <span class="comment">// We must have a single exiting block.</span></div><div class="line"><a name="l01759"></a><span class="lineno"> 1759</span>&#160;  <span class="keywordflow">if</span> (!TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#adf6f53d7652b471c995b7d10f3dd2729">getExitingBlock</a>()) {</div><div class="line"><a name="l01760"></a><span class="lineno"> 1760</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l01761"></a><span class="lineno"> 1761</span>&#160;        <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: loop control flow is not understood by analyzer\n&quot;</span>);</div><div class="line"><a name="l01762"></a><span class="lineno"> 1762</span>&#160;    recordAnalysis(<span class="stringliteral">&quot;CFGNotUnderstood&quot;</span>)</div><div class="line"><a name="l01763"></a><span class="lineno"> 1763</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;loop control flow is not understood by analyzer&quot;</span>;</div><div class="line"><a name="l01764"></a><span class="lineno"> 1764</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01765"></a><span class="lineno"> 1765</span>&#160;  }</div><div class="line"><a name="l01766"></a><span class="lineno"> 1766</span>&#160;</div><div class="line"><a name="l01767"></a><span class="lineno"> 1767</span>&#160;  <span class="comment">// We only handle bottom-tested loops, i.e. loop in which the condition is</span></div><div class="line"><a name="l01768"></a><span class="lineno"> 1768</span>&#160;  <span class="comment">// checked at the end of each iteration. With that we can assume that all</span></div><div class="line"><a name="l01769"></a><span class="lineno"> 1769</span>&#160;  <span class="comment">// instructions in the loop are executed the same number of times.</span></div><div class="line"><a name="l01770"></a><span class="lineno"> 1770</span>&#160;  <span class="keywordflow">if</span> (TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#adf6f53d7652b471c995b7d10f3dd2729">getExitingBlock</a>() != TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a1230fd674d2609b96527fe65eaf40b1b">getLoopLatch</a>()) {</div><div class="line"><a name="l01771"></a><span class="lineno"> 1771</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l01772"></a><span class="lineno"> 1772</span>&#160;        <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: loop control flow is not understood by analyzer\n&quot;</span>);</div><div class="line"><a name="l01773"></a><span class="lineno"> 1773</span>&#160;    recordAnalysis(<span class="stringliteral">&quot;CFGNotUnderstood&quot;</span>)</div><div class="line"><a name="l01774"></a><span class="lineno"> 1774</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;loop control flow is not understood by analyzer&quot;</span>;</div><div class="line"><a name="l01775"></a><span class="lineno"> 1775</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01776"></a><span class="lineno"> 1776</span>&#160;  }</div><div class="line"><a name="l01777"></a><span class="lineno"> 1777</span>&#160;</div><div class="line"><a name="l01778"></a><span class="lineno"> 1778</span>&#160;  <span class="comment">// ScalarEvolution needs to be able to find the exit count.</span></div><div class="line"><a name="l01779"></a><span class="lineno"> 1779</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *ExitCount = PSE-&gt;getBackedgeTakenCount();</div><div class="line"><a name="l01780"></a><span class="lineno"> 1780</span>&#160;  <span class="keywordflow">if</span> (ExitCount == PSE-&gt;getSE()-&gt;getCouldNotCompute()) {</div><div class="line"><a name="l01781"></a><span class="lineno"> 1781</span>&#160;    recordAnalysis(<span class="stringliteral">&quot;CantComputeNumberOfIterations&quot;</span>)</div><div class="line"><a name="l01782"></a><span class="lineno"> 1782</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;could not determine number of loop iterations&quot;</span>;</div><div class="line"><a name="l01783"></a><span class="lineno"> 1783</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: SCEV could not compute the loop exit count.\n&quot;</span>);</div><div class="line"><a name="l01784"></a><span class="lineno"> 1784</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l01785"></a><span class="lineno"> 1785</span>&#160;  }</div><div class="line"><a name="l01786"></a><span class="lineno"> 1786</span>&#160;</div><div class="line"><a name="l01787"></a><span class="lineno"> 1787</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l01788"></a><span class="lineno"> 1788</span>&#160;}</div><div class="line"><a name="l01789"></a><span class="lineno"> 1789</span>&#160;</div><div class="line"><a name="l01790"></a><span class="lineno"> 1790</span>&#160;<span class="keywordtype">void</span> LoopAccessInfo::analyzeLoop(<a class="code" href="classllvm_1_1AAResults.html">AliasAnalysis</a> *AA, <a class="code" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI,</div><div class="line"><a name="l01791"></a><span class="lineno"> 1791</span>&#160;                                 <span class="keyword">const</span> <a class="code" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *TLI,</div><div class="line"><a name="l01792"></a><span class="lineno"> 1792</span>&#160;                                 <a class="code" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT) {</div><div class="line"><a name="l01793"></a><span class="lineno"> 1793</span>&#160;  <span class="keyword">typedef</span> <a class="code" href="classllvm_1_1SmallPtrSet.html">SmallPtrSet&lt;Value*, 16&gt;</a> ValueSet;</div><div class="line"><a name="l01794"></a><span class="lineno"> 1794</span>&#160;</div><div class="line"><a name="l01795"></a><span class="lineno"> 1795</span>&#160;  <span class="comment">// Holds the Load and Store instructions.</span></div><div class="line"><a name="l01796"></a><span class="lineno"> 1796</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;LoadInst *, 16&gt;</a> Loads;</div><div class="line"><a name="l01797"></a><span class="lineno"> 1797</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;StoreInst *, 16&gt;</a> Stores;</div><div class="line"><a name="l01798"></a><span class="lineno"> 1798</span>&#160;</div><div class="line"><a name="l01799"></a><span class="lineno"> 1799</span>&#160;  <span class="comment">// Holds all the different accesses in the loop.</span></div><div class="line"><a name="l01800"></a><span class="lineno"> 1800</span>&#160;  <span class="keywordtype">unsigned</span> NumReads = 0;</div><div class="line"><a name="l01801"></a><span class="lineno"> 1801</span>&#160;  <span class="keywordtype">unsigned</span> NumReadWrites = 0;</div><div class="line"><a name="l01802"></a><span class="lineno"> 1802</span>&#160;</div><div class="line"><a name="l01803"></a><span class="lineno"> 1803</span>&#160;  <span class="keywordtype">bool</span> HasComplexMemInst = <span class="keyword">false</span>;</div><div class="line"><a name="l01804"></a><span class="lineno"> 1804</span>&#160;</div><div class="line"><a name="l01805"></a><span class="lineno"> 1805</span>&#160;  <span class="comment">// A runtime check is only legal to insert if there are no convergent calls.</span></div><div class="line"><a name="l01806"></a><span class="lineno"> 1806</span>&#160;  HasConvergentOp = <span class="keyword">false</span>;</div><div class="line"><a name="l01807"></a><span class="lineno"> 1807</span>&#160;</div><div class="line"><a name="l01808"></a><span class="lineno"> 1808</span>&#160;  PtrRtChecking-&gt;Pointers.<a class="code" href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">clear</a>();</div><div class="line"><a name="l01809"></a><span class="lineno"> 1809</span>&#160;  PtrRtChecking-&gt;Need = <span class="keyword">false</span>;</div><div class="line"><a name="l01810"></a><span class="lineno"> 1810</span>&#160;</div><div class="line"><a name="l01811"></a><span class="lineno"> 1811</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">bool</span> IsAnnotatedParallel = TheLoop-&gt;<a class="code" href="classllvm_1_1Loop.html#a5bce47fa5e8edaf4eef3ddc67a78193c">isAnnotatedParallel</a>();</div><div class="line"><a name="l01812"></a><span class="lineno"> 1812</span>&#160;</div><div class="line"><a name="l01813"></a><span class="lineno"> 1813</span>&#160;  <span class="comment">// For each block.</span></div><div class="line"><a name="l01814"></a><span class="lineno"> 1814</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *BB : TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a40f34cc77d2b3bc73384f535c8101858">blocks</a>()) {</div><div class="line"><a name="l01815"></a><span class="lineno"> 1815</span>&#160;    <span class="comment">// Scan the BB and collect legal loads and stores. Also detect any</span></div><div class="line"><a name="l01816"></a><span class="lineno"> 1816</span>&#160;    <span class="comment">// convergent instructions.</span></div><div class="line"><a name="l01817"></a><span class="lineno"> 1817</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> : *BB) {</div><div class="line"><a name="l01818"></a><span class="lineno"> 1818</span>&#160;      <span class="keywordflow">if</span> (<span class="keyword">auto</span> *Call = dyn_cast&lt;CallBase&gt;(&amp;<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)) {</div><div class="line"><a name="l01819"></a><span class="lineno"> 1819</span>&#160;        <span class="keywordflow">if</span> (Call-&gt;isConvergent())</div><div class="line"><a name="l01820"></a><span class="lineno"> 1820</span>&#160;          HasConvergentOp = <span class="keyword">true</span>;</div><div class="line"><a name="l01821"></a><span class="lineno"> 1821</span>&#160;      }</div><div class="line"><a name="l01822"></a><span class="lineno"> 1822</span>&#160;</div><div class="line"><a name="l01823"></a><span class="lineno"> 1823</span>&#160;      <span class="comment">// With both a non-vectorizable memory instruction and a convergent</span></div><div class="line"><a name="l01824"></a><span class="lineno"> 1824</span>&#160;      <span class="comment">// operation, found in this loop, no reason to continue the search.</span></div><div class="line"><a name="l01825"></a><span class="lineno"> 1825</span>&#160;      <span class="keywordflow">if</span> (HasComplexMemInst &amp;&amp; HasConvergentOp) {</div><div class="line"><a name="l01826"></a><span class="lineno"> 1826</span>&#160;        CanVecMem = <span class="keyword">false</span>;</div><div class="line"><a name="l01827"></a><span class="lineno"> 1827</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l01828"></a><span class="lineno"> 1828</span>&#160;      }</div><div class="line"><a name="l01829"></a><span class="lineno"> 1829</span>&#160;</div><div class="line"><a name="l01830"></a><span class="lineno"> 1830</span>&#160;      <span class="comment">// Avoid hitting recordAnalysis multiple times.</span></div><div class="line"><a name="l01831"></a><span class="lineno"> 1831</span>&#160;      <span class="keywordflow">if</span> (HasComplexMemInst)</div><div class="line"><a name="l01832"></a><span class="lineno"> 1832</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01833"></a><span class="lineno"> 1833</span>&#160;</div><div class="line"><a name="l01834"></a><span class="lineno"> 1834</span>&#160;      <span class="comment">// If this is a load, save it. If this instruction can read from memory</span></div><div class="line"><a name="l01835"></a><span class="lineno"> 1835</span>&#160;      <span class="comment">// but is not a load, then we quit. Notice that we don&#39;t handle function</span></div><div class="line"><a name="l01836"></a><span class="lineno"> 1836</span>&#160;      <span class="comment">// calls that read or write.</span></div><div class="line"><a name="l01837"></a><span class="lineno"> 1837</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>.mayReadFromMemory()) {</div><div class="line"><a name="l01838"></a><span class="lineno"> 1838</span>&#160;        <span class="comment">// Many math library functions read the rounding mode. We will only</span></div><div class="line"><a name="l01839"></a><span class="lineno"> 1839</span>&#160;        <span class="comment">// vectorize a loop if it contains known function calls that don&#39;t set</span></div><div class="line"><a name="l01840"></a><span class="lineno"> 1840</span>&#160;        <span class="comment">// the flag. Therefore, it is safe to ignore this read from memory.</span></div><div class="line"><a name="l01841"></a><span class="lineno"> 1841</span>&#160;        <span class="keyword">auto</span> *Call = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1CallInst.html">CallInst</a>&gt;(&amp;<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>);</div><div class="line"><a name="l01842"></a><span class="lineno"> 1842</span>&#160;        <span class="keywordflow">if</span> (Call &amp;&amp; <a class="code" href="namespacellvm.html#a11c66d01880f53332fc7ad53f565b039">getVectorIntrinsicIDForCall</a>(Call, TLI))</div><div class="line"><a name="l01843"></a><span class="lineno"> 1843</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01844"></a><span class="lineno"> 1844</span>&#160;</div><div class="line"><a name="l01845"></a><span class="lineno"> 1845</span>&#160;        <span class="comment">// If the function has an explicit vectorized counterpart, we can safely</span></div><div class="line"><a name="l01846"></a><span class="lineno"> 1846</span>&#160;        <span class="comment">// assume that it can be vectorized.</span></div><div class="line"><a name="l01847"></a><span class="lineno"> 1847</span>&#160;        <span class="keywordflow">if</span> (Call &amp;&amp; !Call-&gt;isNoBuiltin() &amp;&amp; Call-&gt;getCalledFunction() &amp;&amp;</div><div class="line"><a name="l01848"></a><span class="lineno"> 1848</span>&#160;            TLI-&gt;<a class="code" href="classllvm_1_1TargetLibraryInfo.html#a2fcef86fd476c438d77d7d7229d456e6">isFunctionVectorizable</a>(Call-&gt;getCalledFunction()-&gt;getName()))</div><div class="line"><a name="l01849"></a><span class="lineno"> 1849</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01850"></a><span class="lineno"> 1850</span>&#160;</div><div class="line"><a name="l01851"></a><span class="lineno"> 1851</span>&#160;        <span class="keyword">auto</span> *Ld = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a>&gt;(&amp;<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>);</div><div class="line"><a name="l01852"></a><span class="lineno"> 1852</span>&#160;        <span class="keywordflow">if</span> (!Ld) {</div><div class="line"><a name="l01853"></a><span class="lineno"> 1853</span>&#160;          recordAnalysis(<span class="stringliteral">&quot;CantVectorizeInstruction&quot;</span>, Ld)</div><div class="line"><a name="l01854"></a><span class="lineno"> 1854</span>&#160;            &lt;&lt; <span class="stringliteral">&quot;instruction cannot be vectorized&quot;</span>;</div><div class="line"><a name="l01855"></a><span class="lineno"> 1855</span>&#160;          HasComplexMemInst = <span class="keyword">true</span>;</div><div class="line"><a name="l01856"></a><span class="lineno"> 1856</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01857"></a><span class="lineno"> 1857</span>&#160;        }</div><div class="line"><a name="l01858"></a><span class="lineno"> 1858</span>&#160;        <span class="keywordflow">if</span> (!Ld-&gt;isSimple() &amp;&amp; !IsAnnotatedParallel) {</div><div class="line"><a name="l01859"></a><span class="lineno"> 1859</span>&#160;          recordAnalysis(<span class="stringliteral">&quot;NonSimpleLoad&quot;</span>, Ld)</div><div class="line"><a name="l01860"></a><span class="lineno"> 1860</span>&#160;              &lt;&lt; <span class="stringliteral">&quot;read with atomic ordering or volatile read&quot;</span>;</div><div class="line"><a name="l01861"></a><span class="lineno"> 1861</span>&#160;          <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Found a non-simple load.\n&quot;</span>);</div><div class="line"><a name="l01862"></a><span class="lineno"> 1862</span>&#160;          HasComplexMemInst = <span class="keyword">true</span>;</div><div class="line"><a name="l01863"></a><span class="lineno"> 1863</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01864"></a><span class="lineno"> 1864</span>&#160;        }</div><div class="line"><a name="l01865"></a><span class="lineno"> 1865</span>&#160;        NumLoads++;</div><div class="line"><a name="l01866"></a><span class="lineno"> 1866</span>&#160;        Loads.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#af42bfbc067df27c19ee2fc859df58799">push_back</a>(Ld);</div><div class="line"><a name="l01867"></a><span class="lineno"> 1867</span>&#160;        DepChecker-&gt;addAccess(Ld);</div><div class="line"><a name="l01868"></a><span class="lineno"> 1868</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="LoopAccessAnalysis_8cpp.html#a7b58e159e9c7683ba37043d4288d643a">EnableMemAccessVersioning</a>)</div><div class="line"><a name="l01869"></a><span class="lineno"> 1869</span>&#160;          collectStridedAccess(Ld);</div><div class="line"><a name="l01870"></a><span class="lineno"> 1870</span>&#160;        <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01871"></a><span class="lineno"> 1871</span>&#160;      }</div><div class="line"><a name="l01872"></a><span class="lineno"> 1872</span>&#160;</div><div class="line"><a name="l01873"></a><span class="lineno"> 1873</span>&#160;      <span class="comment">// Save &#39;store&#39; instructions. Abort if other instructions write to memory.</span></div><div class="line"><a name="l01874"></a><span class="lineno"> 1874</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>.mayWriteToMemory()) {</div><div class="line"><a name="l01875"></a><span class="lineno"> 1875</span>&#160;        <span class="keyword">auto</span> *St = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a>&gt;(&amp;<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>);</div><div class="line"><a name="l01876"></a><span class="lineno"> 1876</span>&#160;        <span class="keywordflow">if</span> (!St) {</div><div class="line"><a name="l01877"></a><span class="lineno"> 1877</span>&#160;          recordAnalysis(<span class="stringliteral">&quot;CantVectorizeInstruction&quot;</span>, St)</div><div class="line"><a name="l01878"></a><span class="lineno"> 1878</span>&#160;              &lt;&lt; <span class="stringliteral">&quot;instruction cannot be vectorized&quot;</span>;</div><div class="line"><a name="l01879"></a><span class="lineno"> 1879</span>&#160;          HasComplexMemInst = <span class="keyword">true</span>;</div><div class="line"><a name="l01880"></a><span class="lineno"> 1880</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01881"></a><span class="lineno"> 1881</span>&#160;        }</div><div class="line"><a name="l01882"></a><span class="lineno"> 1882</span>&#160;        <span class="keywordflow">if</span> (!St-&gt;isSimple() &amp;&amp; !IsAnnotatedParallel) {</div><div class="line"><a name="l01883"></a><span class="lineno"> 1883</span>&#160;          recordAnalysis(<span class="stringliteral">&quot;NonSimpleStore&quot;</span>, St)</div><div class="line"><a name="l01884"></a><span class="lineno"> 1884</span>&#160;              &lt;&lt; <span class="stringliteral">&quot;write with atomic ordering or volatile write&quot;</span>;</div><div class="line"><a name="l01885"></a><span class="lineno"> 1885</span>&#160;          <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Found a non-simple store.\n&quot;</span>);</div><div class="line"><a name="l01886"></a><span class="lineno"> 1886</span>&#160;          HasComplexMemInst = <span class="keyword">true</span>;</div><div class="line"><a name="l01887"></a><span class="lineno"> 1887</span>&#160;          <span class="keywordflow">continue</span>;</div><div class="line"><a name="l01888"></a><span class="lineno"> 1888</span>&#160;        }</div><div class="line"><a name="l01889"></a><span class="lineno"> 1889</span>&#160;        NumStores++;</div><div class="line"><a name="l01890"></a><span class="lineno"> 1890</span>&#160;        Stores.<a class="code" href="classllvm_1_1SmallVectorTemplateBase.html#af42bfbc067df27c19ee2fc859df58799">push_back</a>(St);</div><div class="line"><a name="l01891"></a><span class="lineno"> 1891</span>&#160;        DepChecker-&gt;addAccess(St);</div><div class="line"><a name="l01892"></a><span class="lineno"> 1892</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="LoopAccessAnalysis_8cpp.html#a7b58e159e9c7683ba37043d4288d643a">EnableMemAccessVersioning</a>)</div><div class="line"><a name="l01893"></a><span class="lineno"> 1893</span>&#160;          collectStridedAccess(St);</div><div class="line"><a name="l01894"></a><span class="lineno"> 1894</span>&#160;      }</div><div class="line"><a name="l01895"></a><span class="lineno"> 1895</span>&#160;    } <span class="comment">// Next instr.</span></div><div class="line"><a name="l01896"></a><span class="lineno"> 1896</span>&#160;  } <span class="comment">// Next block.</span></div><div class="line"><a name="l01897"></a><span class="lineno"> 1897</span>&#160;</div><div class="line"><a name="l01898"></a><span class="lineno"> 1898</span>&#160;  <span class="keywordflow">if</span> (HasComplexMemInst) {</div><div class="line"><a name="l01899"></a><span class="lineno"> 1899</span>&#160;    CanVecMem = <span class="keyword">false</span>;</div><div class="line"><a name="l01900"></a><span class="lineno"> 1900</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l01901"></a><span class="lineno"> 1901</span>&#160;  }</div><div class="line"><a name="l01902"></a><span class="lineno"> 1902</span>&#160;</div><div class="line"><a name="l01903"></a><span class="lineno"> 1903</span>&#160;  <span class="comment">// Now we have two lists that hold the loads and the stores.</span></div><div class="line"><a name="l01904"></a><span class="lineno"> 1904</span>&#160;  <span class="comment">// Next, we find the pointers that they use.</span></div><div class="line"><a name="l01905"></a><span class="lineno"> 1905</span>&#160;</div><div class="line"><a name="l01906"></a><span class="lineno"> 1906</span>&#160;  <span class="comment">// Check if we see any stores. If there are no stores, then we don&#39;t</span></div><div class="line"><a name="l01907"></a><span class="lineno"> 1907</span>&#160;  <span class="comment">// care if the pointers are *restrict*.</span></div><div class="line"><a name="l01908"></a><span class="lineno"> 1908</span>&#160;  <span class="keywordflow">if</span> (!Stores.<a class="code" href="classllvm_1_1SmallVectorBase.html#ac8624043115fb3a5076c964820001b61">size</a>()) {</div><div class="line"><a name="l01909"></a><span class="lineno"> 1909</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Found a read-only loop!\n&quot;</span>);</div><div class="line"><a name="l01910"></a><span class="lineno"> 1910</span>&#160;    CanVecMem = <span class="keyword">true</span>;</div><div class="line"><a name="l01911"></a><span class="lineno"> 1911</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l01912"></a><span class="lineno"> 1912</span>&#160;  }</div><div class="line"><a name="l01913"></a><span class="lineno"> 1913</span>&#160;</div><div class="line"><a name="l01914"></a><span class="lineno"> 1914</span>&#160;  <a class="code" href="classllvm_1_1EquivalenceClasses.html">MemoryDepChecker::DepCandidates</a> DependentAccesses;</div><div class="line"><a name="l01915"></a><span class="lineno"> 1915</span>&#160;  AccessAnalysis Accesses(TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>()-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#afc70e919c88c86159cc94cea29b6c210">getModule</a>()-&gt;<a class="code" href="classllvm_1_1Module.html#a6d883605206368bc536cc9ded97209b8">getDataLayout</a>(),</div><div class="line"><a name="l01916"></a><span class="lineno"> 1916</span>&#160;                          TheLoop, AA, LI, DependentAccesses, *PSE);</div><div class="line"><a name="l01917"></a><span class="lineno"> 1917</span>&#160;</div><div class="line"><a name="l01918"></a><span class="lineno"> 1918</span>&#160;  <span class="comment">// Holds the analyzed pointers. We don&#39;t want to call GetUnderlyingObjects</span></div><div class="line"><a name="l01919"></a><span class="lineno"> 1919</span>&#160;  <span class="comment">// multiple times on the same object. If the ptr is accessed twice, once</span></div><div class="line"><a name="l01920"></a><span class="lineno"> 1920</span>&#160;  <span class="comment">// for read and once for write, it will only appear once (on the write</span></div><div class="line"><a name="l01921"></a><span class="lineno"> 1921</span>&#160;  <span class="comment">// list). This is okay, since we are going to check for conflicts between</span></div><div class="line"><a name="l01922"></a><span class="lineno"> 1922</span>&#160;  <span class="comment">// writes and between reads and writes, but not between reads and reads.</span></div><div class="line"><a name="l01923"></a><span class="lineno"> 1923</span>&#160;  ValueSet Seen;</div><div class="line"><a name="l01924"></a><span class="lineno"> 1924</span>&#160;</div><div class="line"><a name="l01925"></a><span class="lineno"> 1925</span>&#160;  <span class="comment">// Record uniform store addresses to identify if we have multiple stores</span></div><div class="line"><a name="l01926"></a><span class="lineno"> 1926</span>&#160;  <span class="comment">// to the same address.</span></div><div class="line"><a name="l01927"></a><span class="lineno"> 1927</span>&#160;  ValueSet UniformStores;</div><div class="line"><a name="l01928"></a><span class="lineno"> 1928</span>&#160;</div><div class="line"><a name="l01929"></a><span class="lineno"> 1929</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *<a class="code" href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85aed0b9bef861c96eee19e89db753db7b2">ST</a> : Stores) {</div><div class="line"><a name="l01930"></a><span class="lineno"> 1930</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr = <a class="code" href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85aed0b9bef861c96eee19e89db753db7b2">ST</a>-&gt;getPointerOperand();</div><div class="line"><a name="l01931"></a><span class="lineno"> 1931</span>&#160;</div><div class="line"><a name="l01932"></a><span class="lineno"> 1932</span>&#160;    <span class="keywordflow">if</span> (isUniform(Ptr))</div><div class="line"><a name="l01933"></a><span class="lineno"> 1933</span>&#160;      HasDependenceInvolvingLoopInvariantAddress |=</div><div class="line"><a name="l01934"></a><span class="lineno"> 1934</span>&#160;          !UniformStores.insert(Ptr).second;</div><div class="line"><a name="l01935"></a><span class="lineno"> 1935</span>&#160;</div><div class="line"><a name="l01936"></a><span class="lineno"> 1936</span>&#160;    <span class="comment">// If we did *not* see this pointer before, insert it to  the read-write</span></div><div class="line"><a name="l01937"></a><span class="lineno"> 1937</span>&#160;    <span class="comment">// list. At this phase it is only a &#39;write&#39; list.</span></div><div class="line"><a name="l01938"></a><span class="lineno"> 1938</span>&#160;    <span class="keywordflow">if</span> (Seen.insert(Ptr).second) {</div><div class="line"><a name="l01939"></a><span class="lineno"> 1939</span>&#160;      ++NumReadWrites;</div><div class="line"><a name="l01940"></a><span class="lineno"> 1940</span>&#160;</div><div class="line"><a name="l01941"></a><span class="lineno"> 1941</span>&#160;      <a class="code" href="classllvm_1_1MemoryLocation.html">MemoryLocation</a> Loc = <a class="code" href="classllvm_1_1MemoryLocation.html#a18e5a3f1d71ba10a624f2a8e5121cf1f">MemoryLocation::get</a>(<a class="code" href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85aed0b9bef861c96eee19e89db753db7b2">ST</a>);</div><div class="line"><a name="l01942"></a><span class="lineno"> 1942</span>&#160;      <span class="comment">// The TBAA metadata could have a control dependency on the predication</span></div><div class="line"><a name="l01943"></a><span class="lineno"> 1943</span>&#160;      <span class="comment">// condition, so we cannot rely on it when determining whether or not we</span></div><div class="line"><a name="l01944"></a><span class="lineno"> 1944</span>&#160;      <span class="comment">// need runtime pointer checks.</span></div><div class="line"><a name="l01945"></a><span class="lineno"> 1945</span>&#160;      <span class="keywordflow">if</span> (blockNeedsPredication(<a class="code" href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85aed0b9bef861c96eee19e89db753db7b2">ST</a>-&gt;getParent(), TheLoop, DT))</div><div class="line"><a name="l01946"></a><span class="lineno"> 1946</span>&#160;        Loc.<a class="code" href="classllvm_1_1MemoryLocation.html#a926099ca5ca5db6ba2de398c2487b725">AATags</a>.<a class="code" href="structllvm_1_1AAMDNodes.html#a56188042f9dd6003cb8ed087e8ae654f">TBAA</a> = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01947"></a><span class="lineno"> 1947</span>&#160;</div><div class="line"><a name="l01948"></a><span class="lineno"> 1948</span>&#160;      Accesses.addStore(Loc);</div><div class="line"><a name="l01949"></a><span class="lineno"> 1949</span>&#160;    }</div><div class="line"><a name="l01950"></a><span class="lineno"> 1950</span>&#160;  }</div><div class="line"><a name="l01951"></a><span class="lineno"> 1951</span>&#160;</div><div class="line"><a name="l01952"></a><span class="lineno"> 1952</span>&#160;  <span class="keywordflow">if</span> (IsAnnotatedParallel) {</div><div class="line"><a name="l01953"></a><span class="lineno"> 1953</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l01954"></a><span class="lineno"> 1954</span>&#160;        <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: A loop annotated parallel, ignore memory dependency &quot;</span></div><div class="line"><a name="l01955"></a><span class="lineno"> 1955</span>&#160;               &lt;&lt; <span class="stringliteral">&quot;checks.\n&quot;</span>);</div><div class="line"><a name="l01956"></a><span class="lineno"> 1956</span>&#160;    CanVecMem = <span class="keyword">true</span>;</div><div class="line"><a name="l01957"></a><span class="lineno"> 1957</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l01958"></a><span class="lineno"> 1958</span>&#160;  }</div><div class="line"><a name="l01959"></a><span class="lineno"> 1959</span>&#160;</div><div class="line"><a name="l01960"></a><span class="lineno"> 1960</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *<a class="code" href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85a7289f7156c17c31399fe5226bf556781">LD</a> : Loads) {</div><div class="line"><a name="l01961"></a><span class="lineno"> 1961</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr = <a class="code" href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85a7289f7156c17c31399fe5226bf556781">LD</a>-&gt;getPointerOperand();</div><div class="line"><a name="l01962"></a><span class="lineno"> 1962</span>&#160;    <span class="comment">// If we did *not* see this pointer before, insert it to the</span></div><div class="line"><a name="l01963"></a><span class="lineno"> 1963</span>&#160;    <span class="comment">// read list. If we *did* see it before, then it is already in</span></div><div class="line"><a name="l01964"></a><span class="lineno"> 1964</span>&#160;    <span class="comment">// the read-write list. This allows us to vectorize expressions</span></div><div class="line"><a name="l01965"></a><span class="lineno"> 1965</span>&#160;    <span class="comment">// such as A[i] += x;  Because the address of A[i] is a read-write</span></div><div class="line"><a name="l01966"></a><span class="lineno"> 1966</span>&#160;    <span class="comment">// pointer. This only works if the index of A[i] is consecutive.</span></div><div class="line"><a name="l01967"></a><span class="lineno"> 1967</span>&#160;    <span class="comment">// If the address of i is unknown (for example A[B[i]]) then we may</span></div><div class="line"><a name="l01968"></a><span class="lineno"> 1968</span>&#160;    <span class="comment">// read a few words, modify, and write a few words, and some of the</span></div><div class="line"><a name="l01969"></a><span class="lineno"> 1969</span>&#160;    <span class="comment">// words may be written to the same address.</span></div><div class="line"><a name="l01970"></a><span class="lineno"> 1970</span>&#160;    <span class="keywordtype">bool</span> IsReadOnlyPtr = <span class="keyword">false</span>;</div><div class="line"><a name="l01971"></a><span class="lineno"> 1971</span>&#160;    <span class="keywordflow">if</span> (Seen.insert(Ptr).second ||</div><div class="line"><a name="l01972"></a><span class="lineno"> 1972</span>&#160;        !<a class="code" href="namespacellvm.html#ab7f1b8ad3b5b4cb2cb19c2291dcf3cf1">getPtrStride</a>(*PSE, Ptr, TheLoop, SymbolicStrides)) {</div><div class="line"><a name="l01973"></a><span class="lineno"> 1973</span>&#160;      ++NumReads;</div><div class="line"><a name="l01974"></a><span class="lineno"> 1974</span>&#160;      IsReadOnlyPtr = <span class="keyword">true</span>;</div><div class="line"><a name="l01975"></a><span class="lineno"> 1975</span>&#160;    }</div><div class="line"><a name="l01976"></a><span class="lineno"> 1976</span>&#160;</div><div class="line"><a name="l01977"></a><span class="lineno"> 1977</span>&#160;    <span class="comment">// See if there is an unsafe dependency between a load to a uniform address and</span></div><div class="line"><a name="l01978"></a><span class="lineno"> 1978</span>&#160;    <span class="comment">// store to the same uniform address.</span></div><div class="line"><a name="l01979"></a><span class="lineno"> 1979</span>&#160;    <span class="keywordflow">if</span> (UniformStores.count(Ptr)) {</div><div class="line"><a name="l01980"></a><span class="lineno"> 1980</span>&#160;      <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Found an unsafe dependency between a uniform &quot;</span></div><div class="line"><a name="l01981"></a><span class="lineno"> 1981</span>&#160;                           <span class="stringliteral">&quot;load and uniform store to the same address!\n&quot;</span>);</div><div class="line"><a name="l01982"></a><span class="lineno"> 1982</span>&#160;      HasDependenceInvolvingLoopInvariantAddress = <span class="keyword">true</span>;</div><div class="line"><a name="l01983"></a><span class="lineno"> 1983</span>&#160;    }</div><div class="line"><a name="l01984"></a><span class="lineno"> 1984</span>&#160;</div><div class="line"><a name="l01985"></a><span class="lineno"> 1985</span>&#160;    <a class="code" href="classllvm_1_1MemoryLocation.html">MemoryLocation</a> Loc = <a class="code" href="classllvm_1_1MemoryLocation.html#a18e5a3f1d71ba10a624f2a8e5121cf1f">MemoryLocation::get</a>(<a class="code" href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85a7289f7156c17c31399fe5226bf556781">LD</a>);</div><div class="line"><a name="l01986"></a><span class="lineno"> 1986</span>&#160;    <span class="comment">// The TBAA metadata could have a control dependency on the predication</span></div><div class="line"><a name="l01987"></a><span class="lineno"> 1987</span>&#160;    <span class="comment">// condition, so we cannot rely on it when determining whether or not we</span></div><div class="line"><a name="l01988"></a><span class="lineno"> 1988</span>&#160;    <span class="comment">// need runtime pointer checks.</span></div><div class="line"><a name="l01989"></a><span class="lineno"> 1989</span>&#160;    <span class="keywordflow">if</span> (blockNeedsPredication(<a class="code" href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85a7289f7156c17c31399fe5226bf556781">LD</a>-&gt;getParent(), TheLoop, DT))</div><div class="line"><a name="l01990"></a><span class="lineno"> 1990</span>&#160;      Loc.<a class="code" href="classllvm_1_1MemoryLocation.html#a926099ca5ca5db6ba2de398c2487b725">AATags</a>.<a class="code" href="structllvm_1_1AAMDNodes.html#a56188042f9dd6003cb8ed087e8ae654f">TBAA</a> = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l01991"></a><span class="lineno"> 1991</span>&#160;</div><div class="line"><a name="l01992"></a><span class="lineno"> 1992</span>&#160;    Accesses.addLoad(Loc, IsReadOnlyPtr);</div><div class="line"><a name="l01993"></a><span class="lineno"> 1993</span>&#160;  }</div><div class="line"><a name="l01994"></a><span class="lineno"> 1994</span>&#160;</div><div class="line"><a name="l01995"></a><span class="lineno"> 1995</span>&#160;  <span class="comment">// If we write (or read-write) to a single destination and there are no</span></div><div class="line"><a name="l01996"></a><span class="lineno"> 1996</span>&#160;  <span class="comment">// other reads in this loop then is it safe to vectorize.</span></div><div class="line"><a name="l01997"></a><span class="lineno"> 1997</span>&#160;  <span class="keywordflow">if</span> (NumReadWrites == 1 &amp;&amp; NumReads == 0) {</div><div class="line"><a name="l01998"></a><span class="lineno"> 1998</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Found a write-only loop!\n&quot;</span>);</div><div class="line"><a name="l01999"></a><span class="lineno"> 1999</span>&#160;    CanVecMem = <span class="keyword">true</span>;</div><div class="line"><a name="l02000"></a><span class="lineno"> 2000</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l02001"></a><span class="lineno"> 2001</span>&#160;  }</div><div class="line"><a name="l02002"></a><span class="lineno"> 2002</span>&#160;</div><div class="line"><a name="l02003"></a><span class="lineno"> 2003</span>&#160;  <span class="comment">// Build dependence sets and check whether we need a runtime pointer bounds</span></div><div class="line"><a name="l02004"></a><span class="lineno"> 2004</span>&#160;  <span class="comment">// check.</span></div><div class="line"><a name="l02005"></a><span class="lineno"> 2005</span>&#160;  Accesses.buildDependenceSets();</div><div class="line"><a name="l02006"></a><span class="lineno"> 2006</span>&#160;</div><div class="line"><a name="l02007"></a><span class="lineno"> 2007</span>&#160;  <span class="comment">// Find pointers with computable bounds. We are going to use this information</span></div><div class="line"><a name="l02008"></a><span class="lineno"> 2008</span>&#160;  <span class="comment">// to place a runtime bound check.</span></div><div class="line"><a name="l02009"></a><span class="lineno"> 2009</span>&#160;  <span class="keywordtype">bool</span> CanDoRTIfNeeded = Accesses.canCheckPtrAtRT(*PtrRtChecking, PSE-&gt;getSE(),</div><div class="line"><a name="l02010"></a><span class="lineno"> 2010</span>&#160;                                                  TheLoop, SymbolicStrides);</div><div class="line"><a name="l02011"></a><span class="lineno"> 2011</span>&#160;  <span class="keywordflow">if</span> (!CanDoRTIfNeeded) {</div><div class="line"><a name="l02012"></a><span class="lineno"> 2012</span>&#160;    recordAnalysis(<span class="stringliteral">&quot;CantIdentifyArrayBounds&quot;</span>) &lt;&lt; <span class="stringliteral">&quot;cannot identify array bounds&quot;</span>;</div><div class="line"><a name="l02013"></a><span class="lineno"> 2013</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: We can&#39;t vectorize because we can&#39;t find &quot;</span></div><div class="line"><a name="l02014"></a><span class="lineno"> 2014</span>&#160;                      &lt;&lt; <span class="stringliteral">&quot;the array bounds.\n&quot;</span>);</div><div class="line"><a name="l02015"></a><span class="lineno"> 2015</span>&#160;    CanVecMem = <span class="keyword">false</span>;</div><div class="line"><a name="l02016"></a><span class="lineno"> 2016</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l02017"></a><span class="lineno"> 2017</span>&#160;  }</div><div class="line"><a name="l02018"></a><span class="lineno"> 2018</span>&#160;</div><div class="line"><a name="l02019"></a><span class="lineno"> 2019</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l02020"></a><span class="lineno"> 2020</span>&#160;    <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: May be able to perform a memory runtime check if needed.\n&quot;</span>);</div><div class="line"><a name="l02021"></a><span class="lineno"> 2021</span>&#160;</div><div class="line"><a name="l02022"></a><span class="lineno"> 2022</span>&#160;  CanVecMem = <span class="keyword">true</span>;</div><div class="line"><a name="l02023"></a><span class="lineno"> 2023</span>&#160;  <span class="keywordflow">if</span> (Accesses.isDependencyCheckNeeded()) {</div><div class="line"><a name="l02024"></a><span class="lineno"> 2024</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Checking memory dependencies\n&quot;</span>);</div><div class="line"><a name="l02025"></a><span class="lineno"> 2025</span>&#160;    CanVecMem = DepChecker-&gt;areDepsSafe(</div><div class="line"><a name="l02026"></a><span class="lineno"> 2026</span>&#160;        DependentAccesses, Accesses.getDependenciesToCheck(), SymbolicStrides);</div><div class="line"><a name="l02027"></a><span class="lineno"> 2027</span>&#160;    MaxSafeDepDistBytes = DepChecker-&gt;getMaxSafeDepDistBytes();</div><div class="line"><a name="l02028"></a><span class="lineno"> 2028</span>&#160;</div><div class="line"><a name="l02029"></a><span class="lineno"> 2029</span>&#160;    <span class="keywordflow">if</span> (!CanVecMem &amp;&amp; DepChecker-&gt;shouldRetryWithRuntimeCheck()) {</div><div class="line"><a name="l02030"></a><span class="lineno"> 2030</span>&#160;      <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Retrying with memory checks\n&quot;</span>);</div><div class="line"><a name="l02031"></a><span class="lineno"> 2031</span>&#160;</div><div class="line"><a name="l02032"></a><span class="lineno"> 2032</span>&#160;      <span class="comment">// Clear the dependency checks. We assume they are not needed.</span></div><div class="line"><a name="l02033"></a><span class="lineno"> 2033</span>&#160;      Accesses.resetDepChecks(*DepChecker);</div><div class="line"><a name="l02034"></a><span class="lineno"> 2034</span>&#160;</div><div class="line"><a name="l02035"></a><span class="lineno"> 2035</span>&#160;      PtrRtChecking-&gt;reset();</div><div class="line"><a name="l02036"></a><span class="lineno"> 2036</span>&#160;      PtrRtChecking-&gt;Need = <span class="keyword">true</span>;</div><div class="line"><a name="l02037"></a><span class="lineno"> 2037</span>&#160;</div><div class="line"><a name="l02038"></a><span class="lineno"> 2038</span>&#160;      <span class="keyword">auto</span> *SE = PSE-&gt;getSE();</div><div class="line"><a name="l02039"></a><span class="lineno"> 2039</span>&#160;      CanDoRTIfNeeded = Accesses.canCheckPtrAtRT(*PtrRtChecking, SE, TheLoop,</div><div class="line"><a name="l02040"></a><span class="lineno"> 2040</span>&#160;                                                 SymbolicStrides, <span class="keyword">true</span>);</div><div class="line"><a name="l02041"></a><span class="lineno"> 2041</span>&#160;</div><div class="line"><a name="l02042"></a><span class="lineno"> 2042</span>&#160;      <span class="comment">// Check that we found the bounds for the pointer.</span></div><div class="line"><a name="l02043"></a><span class="lineno"> 2043</span>&#160;      <span class="keywordflow">if</span> (!CanDoRTIfNeeded) {</div><div class="line"><a name="l02044"></a><span class="lineno"> 2044</span>&#160;        recordAnalysis(<span class="stringliteral">&quot;CantCheckMemDepsAtRunTime&quot;</span>)</div><div class="line"><a name="l02045"></a><span class="lineno"> 2045</span>&#160;            &lt;&lt; <span class="stringliteral">&quot;cannot check memory dependencies at runtime&quot;</span>;</div><div class="line"><a name="l02046"></a><span class="lineno"> 2046</span>&#160;        <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Can&#39;t vectorize with memory checks\n&quot;</span>);</div><div class="line"><a name="l02047"></a><span class="lineno"> 2047</span>&#160;        CanVecMem = <span class="keyword">false</span>;</div><div class="line"><a name="l02048"></a><span class="lineno"> 2048</span>&#160;        <span class="keywordflow">return</span>;</div><div class="line"><a name="l02049"></a><span class="lineno"> 2049</span>&#160;      }</div><div class="line"><a name="l02050"></a><span class="lineno"> 2050</span>&#160;</div><div class="line"><a name="l02051"></a><span class="lineno"> 2051</span>&#160;      CanVecMem = <span class="keyword">true</span>;</div><div class="line"><a name="l02052"></a><span class="lineno"> 2052</span>&#160;    }</div><div class="line"><a name="l02053"></a><span class="lineno"> 2053</span>&#160;  }</div><div class="line"><a name="l02054"></a><span class="lineno"> 2054</span>&#160;</div><div class="line"><a name="l02055"></a><span class="lineno"> 2055</span>&#160;  <span class="keywordflow">if</span> (HasConvergentOp) {</div><div class="line"><a name="l02056"></a><span class="lineno"> 2056</span>&#160;    recordAnalysis(<span class="stringliteral">&quot;CantInsertRuntimeCheckWithConvergent&quot;</span>)</div><div class="line"><a name="l02057"></a><span class="lineno"> 2057</span>&#160;      &lt;&lt; <span class="stringliteral">&quot;cannot add control dependency to convergent operation&quot;</span>;</div><div class="line"><a name="l02058"></a><span class="lineno"> 2058</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: We can&#39;t vectorize because a runtime check &quot;</span></div><div class="line"><a name="l02059"></a><span class="lineno"> 2059</span>&#160;                         <span class="stringliteral">&quot;would be needed with a convergent operation\n&quot;</span>);</div><div class="line"><a name="l02060"></a><span class="lineno"> 2060</span>&#160;    CanVecMem = <span class="keyword">false</span>;</div><div class="line"><a name="l02061"></a><span class="lineno"> 2061</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l02062"></a><span class="lineno"> 2062</span>&#160;  }</div><div class="line"><a name="l02063"></a><span class="lineno"> 2063</span>&#160;</div><div class="line"><a name="l02064"></a><span class="lineno"> 2064</span>&#160;  <span class="keywordflow">if</span> (CanVecMem)</div><div class="line"><a name="l02065"></a><span class="lineno"> 2065</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l02066"></a><span class="lineno"> 2066</span>&#160;        <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: No unsafe dependent memory operations in loop.  We&quot;</span></div><div class="line"><a name="l02067"></a><span class="lineno"> 2067</span>&#160;               &lt;&lt; (PtrRtChecking-&gt;Need ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot; don&#39;t&quot;</span>)</div><div class="line"><a name="l02068"></a><span class="lineno"> 2068</span>&#160;               &lt;&lt; <span class="stringliteral">&quot; need runtime memory checks.\n&quot;</span>);</div><div class="line"><a name="l02069"></a><span class="lineno"> 2069</span>&#160;  <span class="keywordflow">else</span> {</div><div class="line"><a name="l02070"></a><span class="lineno"> 2070</span>&#160;    recordAnalysis(<span class="stringliteral">&quot;UnsafeMemDep&quot;</span>)</div><div class="line"><a name="l02071"></a><span class="lineno"> 2071</span>&#160;        &lt;&lt; <span class="stringliteral">&quot;unsafe dependent memory operations in loop. Use &quot;</span></div><div class="line"><a name="l02072"></a><span class="lineno"> 2072</span>&#160;           <span class="stringliteral">&quot;#pragma loop distribute(enable) to allow loop distribution &quot;</span></div><div class="line"><a name="l02073"></a><span class="lineno"> 2073</span>&#160;           <span class="stringliteral">&quot;to attempt to isolate the offending operations into a separate &quot;</span></div><div class="line"><a name="l02074"></a><span class="lineno"> 2074</span>&#160;           <span class="stringliteral">&quot;loop&quot;</span>;</div><div class="line"><a name="l02075"></a><span class="lineno"> 2075</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: unsafe dependent memory operations in loop\n&quot;</span>);</div><div class="line"><a name="l02076"></a><span class="lineno"> 2076</span>&#160;  }</div><div class="line"><a name="l02077"></a><span class="lineno"> 2077</span>&#160;}</div><div class="line"><a name="l02078"></a><span class="lineno"> 2078</span>&#160;</div><div class="line"><a name="l02079"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessInfo.html#aa67d22298695c49e80b79cb8a271928b"> 2079</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1LoopAccessInfo.html#aa67d22298695c49e80b79cb8a271928b">LoopAccessInfo::blockNeedsPredication</a>(<a class="code" href="classllvm_1_1BasicBlock.html">BasicBlock</a> *BB, <a class="code" href="classllvm_1_1Loop.html">Loop</a> *TheLoop,</div><div class="line"><a name="l02080"></a><span class="lineno"> 2080</span>&#160;                                           <a class="code" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT)  {</div><div class="line"><a name="l02081"></a><span class="lineno"> 2081</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a04337b572d34ea413c35dbac5d75530b">contains</a>(BB) &amp;&amp; <span class="stringliteral">&quot;Unknown block used&quot;</span>);</div><div class="line"><a name="l02082"></a><span class="lineno"> 2082</span>&#160;</div><div class="line"><a name="l02083"></a><span class="lineno"> 2083</span>&#160;  <span class="comment">// Blocks that do not dominate the latch need predication.</span></div><div class="line"><a name="l02084"></a><span class="lineno"> 2084</span>&#160;  <a class="code" href="classllvm_1_1BasicBlock.html">BasicBlock</a>* Latch = TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a1230fd674d2609b96527fe65eaf40b1b">getLoopLatch</a>();</div><div class="line"><a name="l02085"></a><span class="lineno"> 2085</span>&#160;  <span class="keywordflow">return</span> !DT-&gt;<a class="code" href="classllvm_1_1DominatorTree.html#ac3abe77784353227ce14dc7c5815c141">dominates</a>(BB, Latch);</div><div class="line"><a name="l02086"></a><span class="lineno"> 2086</span>&#160;}</div><div class="line"><a name="l02087"></a><span class="lineno"> 2087</span>&#160;</div><div class="line"><a name="l02088"></a><span class="lineno"> 2088</span>&#160;<a class="code" href="classllvm_1_1OptimizationRemarkAnalysis.html">OptimizationRemarkAnalysis</a> &amp;LoopAccessInfo::recordAnalysis(<a class="code" href="classllvm_1_1StringRef.html">StringRef</a> RemarkName,</div><div class="line"><a name="l02089"></a><span class="lineno"> 2089</span>&#160;                                                           <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>) {</div><div class="line"><a name="l02090"></a><span class="lineno"> 2090</span>&#160;  <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>(!Report &amp;&amp; <span class="stringliteral">&quot;Multiple reports generated&quot;</span>);</div><div class="line"><a name="l02091"></a><span class="lineno"> 2091</span>&#160;</div><div class="line"><a name="l02092"></a><span class="lineno"> 2092</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *CodeRegion = TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>();</div><div class="line"><a name="l02093"></a><span class="lineno"> 2093</span>&#160;  <a class="code" href="classllvm_1_1DebugLoc.html">DebugLoc</a> DL = TheLoop-&gt;<a class="code" href="classllvm_1_1Loop.html#a615131659002c10601eef598d42d025e">getStartLoc</a>();</div><div class="line"><a name="l02094"></a><span class="lineno"> 2094</span>&#160;</div><div class="line"><a name="l02095"></a><span class="lineno"> 2095</span>&#160;  <span class="keywordflow">if</span> (I) {</div><div class="line"><a name="l02096"></a><span class="lineno"> 2096</span>&#160;    CodeRegion = I-&gt;<a class="code" href="classllvm_1_1Instruction.html#a1a7f07aaef6a3bee130bf0e0f0536802">getParent</a>();</div><div class="line"><a name="l02097"></a><span class="lineno"> 2097</span>&#160;    <span class="comment">// If there is no debug location attached to the instruction, revert back to</span></div><div class="line"><a name="l02098"></a><span class="lineno"> 2098</span>&#160;    <span class="comment">// using the loop&#39;s.</span></div><div class="line"><a name="l02099"></a><span class="lineno"> 2099</span>&#160;    <span class="keywordflow">if</span> (I-&gt;<a class="code" href="classllvm_1_1Instruction.html#ab4f3bf98b5054831b608852e33427814">getDebugLoc</a>())</div><div class="line"><a name="l02100"></a><span class="lineno"> 2100</span>&#160;      DL = I-&gt;<a class="code" href="classllvm_1_1Instruction.html#ab4f3bf98b5054831b608852e33427814">getDebugLoc</a>();</div><div class="line"><a name="l02101"></a><span class="lineno"> 2101</span>&#160;  }</div><div class="line"><a name="l02102"></a><span class="lineno"> 2102</span>&#160;</div><div class="line"><a name="l02103"></a><span class="lineno"> 2103</span>&#160;  Report = std::make_unique&lt;OptimizationRemarkAnalysis&gt;(<a class="code" href="LoopAccessAnalysis_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>, RemarkName, DL,</div><div class="line"><a name="l02104"></a><span class="lineno"> 2104</span>&#160;                                                   CodeRegion);</div><div class="line"><a name="l02105"></a><span class="lineno"> 2105</span>&#160;  <span class="keywordflow">return</span> *Report;</div><div class="line"><a name="l02106"></a><span class="lineno"> 2106</span>&#160;}</div><div class="line"><a name="l02107"></a><span class="lineno"> 2107</span>&#160;</div><div class="line"><a name="l02108"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessInfo.html#a24eb2d9c42c36950317f2666255d7535"> 2108</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1LoopAccessInfo.html#a24eb2d9c42c36950317f2666255d7535">LoopAccessInfo::isUniform</a>(<a class="code" href="classllvm_1_1Value.html">Value</a> *V)<span class="keyword"> const </span>{</div><div class="line"><a name="l02109"></a><span class="lineno"> 2109</span>&#160;  <span class="keyword">auto</span> *SE = PSE-&gt;getSE();</div><div class="line"><a name="l02110"></a><span class="lineno"> 2110</span>&#160;  <span class="comment">// Since we rely on SCEV for uniformity, if the type is not SCEVable, it is</span></div><div class="line"><a name="l02111"></a><span class="lineno"> 2111</span>&#160;  <span class="comment">// never considered uniform.</span></div><div class="line"><a name="l02112"></a><span class="lineno"> 2112</span>&#160;  <span class="comment">// TODO: Is this really what we want? Even without FP SCEV, we may want some</span></div><div class="line"><a name="l02113"></a><span class="lineno"> 2113</span>&#160;  <span class="comment">// trivially loop-invariant FP values to be considered uniform.</span></div><div class="line"><a name="l02114"></a><span class="lineno"> 2114</span>&#160;  <span class="keywordflow">if</span> (!SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a6d8769a72303e2b06ef63129cb231855">isSCEVable</a>(V-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()))</div><div class="line"><a name="l02115"></a><span class="lineno"> 2115</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02116"></a><span class="lineno"> 2116</span>&#160;  <span class="keywordflow">return</span> (SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a5a19768af81df7e5fe571bc08dcd48b3">isLoopInvariant</a>(SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49">getSCEV</a>(V), TheLoop));</div><div class="line"><a name="l02117"></a><span class="lineno"> 2117</span>&#160;}</div><div class="line"><a name="l02118"></a><span class="lineno"> 2118</span>&#160;</div><div class="line"><a name="l02119"></a><span class="lineno"> 2119</span>&#160;<span class="comment">// FIXME: this function is currently a duplicate of the one in</span></div><div class="line"><a name="l02120"></a><span class="lineno"> 2120</span>&#160;<span class="comment">// LoopVectorize.cpp.</span></div><div class="line"><a name="l02121"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#a6df4e7db7761942ca740d19fba41b857"> 2121</a></span>&#160;<span class="keyword">static</span> <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="code" href="LoopAccessAnalysis_8cpp.html#a6df4e7db7761942ca740d19fba41b857">getFirstInst</a>(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *FirstInst, <a class="code" href="classllvm_1_1Value.html">Value</a> *V,</div><div class="line"><a name="l02122"></a><span class="lineno"> 2122</span>&#160;                                 <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Loc) {</div><div class="line"><a name="l02123"></a><span class="lineno"> 2123</span>&#160;  <span class="keywordflow">if</span> (FirstInst)</div><div class="line"><a name="l02124"></a><span class="lineno"> 2124</span>&#160;    <span class="keywordflow">return</span> FirstInst;</div><div class="line"><a name="l02125"></a><span class="lineno"> 2125</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *I = dyn_cast&lt;Instruction&gt;(V))</div><div class="line"><a name="l02126"></a><span class="lineno"> 2126</span>&#160;    <span class="keywordflow">return</span> I-&gt;<a class="code" href="classllvm_1_1Instruction.html#a1a7f07aaef6a3bee130bf0e0f0536802">getParent</a>() == Loc-&gt;<a class="code" href="classllvm_1_1Instruction.html#a1a7f07aaef6a3bee130bf0e0f0536802">getParent</a>() ? <a class="code" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a> : <span class="keyword">nullptr</span>;</div><div class="line"><a name="l02127"></a><span class="lineno"> 2127</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div><div class="line"><a name="l02128"></a><span class="lineno"> 2128</span>&#160;}</div><div class="line"><a name="l02129"></a><span class="lineno"> 2129</span>&#160;</div><div class="line"><a name="l02130"></a><span class="lineno"> 2130</span>&#160;<span class="keyword">namespace </span>{</div><div class="line"><a name="l02131"></a><span class="lineno"> 2131</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02132"></a><span class="lineno"> 2132</span>&#160;<span class="comment">/// IR Values for the lower and upper bounds of a pointer evolution.  We</span></div><div class="line"><a name="l02133"></a><span class="lineno"> 2133</span>&#160;<span class="comment">/// need to use value-handles because SCEV expansion can invalidate previously</span></div><div class="line"><a name="l02134"></a><span class="lineno"> 2134</span>&#160;<span class="comment">/// expanded values.  Thus expansion of a pointer can invalidate the bounds for</span></div><div class="line"><a name="l02135"></a><span class="lineno"> 2135</span>&#160;<span class="comment">/// a previous one.</span></div><div class="line"><a name="l02136"></a><span class="lineno"> 2136</span>&#160;<span class="comment"></span><span class="keyword">struct </span>PointerBounds {</div><div class="line"><a name="l02137"></a><span class="lineno"> 2137</span>&#160;  <a class="code" href="classllvm_1_1TrackingVH.html">TrackingVH&lt;Value&gt;</a> Start;</div><div class="line"><a name="l02138"></a><span class="lineno"> 2138</span>&#160;  <a class="code" href="classllvm_1_1TrackingVH.html">TrackingVH&lt;Value&gt;</a> End;</div><div class="line"><a name="l02139"></a><span class="lineno"> 2139</span>&#160;};</div><div class="line"><a name="l02140"></a><span class="lineno"> 2140</span>&#160;</div><div class="line"><a name="l02141"></a><span class="lineno"> 2141</span>&#160;} <span class="comment">// end anonymous namespace</span></div><div class="line"><a name="l02142"></a><span class="lineno"> 2142</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02143"></a><span class="lineno"> 2143</span>&#160;<span class="comment">/// Expand code for the lower and upper bound of the pointer group \p CG</span></div><div class="line"><a name="l02144"></a><span class="lineno"> 2144</span>&#160;<span class="comment">/// in \p TheLoop.  \return the values for the bounds.</span></div><div class="line"><a name="l02145"></a><span class="lineno"> 2145</span>&#160;<span class="comment"></span><span class="keyword">static</span> PointerBounds</div><div class="line"><a name="l02146"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#a5bf595721f9dd83efbc1fe6c6ae3c67d"> 2146</a></span>&#160;<a class="code" href="LoopAccessAnalysis_8cpp.html#a5bf595721f9dd83efbc1fe6c6ae3c67d">expandBounds</a>(<span class="keyword">const</span> <a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html">RuntimePointerChecking::CheckingPtrGroup</a> *CG, <a class="code" href="classllvm_1_1Loop.html">Loop</a> *TheLoop,</div><div class="line"><a name="l02147"></a><span class="lineno"> 2147</span>&#160;             <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Loc, <a class="code" href="classllvm_1_1SCEVExpander.html">SCEVExpander</a> &amp;Exp, <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE,</div><div class="line"><a name="l02148"></a><span class="lineno"> 2148</span>&#160;             <span class="keyword">const</span> <a class="code" href="classllvm_1_1RuntimePointerChecking.html">RuntimePointerChecking</a> &amp;PtrRtChecking) {</div><div class="line"><a name="l02149"></a><span class="lineno"> 2149</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr = PtrRtChecking.<a class="code" href="classllvm_1_1RuntimePointerChecking.html#aa6ad96a1c2591e0a61c92e0be5776978">Pointers</a>[CG-&gt;<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a90bc32387fd6351a131d06f1e0ed4a37">Members</a>[0]].PointerValue;</div><div class="line"><a name="l02150"></a><span class="lineno"> 2150</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *Sc = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49">getSCEV</a>(Ptr);</div><div class="line"><a name="l02151"></a><span class="lineno"> 2151</span>&#160;</div><div class="line"><a name="l02152"></a><span class="lineno"> 2152</span>&#160;  <span class="keywordtype">unsigned</span> AS = Ptr-&gt;<a class="code" href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">getType</a>()-&gt;<a class="code" href="classllvm_1_1Type.html#a5ab2d0b0f0b8ceec3b907184e7567197">getPointerAddressSpace</a>();</div><div class="line"><a name="l02153"></a><span class="lineno"> 2153</span>&#160;  <a class="code" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;Ctx = Loc-&gt;<a class="code" href="classllvm_1_1Value.html#ab3fc0225d8aaf8434026c3573f961f2c">getContext</a>();</div><div class="line"><a name="l02154"></a><span class="lineno"> 2154</span>&#160;</div><div class="line"><a name="l02155"></a><span class="lineno"> 2155</span>&#160;  <span class="comment">// Use this type for pointer arithmetic.</span></div><div class="line"><a name="l02156"></a><span class="lineno"> 2156</span>&#160;  <a class="code" href="classllvm_1_1Type.html">Type</a> *PtrArithTy = <a class="code" href="classllvm_1_1Type.html#a7fe9ccd4893f4e2caa826126c09545ea">Type::getInt8PtrTy</a>(Ctx, AS);</div><div class="line"><a name="l02157"></a><span class="lineno"> 2157</span>&#160;</div><div class="line"><a name="l02158"></a><span class="lineno"> 2158</span>&#160;  <span class="keywordflow">if</span> (SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a5a19768af81df7e5fe571bc08dcd48b3">isLoopInvariant</a>(Sc, TheLoop)) {</div><div class="line"><a name="l02159"></a><span class="lineno"> 2159</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Adding RT check for a loop invariant ptr:&quot;</span></div><div class="line"><a name="l02160"></a><span class="lineno"> 2160</span>&#160;                      &lt;&lt; *Ptr &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02161"></a><span class="lineno"> 2161</span>&#160;    <span class="comment">// Ptr could be in the loop body. If so, expand a new one at the correct</span></div><div class="line"><a name="l02162"></a><span class="lineno"> 2162</span>&#160;    <span class="comment">// location.</span></div><div class="line"><a name="l02163"></a><span class="lineno"> 2163</span>&#160;    <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Inst = <a class="code" href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">dyn_cast</a>&lt;<a class="code" href="classllvm_1_1Instruction.html">Instruction</a>&gt;(Ptr);</div><div class="line"><a name="l02164"></a><span class="lineno"> 2164</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *NewPtr = (Inst &amp;&amp; TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a04337b572d34ea413c35dbac5d75530b">contains</a>(Inst))</div><div class="line"><a name="l02165"></a><span class="lineno"> 2165</span>&#160;                        ? Exp.<a class="code" href="classllvm_1_1SCEVExpander.html#a583d3ca95f83216d632a4d1ae0330dd0">expandCodeFor</a>(Sc, PtrArithTy, Loc)</div><div class="line"><a name="l02166"></a><span class="lineno"> 2166</span>&#160;                        : Ptr;</div><div class="line"><a name="l02167"></a><span class="lineno"> 2167</span>&#160;    <span class="comment">// We must return a half-open range, which means incrementing Sc.</span></div><div class="line"><a name="l02168"></a><span class="lineno"> 2168</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *ScPlusOne = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a83f34da3409085dd69e2da4a7f85e0f7">getAddExpr</a>(Sc, SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#ac93dd46031b1e2f9fdb0cee7a99681df">getOne</a>(PtrArithTy));</div><div class="line"><a name="l02169"></a><span class="lineno"> 2169</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *NewPtrPlusOne = Exp.<a class="code" href="classllvm_1_1SCEVExpander.html#a583d3ca95f83216d632a4d1ae0330dd0">expandCodeFor</a>(ScPlusOne, PtrArithTy, Loc);</div><div class="line"><a name="l02170"></a><span class="lineno"> 2170</span>&#160;    <span class="keywordflow">return</span> {NewPtr, NewPtrPlusOne};</div><div class="line"><a name="l02171"></a><span class="lineno"> 2171</span>&#160;  } <span class="keywordflow">else</span> {</div><div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Start = <span class="keyword">nullptr</span>, *End = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Adding RT check for range:\n&quot;</span>);</div><div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;    Start = Exp.<a class="code" href="classllvm_1_1SCEVExpander.html#a583d3ca95f83216d632a4d1ae0330dd0">expandCodeFor</a>(CG-&gt;<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a4e3c156ce6fa692f3528dfa3e660ecb2">Low</a>, PtrArithTy, Loc);</div><div class="line"><a name="l02175"></a><span class="lineno"> 2175</span>&#160;    End = Exp.<a class="code" href="classllvm_1_1SCEVExpander.html#a583d3ca95f83216d632a4d1ae0330dd0">expandCodeFor</a>(CG-&gt;<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a205c1f26515d92ec84b40be256bcba08">High</a>, PtrArithTy, Loc);</div><div class="line"><a name="l02176"></a><span class="lineno"> 2176</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;Start: &quot;</span> &lt;&lt; *CG-&gt;<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a4e3c156ce6fa692f3528dfa3e660ecb2">Low</a> &lt;&lt; <span class="stringliteral">&quot; End: &quot;</span> &lt;&lt; *CG-&gt;<a class="code" href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a205c1f26515d92ec84b40be256bcba08">High</a></div><div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;                      &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;    <span class="keywordflow">return</span> {Start, End};</div><div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;  }</div><div class="line"><a name="l02180"></a><span class="lineno"> 2180</span>&#160;}</div><div class="line"><a name="l02181"></a><span class="lineno"> 2181</span>&#160;<span class="comment"></span></div><div class="line"><a name="l02182"></a><span class="lineno"> 2182</span>&#160;<span class="comment">/// Turns a collection of checks into a collection of expanded upper and</span></div><div class="line"><a name="l02183"></a><span class="lineno"> 2183</span>&#160;<span class="comment">/// lower bounds for both pointers in the check.</span></div><div class="line"><a name="l02184"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#af99fa1b4b882efdad390ff043993cf24"> 2184</a></span>&#160;<span class="comment"></span><span class="keyword">static</span> <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;std::pair&lt;PointerBounds, PointerBounds&gt;</a>, 4&gt; <a class="code" href="LoopAccessAnalysis_8cpp.html#a5bf595721f9dd83efbc1fe6c6ae3c67d">expandBounds</a>(</div><div class="line"><a name="l02185"></a><span class="lineno"> 2185</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;RuntimePointerChecking::PointerCheck&gt;</a> &amp;PointerChecks,</div><div class="line"><a name="l02186"></a><span class="lineno"> 2186</span>&#160;    <a class="code" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Loc, <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE, <a class="code" href="classllvm_1_1SCEVExpander.html">SCEVExpander</a> &amp;Exp,</div><div class="line"><a name="l02187"></a><span class="lineno"> 2187</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1RuntimePointerChecking.html">RuntimePointerChecking</a> &amp;PtrRtChecking) {</div><div class="line"><a name="l02188"></a><span class="lineno"> 2188</span>&#160;  <a class="code" href="classllvm_1_1SmallVector.html">SmallVector&lt;std::pair&lt;PointerBounds, PointerBounds&gt;</a>, 4&gt; ChecksWithBounds;</div><div class="line"><a name="l02189"></a><span class="lineno"> 2189</span>&#160;</div><div class="line"><a name="l02190"></a><span class="lineno"> 2190</span>&#160;  <span class="comment">// Here we&#39;re relying on the SCEV Expander&#39;s cache to only emit code for the</span></div><div class="line"><a name="l02191"></a><span class="lineno"> 2191</span>&#160;  <span class="comment">// same bounds once.</span></div><div class="line"><a name="l02192"></a><span class="lineno"> 2192</span>&#160;  <a class="code" href="namespacellvm.html#a0d9313480c51aa626d0ce527b45471e3">transform</a>(</div><div class="line"><a name="l02193"></a><span class="lineno"> 2193</span>&#160;      PointerChecks, std::back_inserter(ChecksWithBounds),</div><div class="line"><a name="l02194"></a><span class="lineno"> 2194</span>&#160;      [&amp;](<span class="keyword">const</span> <a class="code" href="classllvm_1_1RuntimePointerChecking.html#a4f9b2d55586e573727e97cd51a3e0a9a">RuntimePointerChecking::PointerCheck</a> &amp;<a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a>) {</div><div class="line"><a name="l02195"></a><span class="lineno"> 2195</span>&#160;        PointerBounds</div><div class="line"><a name="l02196"></a><span class="lineno"> 2196</span>&#160;          First = <a class="code" href="LoopAccessAnalysis_8cpp.html#a5bf595721f9dd83efbc1fe6c6ae3c67d">expandBounds</a>(Check.first, L, Loc, Exp, SE, PtrRtChecking),</div><div class="line"><a name="l02197"></a><span class="lineno"> 2197</span>&#160;          Second = <a class="code" href="LoopAccessAnalysis_8cpp.html#a5bf595721f9dd83efbc1fe6c6ae3c67d">expandBounds</a>(Check.second, L, Loc, Exp, SE, PtrRtChecking);</div><div class="line"><a name="l02198"></a><span class="lineno"> 2198</span>&#160;        <span class="keywordflow">return</span> std::make_pair(First, Second);</div><div class="line"><a name="l02199"></a><span class="lineno"> 2199</span>&#160;      });</div><div class="line"><a name="l02200"></a><span class="lineno"> 2200</span>&#160;</div><div class="line"><a name="l02201"></a><span class="lineno"> 2201</span>&#160;  <span class="keywordflow">return</span> ChecksWithBounds;</div><div class="line"><a name="l02202"></a><span class="lineno"> 2202</span>&#160;}</div><div class="line"><a name="l02203"></a><span class="lineno"> 2203</span>&#160;</div><div class="line"><a name="l02204"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessInfo.html#aeca7f29168d0664cabfe8bd6a986fcb4"> 2204</a></span>&#160;std::pair&lt;Instruction *, Instruction *&gt; <a class="code" href="classllvm_1_1LoopAccessInfo.html#a84a5de37c9e2f182943639f92cf684b7">LoopAccessInfo::addRuntimeChecks</a>(</div><div class="line"><a name="l02205"></a><span class="lineno"> 2205</span>&#160;    <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Loc,</div><div class="line"><a name="l02206"></a><span class="lineno"> 2206</span>&#160;    <span class="keyword">const</span> <a class="code" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl&lt;RuntimePointerChecking::PointerCheck&gt;</a> &amp;PointerChecks)<span class="keyword"></span></div><div class="line"><a name="l02207"></a><span class="lineno"> 2207</span>&#160;<span class="keyword">    const </span>{</div><div class="line"><a name="l02208"></a><span class="lineno"> 2208</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL = TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>()-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#afc70e919c88c86159cc94cea29b6c210">getModule</a>()-&gt;<a class="code" href="classllvm_1_1Module.html#a6d883605206368bc536cc9ded97209b8">getDataLayout</a>();</div><div class="line"><a name="l02209"></a><span class="lineno"> 2209</span>&#160;  <span class="keyword">auto</span> *SE = PSE-&gt;getSE();</div><div class="line"><a name="l02210"></a><span class="lineno"> 2210</span>&#160;  <a class="code" href="classllvm_1_1SCEVExpander.html">SCEVExpander</a> Exp(*SE, DL, <span class="stringliteral">&quot;induction&quot;</span>);</div><div class="line"><a name="l02211"></a><span class="lineno"> 2211</span>&#160;  <span class="keyword">auto</span> ExpandedChecks =</div><div class="line"><a name="l02212"></a><span class="lineno"> 2212</span>&#160;      <a class="code" href="LoopAccessAnalysis_8cpp.html#a5bf595721f9dd83efbc1fe6c6ae3c67d">expandBounds</a>(PointerChecks, TheLoop, Loc, SE, Exp, *PtrRtChecking);</div><div class="line"><a name="l02213"></a><span class="lineno"> 2213</span>&#160;</div><div class="line"><a name="l02214"></a><span class="lineno"> 2214</span>&#160;  <a class="code" href="classllvm_1_1LLVMContext.html">LLVMContext</a> &amp;Ctx = Loc-&gt;<a class="code" href="classllvm_1_1Value.html#ab3fc0225d8aaf8434026c3573f961f2c">getContext</a>();</div><div class="line"><a name="l02215"></a><span class="lineno"> 2215</span>&#160;  <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *FirstInst = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l02216"></a><span class="lineno"> 2216</span>&#160;  <a class="code" href="classllvm_1_1IRBuilder.html">IRBuilder&lt;&gt;</a> ChkBuilder(Loc);</div><div class="line"><a name="l02217"></a><span class="lineno"> 2217</span>&#160;  <span class="comment">// Our instructions might fold to a constant.</span></div><div class="line"><a name="l02218"></a><span class="lineno"> 2218</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *MemoryRuntimeCheck = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l02219"></a><span class="lineno"> 2219</span>&#160;</div><div class="line"><a name="l02220"></a><span class="lineno"> 2220</span>&#160;  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a> : ExpandedChecks) {</div><div class="line"><a name="l02221"></a><span class="lineno"> 2221</span>&#160;    <span class="keyword">const</span> PointerBounds &amp;A = <a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a>.first, &amp;B = <a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a>.second;</div><div class="line"><a name="l02222"></a><span class="lineno"> 2222</span>&#160;    <span class="comment">// Check if two pointers (A and B) conflict where conflict is computed as:</span></div><div class="line"><a name="l02223"></a><span class="lineno"> 2223</span>&#160;    <span class="comment">// start(A) &lt;= end(B) &amp;&amp; start(B) &lt;= end(A)</span></div><div class="line"><a name="l02224"></a><span class="lineno"> 2224</span>&#160;    <span class="keywordtype">unsigned</span> AS0 = A.Start-&gt;getType()-&gt;getPointerAddressSpace();</div><div class="line"><a name="l02225"></a><span class="lineno"> 2225</span>&#160;    <span class="keywordtype">unsigned</span> AS1 = B.Start-&gt;getType()-&gt;getPointerAddressSpace();</div><div class="line"><a name="l02226"></a><span class="lineno"> 2226</span>&#160;</div><div class="line"><a name="l02227"></a><span class="lineno"> 2227</span>&#160;    <a class="code" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a>((AS0 == B.End-&gt;getType()-&gt;getPointerAddressSpace()) &amp;&amp;</div><div class="line"><a name="l02228"></a><span class="lineno"> 2228</span>&#160;           (AS1 == A.End-&gt;getType()-&gt;getPointerAddressSpace()) &amp;&amp;</div><div class="line"><a name="l02229"></a><span class="lineno"> 2229</span>&#160;           <span class="stringliteral">&quot;Trying to bounds check pointers with different address spaces&quot;</span>);</div><div class="line"><a name="l02230"></a><span class="lineno"> 2230</span>&#160;</div><div class="line"><a name="l02231"></a><span class="lineno"> 2231</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *PtrArithTy0 = <a class="code" href="classllvm_1_1Type.html#a7fe9ccd4893f4e2caa826126c09545ea">Type::getInt8PtrTy</a>(Ctx, AS0);</div><div class="line"><a name="l02232"></a><span class="lineno"> 2232</span>&#160;    <a class="code" href="classllvm_1_1Type.html">Type</a> *PtrArithTy1 = <a class="code" href="classllvm_1_1Type.html#a7fe9ccd4893f4e2caa826126c09545ea">Type::getInt8PtrTy</a>(Ctx, AS1);</div><div class="line"><a name="l02233"></a><span class="lineno"> 2233</span>&#160;</div><div class="line"><a name="l02234"></a><span class="lineno"> 2234</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Start0 = ChkBuilder.<a class="code" href="classllvm_1_1IRBuilder.html#a5e3bfda687f0bb870891d2b7722e7c2a">CreateBitCast</a>(A.Start, PtrArithTy0, <span class="stringliteral">&quot;bc&quot;</span>);</div><div class="line"><a name="l02235"></a><span class="lineno"> 2235</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Start1 = ChkBuilder.<a class="code" href="classllvm_1_1IRBuilder.html#a5e3bfda687f0bb870891d2b7722e7c2a">CreateBitCast</a>(B.Start, PtrArithTy1, <span class="stringliteral">&quot;bc&quot;</span>);</div><div class="line"><a name="l02236"></a><span class="lineno"> 2236</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *End0 =   ChkBuilder.<a class="code" href="classllvm_1_1IRBuilder.html#a5e3bfda687f0bb870891d2b7722e7c2a">CreateBitCast</a>(A.End,   PtrArithTy1, <span class="stringliteral">&quot;bc&quot;</span>);</div><div class="line"><a name="l02237"></a><span class="lineno"> 2237</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *End1 =   ChkBuilder.<a class="code" href="classllvm_1_1IRBuilder.html#a5e3bfda687f0bb870891d2b7722e7c2a">CreateBitCast</a>(B.End,   PtrArithTy0, <span class="stringliteral">&quot;bc&quot;</span>);</div><div class="line"><a name="l02238"></a><span class="lineno"> 2238</span>&#160;</div><div class="line"><a name="l02239"></a><span class="lineno"> 2239</span>&#160;    <span class="comment">// [A|B].Start points to the first accessed byte under base [A|B].</span></div><div class="line"><a name="l02240"></a><span class="lineno"> 2240</span>&#160;    <span class="comment">// [A|B].End points to the last accessed byte, plus one.</span></div><div class="line"><a name="l02241"></a><span class="lineno"> 2241</span>&#160;    <span class="comment">// There is no conflict when the intervals are disjoint:</span></div><div class="line"><a name="l02242"></a><span class="lineno"> 2242</span>&#160;    <span class="comment">// NoConflict = (B.Start &gt;= A.End) || (A.Start &gt;= B.End)</span></div><div class="line"><a name="l02243"></a><span class="lineno"> 2243</span>&#160;    <span class="comment">//</span></div><div class="line"><a name="l02244"></a><span class="lineno"> 2244</span>&#160;    <span class="comment">// bound0 = (B.Start &lt; A.End)</span></div><div class="line"><a name="l02245"></a><span class="lineno"> 2245</span>&#160;    <span class="comment">// bound1 = (A.Start &lt; B.End)</span></div><div class="line"><a name="l02246"></a><span class="lineno"> 2246</span>&#160;    <span class="comment">//  IsConflict = bound0 &amp; bound1</span></div><div class="line"><a name="l02247"></a><span class="lineno"> 2247</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Cmp0 = ChkBuilder.<a class="code" href="classllvm_1_1IRBuilder.html#abf9ca7cf5cdb2219a9daea23be036e4e">CreateICmpULT</a>(Start0, End1, <span class="stringliteral">&quot;bound0&quot;</span>);</div><div class="line"><a name="l02248"></a><span class="lineno"> 2248</span>&#160;    FirstInst = <a class="code" href="LoopAccessAnalysis_8cpp.html#a6df4e7db7761942ca740d19fba41b857">getFirstInst</a>(FirstInst, Cmp0, Loc);</div><div class="line"><a name="l02249"></a><span class="lineno"> 2249</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *Cmp1 = ChkBuilder.<a class="code" href="classllvm_1_1IRBuilder.html#abf9ca7cf5cdb2219a9daea23be036e4e">CreateICmpULT</a>(Start1, End0, <span class="stringliteral">&quot;bound1&quot;</span>);</div><div class="line"><a name="l02250"></a><span class="lineno"> 2250</span>&#160;    FirstInst = <a class="code" href="LoopAccessAnalysis_8cpp.html#a6df4e7db7761942ca740d19fba41b857">getFirstInst</a>(FirstInst, Cmp1, Loc);</div><div class="line"><a name="l02251"></a><span class="lineno"> 2251</span>&#160;    <a class="code" href="classllvm_1_1Value.html">Value</a> *IsConflict = ChkBuilder.<a class="code" href="classllvm_1_1IRBuilder.html#a840336af9ba351eb8c51640544519d64">CreateAnd</a>(Cmp0, Cmp1, <span class="stringliteral">&quot;found.conflict&quot;</span>);</div><div class="line"><a name="l02252"></a><span class="lineno"> 2252</span>&#160;    FirstInst = <a class="code" href="LoopAccessAnalysis_8cpp.html#a6df4e7db7761942ca740d19fba41b857">getFirstInst</a>(FirstInst, IsConflict, Loc);</div><div class="line"><a name="l02253"></a><span class="lineno"> 2253</span>&#160;    <span class="keywordflow">if</span> (MemoryRuntimeCheck) {</div><div class="line"><a name="l02254"></a><span class="lineno"> 2254</span>&#160;      IsConflict =</div><div class="line"><a name="l02255"></a><span class="lineno"> 2255</span>&#160;          ChkBuilder.<a class="code" href="classllvm_1_1IRBuilder.html#ab1475cfd218c3655256eec53a9d6b1dd">CreateOr</a>(MemoryRuntimeCheck, IsConflict, <span class="stringliteral">&quot;conflict.rdx&quot;</span>);</div><div class="line"><a name="l02256"></a><span class="lineno"> 2256</span>&#160;      FirstInst = <a class="code" href="LoopAccessAnalysis_8cpp.html#a6df4e7db7761942ca740d19fba41b857">getFirstInst</a>(FirstInst, IsConflict, Loc);</div><div class="line"><a name="l02257"></a><span class="lineno"> 2257</span>&#160;    }</div><div class="line"><a name="l02258"></a><span class="lineno"> 2258</span>&#160;    MemoryRuntimeCheck = IsConflict;</div><div class="line"><a name="l02259"></a><span class="lineno"> 2259</span>&#160;  }</div><div class="line"><a name="l02260"></a><span class="lineno"> 2260</span>&#160;</div><div class="line"><a name="l02261"></a><span class="lineno"> 2261</span>&#160;  <span class="keywordflow">if</span> (!MemoryRuntimeCheck)</div><div class="line"><a name="l02262"></a><span class="lineno"> 2262</span>&#160;    <span class="keywordflow">return</span> std::make_pair(<span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div><div class="line"><a name="l02263"></a><span class="lineno"> 2263</span>&#160;</div><div class="line"><a name="l02264"></a><span class="lineno"> 2264</span>&#160;  <span class="comment">// We have to do this trickery because the IRBuilder might fold the check to a</span></div><div class="line"><a name="l02265"></a><span class="lineno"> 2265</span>&#160;  <span class="comment">// constant expression in which case there is no Instruction anchored in a</span></div><div class="line"><a name="l02266"></a><span class="lineno"> 2266</span>&#160;  <span class="comment">// the block.</span></div><div class="line"><a name="l02267"></a><span class="lineno"> 2267</span>&#160;  <a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="code" href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a> = BinaryOperator::CreateAnd(MemoryRuntimeCheck,</div><div class="line"><a name="l02268"></a><span class="lineno"> 2268</span>&#160;                                                 <a class="code" href="classllvm_1_1ConstantInt.html#a82dbbd8e3688b0bc1eedb338864d0d0c">ConstantInt::getTrue</a>(Ctx));</div><div class="line"><a name="l02269"></a><span class="lineno"> 2269</span>&#160;  ChkBuilder.<a class="code" href="classllvm_1_1IRBuilder.html#a9ec80ec33e99e7b6b459a4b2e4cb5e0a">Insert</a>(Check, <span class="stringliteral">&quot;memcheck.conflict&quot;</span>);</div><div class="line"><a name="l02270"></a><span class="lineno"> 2270</span>&#160;  FirstInst = <a class="code" href="LoopAccessAnalysis_8cpp.html#a6df4e7db7761942ca740d19fba41b857">getFirstInst</a>(FirstInst, Check, Loc);</div><div class="line"><a name="l02271"></a><span class="lineno"> 2271</span>&#160;  <span class="keywordflow">return</span> std::make_pair(FirstInst, Check);</div><div class="line"><a name="l02272"></a><span class="lineno"> 2272</span>&#160;}</div><div class="line"><a name="l02273"></a><span class="lineno"> 2273</span>&#160;</div><div class="line"><a name="l02274"></a><span class="lineno"> 2274</span>&#160;std::pair&lt;Instruction *, Instruction *&gt;</div><div class="line"><a name="l02275"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessInfo.html#a84a5de37c9e2f182943639f92cf684b7"> 2275</a></span>&#160;<a class="code" href="classllvm_1_1LoopAccessInfo.html#a84a5de37c9e2f182943639f92cf684b7">LoopAccessInfo::addRuntimeChecks</a>(<a class="code" href="classllvm_1_1Instruction.html">Instruction</a> *Loc)<span class="keyword"> const </span>{</div><div class="line"><a name="l02276"></a><span class="lineno"> 2276</span>&#160;  <span class="keywordflow">if</span> (!PtrRtChecking-&gt;Need)</div><div class="line"><a name="l02277"></a><span class="lineno"> 2277</span>&#160;    <span class="keywordflow">return</span> std::make_pair(<span class="keyword">nullptr</span>, <span class="keyword">nullptr</span>);</div><div class="line"><a name="l02278"></a><span class="lineno"> 2278</span>&#160;</div><div class="line"><a name="l02279"></a><span class="lineno"> 2279</span>&#160;  <span class="keywordflow">return</span> addRuntimeChecks(Loc, PtrRtChecking-&gt;getChecks());</div><div class="line"><a name="l02280"></a><span class="lineno"> 2280</span>&#160;}</div><div class="line"><a name="l02281"></a><span class="lineno"> 2281</span>&#160;</div><div class="line"><a name="l02282"></a><span class="lineno"> 2282</span>&#160;<span class="keywordtype">void</span> LoopAccessInfo::collectStridedAccess(<a class="code" href="classllvm_1_1Value.html">Value</a> *MemAccess) {</div><div class="line"><a name="l02283"></a><span class="lineno"> 2283</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *Ptr = <span class="keyword">nullptr</span>;</div><div class="line"><a name="l02284"></a><span class="lineno"> 2284</span>&#160;  <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1LoadInst.html">LoadInst</a> *LI = dyn_cast&lt;LoadInst&gt;(MemAccess))</div><div class="line"><a name="l02285"></a><span class="lineno"> 2285</span>&#160;    Ptr = LI-&gt;getPointerOperand();</div><div class="line"><a name="l02286"></a><span class="lineno"> 2286</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="classllvm_1_1StoreInst.html">StoreInst</a> *<a class="code" href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a> = dyn_cast&lt;StoreInst&gt;(MemAccess))</div><div class="line"><a name="l02287"></a><span class="lineno"> 2287</span>&#160;    Ptr = <a class="code" href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a>-&gt;getPointerOperand();</div><div class="line"><a name="l02288"></a><span class="lineno"> 2288</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l02289"></a><span class="lineno"> 2289</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l02290"></a><span class="lineno"> 2290</span>&#160;</div><div class="line"><a name="l02291"></a><span class="lineno"> 2291</span>&#160;  <a class="code" href="classllvm_1_1Value.html">Value</a> *Stride = <a class="code" href="namespacellvm.html#a611d9f877de3e9402bd8f56fb10ec5a1">getStrideFromPointer</a>(Ptr, PSE-&gt;getSE(), TheLoop);</div><div class="line"><a name="l02292"></a><span class="lineno"> 2292</span>&#160;  <span class="keywordflow">if</span> (!Stride)</div><div class="line"><a name="l02293"></a><span class="lineno"> 2293</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l02294"></a><span class="lineno"> 2294</span>&#160;</div><div class="line"><a name="l02295"></a><span class="lineno"> 2295</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Found a strided access that is a candidate for &quot;</span></div><div class="line"><a name="l02296"></a><span class="lineno"> 2296</span>&#160;                       <span class="stringliteral">&quot;versioning:&quot;</span>);</div><div class="line"><a name="l02297"></a><span class="lineno"> 2297</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;  Ptr: &quot;</span> &lt;&lt; *Ptr &lt;&lt; <span class="stringliteral">&quot; Stride: &quot;</span> &lt;&lt; *Stride &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>);</div><div class="line"><a name="l02298"></a><span class="lineno"> 2298</span>&#160;</div><div class="line"><a name="l02299"></a><span class="lineno"> 2299</span>&#160;  <span class="comment">// Avoid adding the &quot;Stride == 1&quot; predicate when we know that</span></div><div class="line"><a name="l02300"></a><span class="lineno"> 2300</span>&#160;  <span class="comment">// Stride &gt;= Trip-Count. Such a predicate will effectively optimize a single</span></div><div class="line"><a name="l02301"></a><span class="lineno"> 2301</span>&#160;  <span class="comment">// or zero iteration loop, as Trip-Count &lt;= Stride == 1.</span></div><div class="line"><a name="l02302"></a><span class="lineno"> 2302</span>&#160;  <span class="comment">//</span></div><div class="line"><a name="l02303"></a><span class="lineno"> 2303</span>&#160;  <span class="comment">// TODO: We are currently not making a very informed decision on when it is</span></div><div class="line"><a name="l02304"></a><span class="lineno"> 2304</span>&#160;  <span class="comment">// beneficial to apply stride versioning. It might make more sense that the</span></div><div class="line"><a name="l02305"></a><span class="lineno"> 2305</span>&#160;  <span class="comment">// users of this analysis (such as the vectorizer) will trigger it, based on</span></div><div class="line"><a name="l02306"></a><span class="lineno"> 2306</span>&#160;  <span class="comment">// their specific cost considerations; For example, in cases where stride</span></div><div class="line"><a name="l02307"></a><span class="lineno"> 2307</span>&#160;  <span class="comment">// versioning does  not help resolving memory accesses/dependences, the</span></div><div class="line"><a name="l02308"></a><span class="lineno"> 2308</span>&#160;  <span class="comment">// vectorizer should evaluate the cost of the runtime test, and the benefit</span></div><div class="line"><a name="l02309"></a><span class="lineno"> 2309</span>&#160;  <span class="comment">// of various possible stride specializations, considering the alternatives</span></div><div class="line"><a name="l02310"></a><span class="lineno"> 2310</span>&#160;  <span class="comment">// of using gather/scatters (if available).</span></div><div class="line"><a name="l02311"></a><span class="lineno"> 2311</span>&#160;</div><div class="line"><a name="l02312"></a><span class="lineno"> 2312</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *StrideExpr = PSE-&gt;getSCEV(Stride);</div><div class="line"><a name="l02313"></a><span class="lineno"> 2313</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *BETakenCount = PSE-&gt;getBackedgeTakenCount();</div><div class="line"><a name="l02314"></a><span class="lineno"> 2314</span>&#160;</div><div class="line"><a name="l02315"></a><span class="lineno"> 2315</span>&#160;  <span class="comment">// Match the types so we can compare the stride and the BETakenCount.</span></div><div class="line"><a name="l02316"></a><span class="lineno"> 2316</span>&#160;  <span class="comment">// The Stride can be positive/negative, so we sign extend Stride;</span></div><div class="line"><a name="l02317"></a><span class="lineno"> 2317</span>&#160;  <span class="comment">// The backedgeTakenCount is non-negative, so we zero extend BETakenCount.</span></div><div class="line"><a name="l02318"></a><span class="lineno"> 2318</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL = TheLoop-&gt;<a class="code" href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">getHeader</a>()-&gt;<a class="code" href="classllvm_1_1BasicBlock.html#afc70e919c88c86159cc94cea29b6c210">getModule</a>()-&gt;<a class="code" href="classllvm_1_1Module.html#a6d883605206368bc536cc9ded97209b8">getDataLayout</a>();</div><div class="line"><a name="l02319"></a><span class="lineno"> 2319</span>&#160;  uint64_t StrideTypeSize = DL.<a class="code" href="classllvm_1_1DataLayout.html#aa48b3b7e554b44f4e513d5dd8d9f9343">getTypeAllocSize</a>(StrideExpr-&gt;<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>());</div><div class="line"><a name="l02320"></a><span class="lineno"> 2320</span>&#160;  uint64_t BETypeSize = DL.<a class="code" href="classllvm_1_1DataLayout.html#aa48b3b7e554b44f4e513d5dd8d9f9343">getTypeAllocSize</a>(BETakenCount-&gt;<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>());</div><div class="line"><a name="l02321"></a><span class="lineno"> 2321</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *CastedStride = StrideExpr;</div><div class="line"><a name="l02322"></a><span class="lineno"> 2322</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *CastedBECount = BETakenCount;</div><div class="line"><a name="l02323"></a><span class="lineno"> 2323</span>&#160;  <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE = PSE-&gt;getSE();</div><div class="line"><a name="l02324"></a><span class="lineno"> 2324</span>&#160;  <span class="keywordflow">if</span> (BETypeSize &gt;= StrideTypeSize)</div><div class="line"><a name="l02325"></a><span class="lineno"> 2325</span>&#160;    CastedStride = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a38c440751f1bf5f19bc12b95f8f0f2a6">getNoopOrSignExtend</a>(StrideExpr, BETakenCount-&gt;<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>());</div><div class="line"><a name="l02326"></a><span class="lineno"> 2326</span>&#160;  <span class="keywordflow">else</span></div><div class="line"><a name="l02327"></a><span class="lineno"> 2327</span>&#160;    CastedBECount = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a6d745b25efdc69435508f1e936919f8b">getZeroExtendExpr</a>(BETakenCount, StrideExpr-&gt;<a class="code" href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">getType</a>());</div><div class="line"><a name="l02328"></a><span class="lineno"> 2328</span>&#160;  <span class="keyword">const</span> <a class="code" href="classllvm_1_1SCEV.html">SCEV</a> *StrideMinusBETaken = SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a8bcb86d8d126d95b0dc05f09e8f3df96">getMinusSCEV</a>(CastedStride, CastedBECount);</div><div class="line"><a name="l02329"></a><span class="lineno"> 2329</span>&#160;  <span class="comment">// Since TripCount == BackEdgeTakenCount + 1, checking:</span></div><div class="line"><a name="l02330"></a><span class="lineno"> 2330</span>&#160;  <span class="comment">// &quot;Stride &gt;= TripCount&quot; is equivalent to checking:</span></div><div class="line"><a name="l02331"></a><span class="lineno"> 2331</span>&#160;  <span class="comment">// Stride - BETakenCount &gt; 0</span></div><div class="line"><a name="l02332"></a><span class="lineno"> 2332</span>&#160;  <span class="keywordflow">if</span> (SE-&gt;<a class="code" href="classllvm_1_1ScalarEvolution.html#a5a672708a81ae8da8fb56e32638ca9b3">isKnownPositive</a>(StrideMinusBETaken)) {</div><div class="line"><a name="l02333"></a><span class="lineno"> 2333</span>&#160;    <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(</div><div class="line"><a name="l02334"></a><span class="lineno"> 2334</span>&#160;        <a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Stride&gt;=TripCount; No point in versioning as the &quot;</span></div><div class="line"><a name="l02335"></a><span class="lineno"> 2335</span>&#160;                  <span class="stringliteral">&quot;Stride==1 predicate will imply that the loop executes &quot;</span></div><div class="line"><a name="l02336"></a><span class="lineno"> 2336</span>&#160;                  <span class="stringliteral">&quot;at most once.\n&quot;</span>);</div><div class="line"><a name="l02337"></a><span class="lineno"> 2337</span>&#160;    <span class="keywordflow">return</span>;</div><div class="line"><a name="l02338"></a><span class="lineno"> 2338</span>&#160;  }</div><div class="line"><a name="l02339"></a><span class="lineno"> 2339</span>&#160;  <a class="code" href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a>(<a class="code" href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">dbgs</a>() &lt;&lt; <span class="stringliteral">&quot;LAA: Found a strided access that we can version.&quot;</span>);</div><div class="line"><a name="l02340"></a><span class="lineno"> 2340</span>&#160;</div><div class="line"><a name="l02341"></a><span class="lineno"> 2341</span>&#160;  SymbolicStrides[Ptr] = Stride;</div><div class="line"><a name="l02342"></a><span class="lineno"> 2342</span>&#160;  StrideSet.insert(Stride);</div><div class="line"><a name="l02343"></a><span class="lineno"> 2343</span>&#160;}</div><div class="line"><a name="l02344"></a><span class="lineno"> 2344</span>&#160;</div><div class="line"><a name="l02345"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessInfo.html#aaa610c0e0cd0c31c06cb09ca9dc50be0"> 2345</a></span>&#160;<a class="code" href="classllvm_1_1LoopAccessInfo.html#aaa610c0e0cd0c31c06cb09ca9dc50be0">LoopAccessInfo::LoopAccessInfo</a>(<a class="code" href="classllvm_1_1Loop.html">Loop</a> *L, <a class="code" href="classllvm_1_1ScalarEvolution.html">ScalarEvolution</a> *SE,</div><div class="line"><a name="l02346"></a><span class="lineno"> 2346</span>&#160;                               <span class="keyword">const</span> <a class="code" href="classllvm_1_1TargetLibraryInfo.html">TargetLibraryInfo</a> *TLI, <a class="code" href="classllvm_1_1AAResults.html">AliasAnalysis</a> *AA,</div><div class="line"><a name="l02347"></a><span class="lineno"> 2347</span>&#160;                               <a class="code" href="classllvm_1_1DominatorTree.html">DominatorTree</a> *DT, <a class="code" href="classllvm_1_1LoopInfo.html">LoopInfo</a> *LI)</div><div class="line"><a name="l02348"></a><span class="lineno"> 2348</span>&#160;    : PSE(<a class="code" href="namespacestd.html">std</a>::make_unique&lt;<a class="code" href="classllvm_1_1PredicatedScalarEvolution.html">PredicatedScalarEvolution</a>&gt;(*SE, *L)),</div><div class="line"><a name="l02349"></a><span class="lineno"> 2349</span>&#160;      PtrRtChecking(<a class="code" href="namespacestd.html">std</a>::make_unique&lt;<a class="code" href="classllvm_1_1RuntimePointerChecking.html">RuntimePointerChecking</a>&gt;(SE)),</div><div class="line"><a name="l02350"></a><span class="lineno"> 2350</span>&#160;      DepChecker(<a class="code" href="namespacestd.html">std</a>::make_unique&lt;<a class="code" href="classllvm_1_1MemoryDepChecker.html">MemoryDepChecker</a>&gt;(*PSE, L)), TheLoop(L),</div><div class="line"><a name="l02351"></a><span class="lineno"> 2351</span>&#160;      NumLoads(0), NumStores(0), MaxSafeDepDistBytes(-1), CanVecMem(<a class="code" href="namespacefalse.html">false</a>),</div><div class="line"><a name="l02352"></a><span class="lineno"> 2352</span>&#160;      HasConvergentOp(<a class="code" href="namespacefalse.html">false</a>),</div><div class="line"><a name="l02353"></a><span class="lineno"> 2353</span>&#160;      HasDependenceInvolvingLoopInvariantAddress(<a class="code" href="namespacefalse.html">false</a>) {</div><div class="line"><a name="l02354"></a><span class="lineno"> 2354</span>&#160;  <span class="keywordflow">if</span> (canAnalyzeLoop())</div><div class="line"><a name="l02355"></a><span class="lineno"> 2355</span>&#160;    analyzeLoop(AA, LI, TLI, DT);</div><div class="line"><a name="l02356"></a><span class="lineno"> 2356</span>&#160;}</div><div class="line"><a name="l02357"></a><span class="lineno"> 2357</span>&#160;</div><div class="line"><a name="l02358"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessInfo.html#a8acfde41662b7ec9d592d905da1dbb22"> 2358</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classllvm_1_1LoopAccessInfo.html#a8acfde41662b7ec9d592d905da1dbb22">LoopAccessInfo::print</a>(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, <span class="keywordtype">unsigned</span> <a class="code" href="namespacellvm.html#a1eb5609345b906d024fbf9e4bc1adc06afe578efb7ca235af77fb0eef7edcf639">Depth</a>)<span class="keyword"> const </span>{</div><div class="line"><a name="l02359"></a><span class="lineno"> 2359</span>&#160;  <span class="keywordflow">if</span> (CanVecMem) {</div><div class="line"><a name="l02360"></a><span class="lineno"> 2360</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Memory dependences are safe&quot;</span>;</div><div class="line"><a name="l02361"></a><span class="lineno"> 2361</span>&#160;    <span class="keywordflow">if</span> (MaxSafeDepDistBytes != -1ULL)</div><div class="line"><a name="l02362"></a><span class="lineno"> 2362</span>&#160;      OS &lt;&lt; <span class="stringliteral">&quot; with a maximum dependence distance of &quot;</span> &lt;&lt; MaxSafeDepDistBytes</div><div class="line"><a name="l02363"></a><span class="lineno"> 2363</span>&#160;         &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span>;</div><div class="line"><a name="l02364"></a><span class="lineno"> 2364</span>&#160;    <span class="keywordflow">if</span> (PtrRtChecking-&gt;Need)</div><div class="line"><a name="l02365"></a><span class="lineno"> 2365</span>&#160;      OS &lt;&lt; <span class="stringliteral">&quot; with run-time checks&quot;</span>;</div><div class="line"><a name="l02366"></a><span class="lineno"> 2366</span>&#160;    OS &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l02367"></a><span class="lineno"> 2367</span>&#160;  }</div><div class="line"><a name="l02368"></a><span class="lineno"> 2368</span>&#160;</div><div class="line"><a name="l02369"></a><span class="lineno"> 2369</span>&#160;  <span class="keywordflow">if</span> (HasConvergentOp)</div><div class="line"><a name="l02370"></a><span class="lineno"> 2370</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Has convergent operation in loop\n&quot;</span>;</div><div class="line"><a name="l02371"></a><span class="lineno"> 2371</span>&#160;</div><div class="line"><a name="l02372"></a><span class="lineno"> 2372</span>&#160;  <span class="keywordflow">if</span> (Report)</div><div class="line"><a name="l02373"></a><span class="lineno"> 2373</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Report: &quot;</span> &lt;&lt; Report-&gt;getMsg() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l02374"></a><span class="lineno"> 2374</span>&#160;</div><div class="line"><a name="l02375"></a><span class="lineno"> 2375</span>&#160;  <span class="keywordflow">if</span> (<span class="keyword">auto</span> *Dependences = DepChecker-&gt;getDependences()) {</div><div class="line"><a name="l02376"></a><span class="lineno"> 2376</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Dependences:\n&quot;</span>;</div><div class="line"><a name="l02377"></a><span class="lineno"> 2377</span>&#160;    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;Dep : *Dependences) {</div><div class="line"><a name="l02378"></a><span class="lineno"> 2378</span>&#160;      Dep.print(OS, Depth + 2, DepChecker-&gt;getMemoryInstructions());</div><div class="line"><a name="l02379"></a><span class="lineno"> 2379</span>&#160;      OS &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l02380"></a><span class="lineno"> 2380</span>&#160;    }</div><div class="line"><a name="l02381"></a><span class="lineno"> 2381</span>&#160;  } <span class="keywordflow">else</span></div><div class="line"><a name="l02382"></a><span class="lineno"> 2382</span>&#160;    OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Too many dependences, not recorded\n&quot;</span>;</div><div class="line"><a name="l02383"></a><span class="lineno"> 2383</span>&#160;</div><div class="line"><a name="l02384"></a><span class="lineno"> 2384</span>&#160;  <span class="comment">// List the pair of accesses need run-time checks to prove independence.</span></div><div class="line"><a name="l02385"></a><span class="lineno"> 2385</span>&#160;  PtrRtChecking-&gt;print(OS, Depth);</div><div class="line"><a name="l02386"></a><span class="lineno"> 2386</span>&#160;  OS &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l02387"></a><span class="lineno"> 2387</span>&#160;</div><div class="line"><a name="l02388"></a><span class="lineno"> 2388</span>&#160;  OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Non vectorizable stores to invariant address were &quot;</span></div><div class="line"><a name="l02389"></a><span class="lineno"> 2389</span>&#160;                   &lt;&lt; (HasDependenceInvolvingLoopInvariantAddress ? <span class="stringliteral">&quot;&quot;</span> : <span class="stringliteral">&quot;not &quot;</span>)</div><div class="line"><a name="l02390"></a><span class="lineno"> 2390</span>&#160;                   &lt;&lt; <span class="stringliteral">&quot;found in loop.\n&quot;</span>;</div><div class="line"><a name="l02391"></a><span class="lineno"> 2391</span>&#160;</div><div class="line"><a name="l02392"></a><span class="lineno"> 2392</span>&#160;  OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;SCEV assumptions:\n&quot;</span>;</div><div class="line"><a name="l02393"></a><span class="lineno"> 2393</span>&#160;  PSE-&gt;getUnionPredicate().print(OS, Depth);</div><div class="line"><a name="l02394"></a><span class="lineno"> 2394</span>&#160;</div><div class="line"><a name="l02395"></a><span class="lineno"> 2395</span>&#160;  OS &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line"><a name="l02396"></a><span class="lineno"> 2396</span>&#160;</div><div class="line"><a name="l02397"></a><span class="lineno"> 2397</span>&#160;  OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(Depth) &lt;&lt; <span class="stringliteral">&quot;Expressions re-written:\n&quot;</span>;</div><div class="line"><a name="l02398"></a><span class="lineno"> 2398</span>&#160;  PSE-&gt;print(OS, Depth);</div><div class="line"><a name="l02399"></a><span class="lineno"> 2399</span>&#160;}</div><div class="line"><a name="l02400"></a><span class="lineno"> 2400</span>&#160;</div><div class="line"><a name="l02401"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessLegacyAnalysis.html#ad81d9a21b2eb90fec45f93a07f366754"> 2401</a></span>&#160;<a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html#ad81d9a21b2eb90fec45f93a07f366754">LoopAccessLegacyAnalysis::LoopAccessLegacyAnalysis</a>() : <a class="code" href="classllvm_1_1FunctionPass.html">FunctionPass</a>(<a class="code" href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">ID</a>) {</div><div class="line"><a name="l02402"></a><span class="lineno"> 2402</span>&#160;  <a class="code" href="namespacellvm.html#a4d83ff3eb9801798dcdc92eba3a9dde7">initializeLoopAccessLegacyAnalysisPass</a>(*<a class="code" href="classllvm_1_1PassRegistry.html#a05a729900b76c89e808c6c3094921b2f">PassRegistry::getPassRegistry</a>());</div><div class="line"><a name="l02403"></a><span class="lineno"> 2403</span>&#160;}</div><div class="line"><a name="l02404"></a><span class="lineno"> 2404</span>&#160;</div><div class="line"><a name="l02405"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessLegacyAnalysis.html#ad340ccd20710b9c804283f3b1572c4fc"> 2405</a></span>&#160;<span class="keyword">const</span> <a class="code" href="classllvm_1_1LoopAccessInfo.html">LoopAccessInfo</a> &amp;<a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html#ad340ccd20710b9c804283f3b1572c4fc">LoopAccessLegacyAnalysis::getInfo</a>(<a class="code" href="classllvm_1_1Loop.html">Loop</a> *L) {</div><div class="line"><a name="l02406"></a><span class="lineno"> 2406</span>&#160;  <span class="keyword">auto</span> &amp;LAI = LoopAccessInfoMap[L];</div><div class="line"><a name="l02407"></a><span class="lineno"> 2407</span>&#160;</div><div class="line"><a name="l02408"></a><span class="lineno"> 2408</span>&#160;  <span class="keywordflow">if</span> (!LAI)</div><div class="line"><a name="l02409"></a><span class="lineno"> 2409</span>&#160;    LAI = std::make_unique&lt;LoopAccessInfo&gt;(L, SE, TLI, AA, DT, LI);</div><div class="line"><a name="l02410"></a><span class="lineno"> 2410</span>&#160;</div><div class="line"><a name="l02411"></a><span class="lineno"> 2411</span>&#160;  <span class="keywordflow">return</span> *LAI.get();</div><div class="line"><a name="l02412"></a><span class="lineno"> 2412</span>&#160;}</div><div class="line"><a name="l02413"></a><span class="lineno"> 2413</span>&#160;</div><div class="line"><a name="l02414"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessLegacyAnalysis.html#a6548db490a8ff769659787a27a5c94d7"> 2414</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html#a6548db490a8ff769659787a27a5c94d7">LoopAccessLegacyAnalysis::print</a>(<a class="code" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, <span class="keyword">const</span> <a class="code" href="classllvm_1_1Module.html">Module</a> *M)<span class="keyword"> const </span>{</div><div class="line"><a name="l02415"></a><span class="lineno"> 2415</span>&#160;  <a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html">LoopAccessLegacyAnalysis</a> &amp;LAA = *<span class="keyword">const_cast&lt;</span><a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html">LoopAccessLegacyAnalysis</a> *<span class="keyword">&gt;</span>(<span class="keyword">this</span>);</div><div class="line"><a name="l02416"></a><span class="lineno"> 2416</span>&#160;</div><div class="line"><a name="l02417"></a><span class="lineno"> 2417</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1Loop.html">Loop</a> *TopLevelLoop : *LI)</div><div class="line"><a name="l02418"></a><span class="lineno"> 2418</span>&#160;    <span class="keywordflow">for</span> (<a class="code" href="classllvm_1_1Loop.html">Loop</a> *L : <a class="code" href="namespacellvm.html#add49d9f7abebe402adf1a57c762abeef">depth_first</a>(TopLevelLoop)) {</div><div class="line"><a name="l02419"></a><span class="lineno"> 2419</span>&#160;      OS.<a class="code" href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">indent</a>(2) &lt;&lt; L-&gt;getHeader()-&gt;getName() &lt;&lt; <span class="stringliteral">&quot;:\n&quot;</span>;</div><div class="line"><a name="l02420"></a><span class="lineno"> 2420</span>&#160;      <span class="keyword">auto</span> &amp;LAI = LAA.<a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html#ad340ccd20710b9c804283f3b1572c4fc">getInfo</a>(L);</div><div class="line"><a name="l02421"></a><span class="lineno"> 2421</span>&#160;      LAI.<a class="code" href="classllvm_1_1LoopAccessInfo.html#a8acfde41662b7ec9d592d905da1dbb22">print</a>(OS, 4);</div><div class="line"><a name="l02422"></a><span class="lineno"> 2422</span>&#160;    }</div><div class="line"><a name="l02423"></a><span class="lineno"> 2423</span>&#160;}</div><div class="line"><a name="l02424"></a><span class="lineno"> 2424</span>&#160;</div><div class="line"><a name="l02425"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessLegacyAnalysis.html#ae38799ea6afbe2f009f89d9f8958d198"> 2425</a></span>&#160;<span class="keywordtype">bool</span> <a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html#ae38799ea6afbe2f009f89d9f8958d198">LoopAccessLegacyAnalysis::runOnFunction</a>(<a class="code" href="classllvm_1_1Function.html">Function</a> &amp;<a class="code" href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a>) {</div><div class="line"><a name="l02426"></a><span class="lineno"> 2426</span>&#160;  SE = &amp;getAnalysis&lt;ScalarEvolutionWrapperPass&gt;().getSE();</div><div class="line"><a name="l02427"></a><span class="lineno"> 2427</span>&#160;  <span class="keyword">auto</span> *TLIP = getAnalysisIfAvailable&lt;TargetLibraryInfoWrapperPass&gt;();</div><div class="line"><a name="l02428"></a><span class="lineno"> 2428</span>&#160;  TLI = TLIP ? &amp;TLIP-&gt;getTLI(F) : <span class="keyword">nullptr</span>;</div><div class="line"><a name="l02429"></a><span class="lineno"> 2429</span>&#160;  AA = &amp;getAnalysis&lt;AAResultsWrapperPass&gt;().getAAResults();</div><div class="line"><a name="l02430"></a><span class="lineno"> 2430</span>&#160;  DT = &amp;getAnalysis&lt;DominatorTreeWrapperPass&gt;().getDomTree();</div><div class="line"><a name="l02431"></a><span class="lineno"> 2431</span>&#160;  LI = &amp;getAnalysis&lt;LoopInfoWrapperPass&gt;().getLoopInfo();</div><div class="line"><a name="l02432"></a><span class="lineno"> 2432</span>&#160;</div><div class="line"><a name="l02433"></a><span class="lineno"> 2433</span>&#160;  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l02434"></a><span class="lineno"> 2434</span>&#160;}</div><div class="line"><a name="l02435"></a><span class="lineno"> 2435</span>&#160;</div><div class="line"><a name="l02436"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessLegacyAnalysis.html#aca1f179c99fe3eb13060f42e415388a8"> 2436</a></span>&#160;<span class="keywordtype">void</span> <a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html#aca1f179c99fe3eb13060f42e415388a8">LoopAccessLegacyAnalysis::getAnalysisUsage</a>(<a class="code" href="classllvm_1_1AnalysisUsage.html">AnalysisUsage</a> &amp;AU)<span class="keyword"> const </span>{</div><div class="line"><a name="l02437"></a><span class="lineno"> 2437</span>&#160;    AU.<a class="code" href="classllvm_1_1AnalysisUsage.html#ae5c60fd282ee894c87ea02c3f0fcb6d0">addRequired</a>&lt;<a class="code" href="classllvm_1_1ScalarEvolutionWrapperPass.html">ScalarEvolutionWrapperPass</a>&gt;();</div><div class="line"><a name="l02438"></a><span class="lineno"> 2438</span>&#160;    AU.<a class="code" href="classllvm_1_1AnalysisUsage.html#ae5c60fd282ee894c87ea02c3f0fcb6d0">addRequired</a>&lt;<a class="code" href="classllvm_1_1AAResultsWrapperPass.html">AAResultsWrapperPass</a>&gt;();</div><div class="line"><a name="l02439"></a><span class="lineno"> 2439</span>&#160;    AU.<a class="code" href="classllvm_1_1AnalysisUsage.html#ae5c60fd282ee894c87ea02c3f0fcb6d0">addRequired</a>&lt;<a class="code" href="classllvm_1_1DominatorTreeWrapperPass.html">DominatorTreeWrapperPass</a>&gt;();</div><div class="line"><a name="l02440"></a><span class="lineno"> 2440</span>&#160;    AU.<a class="code" href="classllvm_1_1AnalysisUsage.html#ae5c60fd282ee894c87ea02c3f0fcb6d0">addRequired</a>&lt;<a class="code" href="classllvm_1_1LoopInfoWrapperPass.html">LoopInfoWrapperPass</a>&gt;();</div><div class="line"><a name="l02441"></a><span class="lineno"> 2441</span>&#160;</div><div class="line"><a name="l02442"></a><span class="lineno"> 2442</span>&#160;    AU.<a class="code" href="classllvm_1_1AnalysisUsage.html#af22b06a6a4f9df80454071685a0d6a02">setPreservesAll</a>();</div><div class="line"><a name="l02443"></a><span class="lineno"> 2443</span>&#160;}</div><div class="line"><a name="l02444"></a><span class="lineno"> 2444</span>&#160;</div><div class="line"><a name="l02445"></a><span class="lineno"> 2445</span>&#160;<span class="keywordtype">char</span> <a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html#ab43633352c881df20ceca554ca60dd9f">LoopAccessLegacyAnalysis::ID</a> = 0;</div><div class="line"><a name="l02446"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#a910cc6725e0a341b7cdf6f2f3aceffaa"> 2446</a></span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> <a class="code" href="LoopAccessAnalysis_8cpp.html#a910cc6725e0a341b7cdf6f2f3aceffaa">laa_name</a>[] = <span class="stringliteral">&quot;Loop Access Analysis&quot;</span>;</div><div class="line"><a name="l02447"></a><span class="lineno"><a class="line" href="LoopAccessAnalysis_8cpp.html#a88e01fef3136505c1c94623e7f25e58d"> 2447</a></span>&#160;<span class="preprocessor">#define LAA_NAME &quot;loop-accesses&quot;</span></div><div class="line"><a name="l02448"></a><span class="lineno"> 2448</span>&#160;</div><div class="line"><a name="l02449"></a><span class="lineno"> 2449</span>&#160;<a class="code" href="PassSupport_8h.html#aaa970fc931c1c63037a8182e028d04b1">INITIALIZE_PASS_BEGIN</a>(<a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html">LoopAccessLegacyAnalysis</a>, <a class="code" href="LoopAccessAnalysis_8cpp.html#a88e01fef3136505c1c94623e7f25e58d">LAA_NAME</a>, laa_name, <span class="keyword">false</span>, <span class="keyword">true</span>)</div><div class="line"><a name="l02450"></a><span class="lineno"> 2450</span>&#160;<a class="code" href="PassSupport_8h.html#a14724f1ccf528e73bb29bc9230737967">INITIALIZE_PASS_DEPENDENCY</a>(<a class="code" href="classllvm_1_1AAResultsWrapperPass.html">AAResultsWrapperPass</a>)</div><div class="line"><a name="l02451"></a><span class="lineno"> 2451</span>&#160;<a class="code" href="PassSupport_8h.html#a14724f1ccf528e73bb29bc9230737967">INITIALIZE_PASS_DEPENDENCY</a>(<a class="code" href="classllvm_1_1ScalarEvolutionWrapperPass.html">ScalarEvolutionWrapperPass</a>)</div><div class="line"><a name="l02452"></a><span class="lineno"> 2452</span>&#160;<a class="code" href="PassSupport_8h.html#a14724f1ccf528e73bb29bc9230737967">INITIALIZE_PASS_DEPENDENCY</a>(<a class="code" href="classllvm_1_1DominatorTreeWrapperPass.html">DominatorTreeWrapperPass</a>)</div><div class="line"><a name="l02453"></a><span class="lineno"> 2453</span>&#160;<a class="code" href="PassSupport_8h.html#a14724f1ccf528e73bb29bc9230737967">INITIALIZE_PASS_DEPENDENCY</a>(<a class="code" href="classllvm_1_1LoopInfoWrapperPass.html">LoopInfoWrapperPass</a>)</div><div class="line"><a name="l02454"></a><span class="lineno"> 2454</span>&#160;<a class="code" href="RegBankSelect_8cpp.html#a0eee13989797c0d4612066f84ff7a7b8">INITIALIZE_PASS_END</a>(<a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html">LoopAccessLegacyAnalysis</a>, <a class="code" href="LoopAccessAnalysis_8cpp.html#a88e01fef3136505c1c94623e7f25e58d">LAA_NAME</a>, laa_name, <a class="code" href="namespacefalse.html">false</a>, <a class="code" href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a>)</div><div class="line"><a name="l02455"></a><span class="lineno"> 2455</span>&#160;</div><div class="line"><a name="l02456"></a><span class="lineno"> 2456</span>&#160;<a class="code" href="structllvm_1_1AnalysisKey.html">AnalysisKey</a> <a class="code" href="classllvm_1_1LoopAccessAnalysis.html">LoopAccessAnalysis</a>::<a class="code" href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">Key</a>;</div><div class="line"><a name="l02457"></a><span class="lineno"> 2457</span>&#160;</div><div class="line"><a name="l02458"></a><span class="lineno"><a class="line" href="classllvm_1_1LoopAccessAnalysis.html#a37e47fa1a30253fcbe82b4dc1ba01252"> 2458</a></span>&#160;<a class="code" href="classllvm_1_1LoopAccessInfo.html">LoopAccessInfo</a> <a class="code" href="classllvm_1_1LoopAccessAnalysis.html">LoopAccessAnalysis</a>::run(<a class="code" href="classllvm_1_1Loop.html">Loop</a> &amp;L, <a class="code" href="classllvm_1_1AnalysisManager.html">LoopAnalysisManager</a> &amp;AM,</div><div class="line"><a name="l02459"></a><span class="lineno"> 2459</span>&#160;                                       <a class="code" href="structllvm_1_1LoopStandardAnalysisResults.html">LoopStandardAnalysisResults</a> &amp;AR) {</div><div class="line"><a name="l02460"></a><span class="lineno"> 2460</span>&#160;  <span class="keywordflow">return</span> <a class="code" href="classllvm_1_1LoopAccessInfo.html">LoopAccessInfo</a>(&amp;L, &amp;AR.SE, &amp;AR.TLI, &amp;AR.AA, &amp;AR.DT, &amp;AR.LI);</div><div class="line"><a name="l02461"></a><span class="lineno"> 2461</span>&#160;}</div><div class="line"><a name="l02462"></a><span class="lineno"> 2462</span>&#160;</div><div class="line"><a name="l02463"></a><span class="lineno"> 2463</span>&#160;<span class="keyword">namespace </span><a class="code" href="namespacellvm.html">llvm</a> {</div><div class="line"><a name="l02464"></a><span class="lineno"> 2464</span>&#160;</div><div class="line"><a name="l02465"></a><span class="lineno"><a class="line" href="namespacellvm.html#ad8c0f164d625c83cfd0028a2d8daf07e"> 2465</a></span>&#160;  <a class="code" href="classllvm_1_1Pass.html">Pass</a> *<a class="code" href="namespacellvm.html#ad8c0f164d625c83cfd0028a2d8daf07e">createLAAPass</a>() {</div><div class="line"><a name="l02466"></a><span class="lineno"> 2466</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classllvm_1_1LoopAccessLegacyAnalysis.html#ad81d9a21b2eb90fec45f93a07f366754">LoopAccessLegacyAnalysis</a>();</div><div class="line"><a name="l02467"></a><span class="lineno"> 2467</span>&#160;  }</div><div class="line"><a name="l02468"></a><span class="lineno"> 2468</span>&#160;</div><div class="line"><a name="l02469"></a><span class="lineno"> 2469</span>&#160;} <span class="comment">// end namespace llvm</span></div><div class="ttc" id="LoopAccessAnalysis_8cpp_html_ab6cdd949c43218910fff41875a194e9f"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#ab6cdd949c43218910fff41875a194e9f">isSafeDependenceDistance</a></div><div class="ttdeci">static bool isSafeDependenceDistance(const DataLayout &amp;DL, ScalarEvolution &amp;SE, const SCEV &amp;BackedgeTakenCount, const SCEV &amp;Dist, uint64_t Stride, uint64_t TypeByteSize)</div><div class="ttdoc">Given a non-constant (unknown) dependence-distance Dist between two memory accesses, that have the same stride whose absolute value is given in Stride, and that have the same type size TypeByteSize, in a loop whose takenCount is BackedgeTakenCount, check if it is possible to prove statically that the dependence distance is larger than the range that the accesses will travel through the execution of the loop. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01351">LoopAccessAnalysis.cpp:1351</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a88e01fef3136505c1c94623e7f25e58d"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a88e01fef3136505c1c94623e7f25e58d">LAA_NAME</a></div><div class="ttdeci">#define LAA_NAME</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02447">LoopAccessAnalysis.cpp:2447</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a38e964f0cadf077725453884734a6c99"><div class="ttname"><a href="classllvm_1_1APInt.html#a38e964f0cadf077725453884734a6c99">llvm::APInt::abs</a></div><div class="ttdeci">APInt abs() const</div><div class="ttdoc">Get the absolute value;. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01857">APInt.h:1857</a></div></div>
<div class="ttc" id="classllvm_1_1Pass_html"><div class="ttname"><a href="classllvm_1_1Pass.html">llvm::Pass</a></div><div class="ttdoc">Pass interface - Implemented by all &amp;#39;passes&amp;#39;. </div><div class="ttdef"><b>Definition:</b> <a href="Pass_8h_source.html#l00078">Pass.h:78</a></div></div>
<div class="ttc" id="structllvm_1_1VectorizerParams_html_a43a5cafabe566a957f39d39f2edb411b"><div class="ttname"><a href="structllvm_1_1VectorizerParams.html#a43a5cafabe566a957f39d39f2edb411b">llvm::VectorizerParams::RuntimeMemoryCheckThreshold</a></div><div class="ttdeci">static unsigned RuntimeMemoryCheckThreshold</div><div class="ttdoc">performing memory disambiguation checks at runtime do not make more than this number of comparisons...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00055">LoopAccessAnalysis.h:55</a></div></div>
<div class="ttc" id="AArch64Disassembler_8cpp_html_a5d37f23ec6bf93da60e38fda41e9a83d"><div class="ttname"><a href="AArch64Disassembler_8cpp.html#a5d37f23ec6bf93da60e38fda41e9a83d">Check</a></div><div class="ttdeci">static bool Check(DecodeStatus &amp;Out, DecodeStatus In)</div><div class="ttdef"><b>Definition:</b> <a href="AArch64Disassembler_8cpp_source.html#l00223">AArch64Disassembler.cpp:223</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a910cc6725e0a341b7cdf6f2f3aceffaa"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a910cc6725e0a341b7cdf6f2f3aceffaa">laa_name</a></div><div class="ttdeci">static const char laa_name[]</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02446">LoopAccessAnalysis.cpp:2446</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateCommon_html_a075e34e98605d0e7c289763a104869ac"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateCommon.html#a075e34e98605d0e7c289763a104869ac">llvm::SmallVectorTemplateCommon::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00129">SmallVector.h:129</a></div></div>
<div class="ttc" id="namespacellvm_html_a611d9f877de3e9402bd8f56fb10ec5a1"><div class="ttname"><a href="namespacellvm.html#a611d9f877de3e9402bd8f56fb10ec5a1">llvm::getStrideFromPointer</a></div><div class="ttdeci">Value * getStrideFromPointer(Value *Ptr, ScalarEvolution *SE, Loop *Lp)</div><div class="ttdoc">Get the stride of a pointer access in a loop. </div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00186">VectorUtils.cpp:186</a></div></div>
<div class="ttc" id="NVVMIntrRange_8cpp_html_a2ae53ee71b2ccbb52b883c0b4f59f8c2"><div class="ttname"><a href="NVVMIntrRange_8cpp.html#a2ae53ee71b2ccbb52b883c0b4f59f8c2">C</a></div><div class="ttdeci">uint64_t CallInst * C</div><div class="ttdef"><b>Definition:</b> <a href="NVVMIntrRange_8cpp_source.html#l00068">NVVMIntrRange.cpp:68</a></div></div>
<div class="ttc" id="SmallSet_8h_html"><div class="ttname"><a href="SmallSet_8h.html">SmallSet.h</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_ad78e062f62e0d6e453941fb4ca843e4d"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a></div><div class="ttdeci">#define DEBUG_TYPE</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00072">LoopAccessAnalysis.cpp:72</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a095d2abc4fa2ce11453eaeece2200cbe"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a095d2abc4fa2ce11453eaeece2200cbe">VectorizationInterleave</a></div><div class="ttdeci">static cl::opt&lt; unsigned, true &gt; VectorizationInterleave(&quot;force-vector-interleave&quot;, cl::Hidden, cl::desc(&quot;Sets the vectorization interleave count. &quot; &quot;Zero is autoselect.&quot;), cl::location(VectorizerParams::VectorizationInterleave))</div></div>
<div class="ttc" id="PointerIntPair_8h_html"><div class="ttname"><a href="PointerIntPair_8h.html">PointerIntPair.h</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html"><div class="ttname"><a href="classllvm_1_1DataLayout.html">llvm::DataLayout</a></div><div class="ttdoc">A parsed version of the target data layout string in and methods for querying it. ...</div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00111">DataLayout.h:111</a></div></div>
<div class="ttc" id="IR_2Instruction_8h_html"><div class="ttname"><a href="IR_2Instruction_8h.html">Instruction.h</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html_a396fcfee6914c76974b73c3d203da6a5"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html#a396fcfee6914c76974b73c3d203da6a5">llvm::SmallVectorImpl::emplace_back</a></div><div class="ttdeci">reference emplace_back(ArgTypes &amp;&amp;... Args)</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00641">SmallVector.h:641</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_a2607c6b8fad0ecefaaa5db14a4be340e"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#a2607c6b8fad0ecefaaa5db14a4be340e">llvm::RuntimePointerChecking::printChecks</a></div><div class="ttdeci">void printChecks(raw_ostream &amp;OS, const SmallVectorImpl&lt; PointerCheck &gt; &amp;Checks, unsigned Depth=0) const</div><div class="ttdoc">Print Checks. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00453">LoopAccessAnalysis.cpp:453</a></div></div>
<div class="ttc" id="classllvm_1_1PredicatedScalarEvolution_html_a757ce31dd838b17c024287ce9d17c4c2"><div class="ttname"><a href="classllvm_1_1PredicatedScalarEvolution.html#a757ce31dd838b17c024287ce9d17c4c2">llvm::PredicatedScalarEvolution::setNoOverflow</a></div><div class="ttdeci">void setNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags)</div><div class="ttdoc">Proves that V doesn&amp;#39;t overflow by adding SCEV predicate. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l12500">ScalarEvolution.cpp:12500</a></div></div>
<div class="ttc" id="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup_html"><div class="ttname"><a href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html">llvm::RuntimePointerChecking::CheckingPtrGroup</a></div><div class="ttdoc">A grouping of pointers. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00386">LoopAccessAnalysis.h:386</a></div></div>
<div class="ttc" id="ErlangGCPrinter_8cpp_html_a74b474c0616ab55c1d9487f11fd31d26"><div class="ttname"><a href="ErlangGCPrinter_8cpp.html#a74b474c0616ab55c1d9487f11fd31d26">X</a></div><div class="ttdeci">static GCMetadataPrinterRegistry::Add&lt; ErlangGCPrinter &gt; X(&quot;erlang&quot;, &quot;erlang-compatible garbage collector&quot;)</div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_ac9e61b1a68b91217d3d10a61a1f0fbb9"><div class="ttname"><a href="classllvm_1_1DataLayout.html#ac9e61b1a68b91217d3d10a61a1f0fbb9">llvm::DataLayout::getIndexSizeInBits</a></div><div class="ttdeci">unsigned getIndexSizeInBits(unsigned AS) const</div><div class="ttdoc">Size in bits of index used for address calculation in getelementptr. </div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00402">DataLayout.h:402</a></div></div>
<div class="ttc" id="DiagnosticInfo_8h_html"><div class="ttname"><a href="DiagnosticInfo_8h.html">DiagnosticInfo.h</a></div></div>
<div class="ttc" id="classllvm_1_1LoopBase_html_a1230fd674d2609b96527fe65eaf40b1b"><div class="ttname"><a href="classllvm_1_1LoopBase.html#a1230fd674d2609b96527fe65eaf40b1b">llvm::LoopBase::getLoopLatch</a></div><div class="ttdeci">BlockT * getLoopLatch() const</div><div class="ttdoc">If there is a single latch block for this loop, return it. </div><div class="ttdef"><b>Definition:</b> <a href="LoopInfoImpl_8h_source.html#l00209">LoopInfoImpl.h:209</a></div></div>
<div class="ttc" id="classllvm_1_1PassRegistry_html_a05a729900b76c89e808c6c3094921b2f"><div class="ttname"><a href="classllvm_1_1PassRegistry.html#a05a729900b76c89e808c6c3094921b2f">llvm::PassRegistry::getPassRegistry</a></div><div class="ttdeci">static PassRegistry * getPassRegistry()</div><div class="ttdoc">getPassRegistry - Access the global registry object, which is automatically initialized at applicatio...</div><div class="ttdef"><b>Definition:</b> <a href="PassRegistry_8cpp_source.html#l00031">PassRegistry.cpp:31</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a217e0207d9cc8e046c2dccbf0e4bb198"><div class="ttname"><a href="classllvm_1_1APInt.html#a217e0207d9cc8e046c2dccbf0e4bb198">llvm::APInt::getZExtValue</a></div><div class="ttdeci">uint64_t getZExtValue() const</div><div class="ttdoc">Get zero extended value. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01620">APInt.h:1620</a></div></div>
<div class="ttc" id="namespacellvm_1_1Sched_html_ac1547cccaf660851fcd6863d1e60309eac13545a6345c7d5b3c9cc8932ad3b0e9"><div class="ttname"><a href="namespacellvm_1_1Sched.html#ac1547cccaf660851fcd6863d1e60309eac13545a6345c7d5b3c9cc8932ad3b0e9">llvm::Sched::Source</a></div><div class="ttdef"><b>Definition:</b> <a href="TargetLowering_8h_source.html#l00100">TargetLowering.h:100</a></div></div>
<div class="ttc" id="namespacellvm_1_1sys_1_1path_html_a00a76a729b319dc47beffbe07325565f"><div class="ttname"><a href="namespacellvm_1_1sys_1_1path.html#a00a76a729b319dc47beffbe07325565f">llvm::sys::path::begin</a></div><div class="ttdeci">const_iterator begin(StringRef path, Style style=Style::native)</div><div class="ttdoc">Get begin iterator over path. </div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00224">Path.cpp:224</a></div></div>
<div class="ttc" id="namespacellvm_html_a4d83ff3eb9801798dcdc92eba3a9dde7"><div class="ttname"><a href="namespacellvm.html#a4d83ff3eb9801798dcdc92eba3a9dde7">llvm::initializeLoopAccessLegacyAnalysisPass</a></div><div class="ttdeci">void initializeLoopAccessLegacyAnalysisPass(PassRegistry &amp;)</div></div>
<div class="ttc" id="Instructions_8h_html"><div class="ttname"><a href="Instructions_8h.html">Instructions.h</a></div></div>
<div class="ttc" id="structllvm_1_1MemoryDepChecker_1_1Dependence_html_a68f3caaf7ba7f284e0feb00ae907e4c2"><div class="ttname"><a href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a68f3caaf7ba7f284e0feb00ae907e4c2">llvm::MemoryDepChecker::Dependence::isBackward</a></div><div class="ttdeci">bool isBackward() const</div><div class="ttdoc">Lexically backward dependence. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01254">LoopAccessAnalysis.cpp:1254</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a2eb94d079d8416118f4aaed865ab05d7"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a2eb94d079d8416118f4aaed865ab05d7">llvm::ScalarEvolution::getConstant</a></div><div class="ttdeci">const SCEV * getConstant(ConstantInt *V)</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l00427">ScalarEvolution.cpp:427</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_abe6d015febd4845fa107ab9c87c031c0"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#abe6d015febd4845fa107ab9c87c031c0">isInBoundsGep</a></div><div class="ttdeci">static bool isInBoundsGep(Value *Ptr)</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00936">LoopAccessAnalysis.cpp:936</a></div></div>
<div class="ttc" id="namespacellvm_html"><div class="ttname"><a href="namespacellvm.html">llvm</a></div><div class="ttdoc">This class represents lattice values for constants. </div><div class="ttdef"><b>Definition:</b> <a href="AllocatorList_8h_source.html#l00023">AllocatorList.h:23</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_ab62603cc7bc570ef4688112c0a7fa0c0"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#ab62603cc7bc570ef4688112c0a7fa0c0">MemoryCheckMergeThreshold</a></div><div class="ttdeci">static cl::opt&lt; unsigned &gt; MemoryCheckMergeThreshold(&quot;memory-check-merge-threshold&quot;, cl::Hidden, cl::desc(&quot;Maximum number of comparisons done when trying to merge &quot; &quot;runtime memory checks. (default = 100)&quot;), cl::init(100))</div><div class="ttdoc">The maximum iterations used to merge memory checks. </div></div>
<div class="ttc" id="structllvm_1_1AAMDNodes_html_a56188042f9dd6003cb8ed087e8ae654f"><div class="ttname"><a href="structllvm_1_1AAMDNodes.html#a56188042f9dd6003cb8ed087e8ae654f">llvm::AAMDNodes::TBAA</a></div><div class="ttdeci">MDNode * TBAA</div><div class="ttdoc">The tag for type-based alias analysis. </div><div class="ttdef"><b>Definition:</b> <a href="Metadata_8h_source.html#l00661">Metadata.h:661</a></div></div>
<div class="ttc" id="classllvm_1_1IRBuilder_html_abf9ca7cf5cdb2219a9daea23be036e4e"><div class="ttname"><a href="classllvm_1_1IRBuilder.html#abf9ca7cf5cdb2219a9daea23be036e4e">llvm::IRBuilder::CreateICmpULT</a></div><div class="ttdeci">Value * CreateICmpULT(Value *LHS, Value *RHS, const Twine &amp;Name=&quot;&quot;)</div><div class="ttdef"><b>Definition:</b> <a href="IRBuilder_8h_source.html#l02262">IRBuilder.h:2262</a></div></div>
<div class="ttc" id="DerivedTypes_8h_html"><div class="ttname"><a href="DerivedTypes_8h.html">DerivedTypes.h</a></div></div>
<div class="ttc" id="classllvm_1_1Module_html"><div class="ttname"><a href="classllvm_1_1Module.html">llvm::Module</a></div><div class="ttdoc">A Module instance is used to store all the information related to an LLVM module. ...</div><div class="ttdef"><b>Definition:</b> <a href="Module_8h_source.html#l00066">Module.h:66</a></div></div>
<div class="ttc" id="Type_8h_html"><div class="ttname"><a href="Type_8h.html">Type.h</a></div></div>
<div class="ttc" id="namespacellvm_1_1ARM__MB_html_ad70272e2a9ec2a7e3a497458e1edbc85aed0b9bef861c96eee19e89db753db7b2"><div class="ttname"><a href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85aed0b9bef861c96eee19e89db753db7b2">llvm::ARM_MB::ST</a></div><div class="ttdef"><b>Definition:</b> <a href="MCTargetDesc_2ARMBaseInfo_8h_source.html#l00073">ARMBaseInfo.h:73</a></div></div>
<div class="ttc" id="classllvm_1_1LocationSize_html_a3de0002f6ad965b6bc1ad4591dbebeb5"><div class="ttname"><a href="classllvm_1_1LocationSize.html#a3de0002f6ad965b6bc1ad4591dbebeb5">llvm::LocationSize::unknown</a></div><div class="ttdeci">static constexpr LocationSize unknown()</div><div class="ttdef"><b>Definition:</b> <a href="MemoryLocation_8h_source.html#l00101">MemoryLocation.h:101</a></div></div>
<div class="ttc" id="classllvm_1_1EquivalenceClasses_html_a72c29f11de2d94ba0589624b00fac90a"><div class="ttname"><a href="classllvm_1_1EquivalenceClasses.html#a72c29f11de2d94ba0589624b00fac90a">llvm::EquivalenceClasses::getLeaderValue</a></div><div class="ttdeci">const ElemTy &amp; getLeaderValue(const ElemTy &amp;V) const</div><div class="ttdoc">getLeaderValue - Return the leader for the specified value that is in the set. </div><div class="ttdef"><b>Definition:</b> <a href="EquivalenceClasses_8h_source.html#l00170">EquivalenceClasses.h:170</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateBase_html_af42bfbc067df27c19ee2fc859df58799"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateBase.html#af42bfbc067df27c19ee2fc859df58799">llvm::SmallVectorTemplateBase::push_back</a></div><div class="ttdeci">void push_back(const T &amp;Elt)</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00211">SmallVector.h:211</a></div></div>
<div class="ttc" id="DataLayout_8h_html"><div class="ttname"><a href="DataLayout_8h.html">DataLayout.h</a></div></div>
<div class="ttc" id="iterator__range_8h_html"><div class="ttname"><a href="iterator__range_8h.html">iterator_range.h</a></div><div class="ttdoc">This provides a very simple, boring adaptor for a begin and end iterator into a range type...</div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html">llvm::ScalarEvolution</a></div><div class="ttdoc">The main scalar evolution driver. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l00441">ScalarEvolution.h:441</a></div></div>
<div class="ttc" id="namespacellvm_1_1AMDGPU_1_1Hwreg_html_a6110fc30bc7311a6cf99814530362e21"><div class="ttname"><a href="namespacellvm_1_1AMDGPU_1_1Hwreg.html#a6110fc30bc7311a6cf99814530362e21">llvm::AMDGPU::Hwreg::Offset</a></div><div class="ttdeci">Offset</div><div class="ttdef"><b>Definition:</b> <a href="SIDefines_8h_source.html#l00342">SIDefines.h:342</a></div></div>
<div class="ttc" id="classllvm_1_1DenseMap_html"><div class="ttname"><a href="classllvm_1_1DenseMap.html">llvm::DenseMap</a></div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00684">DenseMap.h:684</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessLegacyAnalysis_html_ad81d9a21b2eb90fec45f93a07f366754"><div class="ttname"><a href="classllvm_1_1LoopAccessLegacyAnalysis.html#ad81d9a21b2eb90fec45f93a07f366754">llvm::LoopAccessLegacyAnalysis::LoopAccessLegacyAnalysis</a></div><div class="ttdeci">LoopAccessLegacyAnalysis()</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02401">LoopAccessAnalysis.cpp:2401</a></div></div>
<div class="ttc" id="Debug_8h_html"><div class="ttname"><a href="Debug_8h.html">Debug.h</a></div></div>
<div class="ttc" id="classllvm_1_1CallInst_html"><div class="ttname"><a href="classllvm_1_1CallInst.html">llvm::CallInst</a></div><div class="ttdoc">This class represents a function call, abstracting a target machine&amp;#39;s calling convention. </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l01406">Instructions.h:1406</a></div></div>
<div class="ttc" id="namespacellvm_html_ab7f1b8ad3b5b4cb2cb19c2291dcf3cf1"><div class="ttname"><a href="namespacellvm.html#ab7f1b8ad3b5b4cb2cb19c2291dcf3cf1">llvm::getPtrStride</a></div><div class="ttdeci">int64_t getPtrStride(PredicatedScalarEvolution &amp;PSE, Value *Ptr, const Loop *Lp, const ValueToValueMap &amp;StridesMap=ValueToValueMap(), bool Assume=false, bool ShouldCheckWrap=true)</div><div class="ttdoc">If the pointer has a constant stride return it in units of its element size. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00991">LoopAccessAnalysis.cpp:991</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessLegacyAnalysis_html_aca1f179c99fe3eb13060f42e415388a8"><div class="ttname"><a href="classllvm_1_1LoopAccessLegacyAnalysis.html#aca1f179c99fe3eb13060f42e415388a8">llvm::LoopAccessLegacyAnalysis::getAnalysisUsage</a></div><div class="ttdeci">void getAnalysisUsage(AnalysisUsage &amp;AU) const override</div><div class="ttdoc">getAnalysisUsage - This function should be overriden by passes that need analysis information to do t...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02436">LoopAccessAnalysis.cpp:2436</a></div></div>
<div class="ttc" id="classllvm_1_1raw__ostream_html_a8fdf5cdf041c8aded7e3308c1c3efacc"><div class="ttname"><a href="classllvm_1_1raw__ostream.html#a8fdf5cdf041c8aded7e3308c1c3efacc">llvm::raw_ostream::indent</a></div><div class="ttdeci">raw_ostream &amp; indent(unsigned NumSpaces)</div><div class="ttdoc">indent - Insert &amp;#39;NumSpaces&amp;#39; spaces. </div><div class="ttdef"><b>Definition:</b> <a href="raw__ostream_8cpp_source.html#l00496">raw_ostream.cpp:496</a></div></div>
<div class="ttc" id="BasicBlock_8h_html"><div class="ttname"><a href="BasicBlock_8h.html">BasicBlock.h</a></div></div>
<div class="ttc" id="structllvm_1_1RuntimePointerChecking_1_1PointerInfo_html_a6ddd46705dc2cd974b46450d7d37759e"><div class="ttname"><a href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html#a6ddd46705dc2cd974b46450d7d37759e">llvm::RuntimePointerChecking::PointerInfo::IsWritePtr</a></div><div class="ttdeci">bool IsWritePtr</div><div class="ttdoc">Holds the information if this pointer is used for writing to memory. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00346">LoopAccessAnalysis.h:346</a></div></div>
<div class="ttc" id="namespacellvm_1_1SI_1_1KernelInputOffsets_html_a58b4eae4b0a45d478c7c0f3959b04612"><div class="ttname"><a href="namespacellvm_1_1SI_1_1KernelInputOffsets.html#a58b4eae4b0a45d478c7c0f3959b04612">llvm::SI::KernelInputOffsets::Offsets</a></div><div class="ttdeci">Offsets</div><div class="ttdoc">Offsets in bytes from the start of the input buffer. </div><div class="ttdef"><b>Definition:</b> <a href="SIInstrInfo_8h_source.html#l01157">SIInstrInfo.h:1157</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_ab3fc0225d8aaf8434026c3573f961f2c"><div class="ttname"><a href="classllvm_1_1Value.html#ab3fc0225d8aaf8434026c3573f961f2c">llvm::Value::getContext</a></div><div class="ttdeci">LLVMContext &amp; getContext() const</div><div class="ttdoc">All values hold a context through their type. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00744">Value.cpp:744</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_a1b570db2adb62a2c7ffca1869987682b"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#a1b570db2adb62a2c7ffca1869987682b">llvm::RuntimePointerChecking::reset</a></div><div class="ttdeci">void reset()</div><div class="ttdoc">Reset the state of the pointer runtime information. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00366">LoopAccessAnalysis.h:366</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a5a19768af81df7e5fe571bc08dcd48b3"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a5a19768af81df7e5fe571bc08dcd48b3">llvm::ScalarEvolution::isLoopInvariant</a></div><div class="ttdeci">bool isLoopInvariant(const SCEV *S, const Loop *L)</div><div class="ttdoc">Return true if the value of the given SCEV is unchanging in the specified loop. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l11806">ScalarEvolution.cpp:11806</a></div></div>
<div class="ttc" id="namespacellvm_html_a0d10fe510ced2849a8074fe81e5d04ce"><div class="ttname"><a href="namespacellvm.html#a0d10fe510ced2849a8074fe81e5d04ce">llvm::all_of</a></div><div class="ttdeci">bool all_of(R &amp;&amp;range, UnaryPredicate P)</div><div class="ttdoc">Provide wrappers to std::all_of which take ranges instead of having to pass begin/end explicitly...</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l01182">STLExtras.h:1182</a></div></div>
<div class="ttc" id="namespacellvm_html_ad8c0f164d625c83cfd0028a2d8daf07e"><div class="ttname"><a href="namespacellvm.html#ad8c0f164d625c83cfd0028a2d8daf07e">llvm::createLAAPass</a></div><div class="ttdeci">Pass * createLAAPass()</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02465">LoopAccessAnalysis.cpp:2465</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_a616cdd740bc8d7ccbed42ce872ca86c4"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#a616cdd740bc8d7ccbed42ce872ca86c4">llvm::RuntimePointerChecking::print</a></div><div class="ttdeci">void print(raw_ostream &amp;OS, unsigned Depth=0) const</div><div class="ttdoc">Print the list run-time memory checks necessary. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00472">LoopAccessAnalysis.cpp:472</a></div></div>
<div class="ttc" id="classllvm_1_1DebugLoc_html"><div class="ttname"><a href="classllvm_1_1DebugLoc.html">llvm::DebugLoc</a></div><div class="ttdoc">A debug info location. </div><div class="ttdef"><b>Definition:</b> <a href="DebugLoc_8h_source.html#l00033">DebugLoc.h:33</a></div></div>
<div class="ttc" id="structllvm_1_1LoopStandardAnalysisResults_html"><div class="ttname"><a href="structllvm_1_1LoopStandardAnalysisResults.html">llvm::LoopStandardAnalysisResults</a></div><div class="ttdoc">The adaptor from a function pass to a loop pass computes these analyses and makes them available to t...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAnalysisManager_8h_source.html#l00053">LoopAnalysisManager.h:53</a></div></div>
<div class="ttc" id="LLParser_8cpp_html_a33ece1ef8074506a15d7f86eb76dbae6"><div class="ttname"><a href="LLParser_8cpp.html#a33ece1ef8074506a15d7f86eb76dbae6">F</a></div><div class="ttdeci">F(f)</div></div>
<div class="ttc" id="classllvm_1_1Type_html_a5ab2d0b0f0b8ceec3b907184e7567197"><div class="ttname"><a href="classllvm_1_1Type.html#a5ab2d0b0f0b8ceec3b907184e7567197">llvm::Type::getPointerAddressSpace</a></div><div class="ttdeci">unsigned getPointerAddressSpace() const</div><div class="ttdoc">Get the address space of this pointer or pointer vector type. </div><div class="ttdef"><b>Definition:</b> <a href="DerivedTypes_8h_source.html#l00635">DerivedTypes.h:635</a></div></div>
<div class="ttc" id="classllvm_1_1Function_html"><div class="ttname"><a href="classllvm_1_1Function.html">llvm::Function</a></div><div class="ttdef"><b>Definition:</b> <a href="Function_8h_source.html#l00059">Function.h:59</a></div></div>
<div class="ttc" id="BlockFrequencyInfo_8cpp_html_af1bff759151fc332f9c9021578b15be6"><div class="ttname"><a href="BlockFrequencyInfo_8cpp.html#af1bff759151fc332f9c9021578b15be6">true</a></div><div class="ttdeci">block Block Frequency true</div><div class="ttdef"><b>Definition:</b> <a href="BlockFrequencyInfo_8cpp_source.html#l00294">BlockFrequencyInfo.cpp:294</a></div></div>
<div class="ttc" id="classllvm_1_1LoadInst_html"><div class="ttname"><a href="classllvm_1_1LoadInst.html">llvm::LoadInst</a></div><div class="ttdoc">An instruction for reading from memory. </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00169">Instructions.h:169</a></div></div>
<div class="ttc" id="classllvm_1_1EquivalenceClasses_html_aef0dc9d4f28e4982cfd008cc4b53e479"><div class="ttname"><a href="classllvm_1_1EquivalenceClasses.html#aef0dc9d4f28e4982cfd008cc4b53e479">llvm::EquivalenceClasses::unionSets</a></div><div class="ttdeci">member_iterator unionSets(const ElemTy &amp;V1, const ElemTy &amp;V2)</div><div class="ttdoc">union - Merge the two equivalence sets for the specified values, inserting them if they do not alread...</div><div class="ttdef"><b>Definition:</b> <a href="EquivalenceClasses_8h_source.html#l00217">EquivalenceClasses.h:217</a></div></div>
<div class="ttc" id="HexagonCommonGEP_8cpp_html_ad532e8710e50302e0a376b61c91fa91d"><div class="ttname"><a href="HexagonCommonGEP_8cpp.html#ad532e8710e50302e0a376b61c91fa91d">GEP</a></div><div class="ttdeci">Hexagon Common GEP</div><div class="ttdef"><b>Definition:</b> <a href="HexagonCommonGEP_8cpp_source.html#l00171">HexagonCommonGEP.cpp:171</a></div></div>
<div class="ttc" id="classllvm_1_1MemoryDepChecker_html"><div class="ttname"><a href="classllvm_1_1MemoryDepChecker.html">llvm::MemoryDepChecker</a></div><div class="ttdoc">Checks memory dependences among accesses to the same underlying object to determine whether there vec...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00092">LoopAccessAnalysis.h:92</a></div></div>
<div class="ttc" id="structllvm_1_1VectorizerParams_html_a22854382d27cb43d471731779195e9a8"><div class="ttname"><a href="structllvm_1_1VectorizerParams.html#a22854382d27cb43d471731779195e9a8">llvm::VectorizerParams::VectorizationFactor</a></div><div class="ttdeci">static unsigned VectorizationFactor</div><div class="ttdoc">VF as overridden by the user. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00047">LoopAccessAnalysis.h:47</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html_a499ea32ca1b8d16cedfe01d1e5b08f29"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html#a499ea32ca1b8d16cedfe01d1e5b08f29">llvm::SmallVectorImpl::reserve</a></div><div class="ttdeci">void reserve(size_type N)</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00369">SmallVector.h:369</a></div></div>
<div class="ttc" id="namespacellvm_html_a1eb5609345b906d024fbf9e4bc1adc06afe578efb7ca235af77fb0eef7edcf639"><div class="ttname"><a href="namespacellvm.html#a1eb5609345b906d024fbf9e4bc1adc06afe578efb7ca235af77fb0eef7edcf639">llvm::Depth</a></div><div class="ttdef"><b>Definition:</b> <a href="SIMachineScheduler_8h_source.html#l00036">SIMachineScheduler.h:36</a></div></div>
<div class="ttc" id="NVVMIntrRange_8cpp_html_a7df34dbf636f2fbbb00f2b86eccdb1eb"><div class="ttname"><a href="NVVMIntrRange_8cpp.html#a7df34dbf636f2fbbb00f2b86eccdb1eb">High</a></div><div class="ttdeci">uint64_t High</div><div class="ttdef"><b>Definition:</b> <a href="NVVMIntrRange_8cpp_source.html#l00068">NVVMIntrRange.cpp:68</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_abb0442118037e1a5cf98ecead9627a5e"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#abb0442118037e1a5cf98ecead9627a5e">areStridedAccessesIndependent</a></div><div class="ttdeci">static bool areStridedAccessesIndependent(uint64_t Distance, uint64_t Stride, uint64_t TypeByteSize)</div><div class="ttdoc">Check the dependence for two accesses with the same stride Stride. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01411">LoopAccessAnalysis.cpp:1411</a></div></div>
<div class="ttc" id="namespacellvm_1_1cl_html_a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6"><div class="ttname"><a href="namespacellvm_1_1cl.html#a68075925a54790e71ca790e1d4f21a40a263ac008d8d31f13ce460395fc4cf7e6">llvm::cl::Hidden</a></div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00148">CommandLine.h:148</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a512fe2c15ea651294688eeec1341644c"><div class="ttname"><a href="classllvm_1_1APInt.html#a512fe2c15ea651294688eeec1341644c">llvm::APInt::getBitWidth</a></div><div class="ttdeci">unsigned getBitWidth() const</div><div class="ttdoc">Return the number of bits in the APInt. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01566">APInt.h:1566</a></div></div>
<div class="ttc" id="namespacellvm_html_a11c66d01880f53332fc7ad53f565b039"><div class="ttname"><a href="namespacellvm.html#a11c66d01880f53332fc7ad53f565b039">llvm::getVectorIntrinsicIDForCall</a></div><div class="ttdeci">Intrinsic::ID getVectorIntrinsicIDForCall(const CallInst *CI, const TargetLibraryInfo *TLI)</div><div class="ttdoc">Returns intrinsic ID for call. </div><div class="ttdef"><b>Definition:</b> <a href="VectorUtils_8cpp_source.html#l00113">VectorUtils.cpp:113</a></div></div>
<div class="ttc" id="EquivalenceClasses_8h_html"><div class="ttname"><a href="EquivalenceClasses_8h.html">EquivalenceClasses.h</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_af4009b07ade042922fe2f94d32b47844"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#af4009b07ade042922fe2f94d32b47844">llvm::RuntimePointerChecking::insert</a></div><div class="ttdeci">void insert(Loop *Lp, Value *Ptr, bool WritePtr, unsigned DepSetId, unsigned ASId, const ValueToValueMap &amp;Strides, PredicatedScalarEvolution &amp;PSE)</div><div class="ttdoc">Insert a pointer and calculate the start and end SCEVs. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00190">LoopAccessAnalysis.cpp:190</a></div></div>
<div class="ttc" id="ScalarEvolutionExpander_8h_html"><div class="ttname"><a href="ScalarEvolutionExpander_8h.html">ScalarEvolutionExpander.h</a></div></div>
<div class="ttc" id="namespacellvm_html_aee44336886a06f3c1b8c35c701ba8316"><div class="ttname"><a href="namespacellvm.html#aee44336886a06f3c1b8c35c701ba8316">llvm::getLoadStorePointerOperand</a></div><div class="ttdeci">const Value * getLoadStorePointerOperand(const Value *V)</div><div class="ttdoc">A helper function that returns the pointer operand of a load or store instruction. </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l05260">Instructions.h:5260</a></div></div>
<div class="ttc" id="classllvm_1_1AnalysisUsage_html_ae5c60fd282ee894c87ea02c3f0fcb6d0"><div class="ttname"><a href="classllvm_1_1AnalysisUsage.html#ae5c60fd282ee894c87ea02c3f0fcb6d0">llvm::AnalysisUsage::addRequired</a></div><div class="ttdeci">AnalysisUsage &amp; addRequired()</div><div class="ttdef"><b>Definition:</b> <a href="PassAnalysisSupport_8h_source.html#l00065">PassAnalysisSupport.h:65</a></div></div>
<div class="ttc" id="classllvm_1_1BasicBlock_html_afc70e919c88c86159cc94cea29b6c210"><div class="ttname"><a href="classllvm_1_1BasicBlock.html#afc70e919c88c86159cc94cea29b6c210">llvm::BasicBlock::getModule</a></div><div class="ttdeci">const Module * getModule() const</div><div class="ttdoc">Return the module owning the function this basic block belongs to, or nullptr if the function does no...</div><div class="ttdef"><b>Definition:</b> <a href="BasicBlock_8cpp_source.html#l00140">BasicBlock.cpp:140</a></div></div>
<div class="ttc" id="PassSupport_8h_html_a14724f1ccf528e73bb29bc9230737967"><div class="ttname"><a href="PassSupport_8h.html#a14724f1ccf528e73bb29bc9230737967">INITIALIZE_PASS_DEPENDENCY</a></div><div class="ttdeci">#define INITIALIZE_PASS_DEPENDENCY(depName)</div><div class="ttdef"><b>Definition:</b> <a href="PassSupport_8h_source.html#l00050">PassSupport.h:50</a></div></div>
<div class="ttc" id="namespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition:</b> <a href="BitVector_8h_source.html#l00937">BitVector.h:937</a></div></div>
<div class="ttc" id="classllvm_1_1LoopBase_html_a389bb3581ba3c8094b89642efaf8e514"><div class="ttname"><a href="classllvm_1_1LoopBase.html#a389bb3581ba3c8094b89642efaf8e514">llvm::LoopBase::getNumBackEdges</a></div><div class="ttdeci">unsigned getNumBackEdges() const</div><div class="ttdoc">Calculate the number of back edges to the loop header. </div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l00233">LoopInfo.h:233</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVWrapPredicate_html_a0cfd938ff9c572d287e5e7923624db70a17e825823d4b6a92c1b221c4460c91a3"><div class="ttname"><a href="classllvm_1_1SCEVWrapPredicate.html#a0cfd938ff9c572d287e5e7923624db70a17e825823d4b6a92c1b221c4460c91a3">llvm::SCEVWrapPredicate::IncrementNUSW</a></div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l00328">ScalarEvolution.h:328</a></div></div>
<div class="ttc" id="namespacellvm_html_a2554a96c67bdd7d0a62855a844ec55b0a945d5e233cf7d6240f6b783b36a374ff"><div class="ttname"><a href="namespacellvm.html#a2554a96c67bdd7d0a62855a844ec55b0a945d5e233cf7d6240f6b783b36a374ff">llvm::AlignStyle::Left</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_ae61f17d62c8a79bc5cffa63a2f152311"><div class="ttname"><a href="classllvm_1_1Type.html#ae61f17d62c8a79bc5cffa63a2f152311">llvm::Type::getPointerElementType</a></div><div class="ttdeci">Type * getPointerElementType() const</div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00381">Type.h:381</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVAddRecExpr_html_af6314c51a3cc5a619beb697246177bf0"><div class="ttname"><a href="classllvm_1_1SCEVAddRecExpr.html#af6314c51a3cc5a619beb697246177bf0">llvm::SCEVAddRecExpr::getLoop</a></div><div class="ttdeci">const Loop * getLoop() const</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00307">ScalarEvolutionExpressions.h:307</a></div></div>
<div class="ttc" id="classllvm_1_1Module_html_a6d883605206368bc536cc9ded97209b8"><div class="ttname"><a href="classllvm_1_1Module.html#a6d883605206368bc536cc9ded97209b8">llvm::Module::getDataLayout</a></div><div class="ttdeci">const DataLayout &amp; getDataLayout() const</div><div class="ttdoc">Get the data layout for the module&amp;#39;s target platform. </div><div class="ttdef"><b>Definition:</b> <a href="Module_8cpp_source.html#l00369">Module.cpp:369</a></div></div>
<div class="ttc" id="structllvm_1_1VectorizerParams_html_a122bb2d8a6d57352811c1a7aa72771be"><div class="ttname"><a href="structllvm_1_1VectorizerParams.html#a122bb2d8a6d57352811c1a7aa72771be">llvm::VectorizerParams::MaxVectorWidth</a></div><div class="ttdeci">static const unsigned MaxVectorWidth</div><div class="ttdoc">Maximum SIMD width. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00044">LoopAccessAnalysis.h:44</a></div></div>
<div class="ttc" id="LoopInfo_8h_html"><div class="ttname"><a href="LoopInfo_8h.html">LoopInfo.h</a></div></div>
<div class="ttc" id="structllvm_1_1MemoryDepChecker_1_1Dependence_html_a4cbfae0900c7bc2adb637840e589ed4e"><div class="ttname"><a href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a4cbfae0900c7bc2adb637840e589ed4e">llvm::MemoryDepChecker::Dependence::isPossiblyBackward</a></div><div class="ttdeci">bool isPossiblyBackward() const</div><div class="ttdoc">May be a lexically backward dependence type (includes Unknown). </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01270">LoopAccessAnalysis.cpp:1270</a></div></div>
<div class="ttc" id="AliasSetTracker_8h_html"><div class="ttname"><a href="AliasSetTracker_8h.html">AliasSetTracker.h</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_a8ebeb3910d03eaa4e30ef67edc21df0b"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#a8ebeb3910d03eaa4e30ef67edc21df0b">llvm::RuntimePointerChecking::arePointersInSamePartition</a></div><div class="ttdeci">static bool arePointersInSamePartition(const SmallVectorImpl&lt; int &gt; &amp;PtrToPartition, unsigned PtrIdx1, unsigned PtrIdx2)</div><div class="ttdoc">Check if pointers are in the same partition. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00427">LoopAccessAnalysis.cpp:427</a></div></div>
<div class="ttc" id="classllvm_1_1OptimizationRemarkAnalysis_html"><div class="ttname"><a href="classllvm_1_1OptimizationRemarkAnalysis.html">llvm::OptimizationRemarkAnalysis</a></div><div class="ttdoc">Diagnostic information for optimization analysis remarks. </div><div class="ttdef"><b>Definition:</b> <a href="DiagnosticInfo_8h_source.html#l00758">DiagnosticInfo.h:758</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html">llvm::SmallVectorImpl&lt; int &gt;</a></div></div>
<div class="ttc" id="classllvm_1_1IRBuilder_html"><div class="ttname"><a href="classllvm_1_1IRBuilder.html">llvm::IRBuilder&lt;&gt;</a></div></div>
<div class="ttc" id="STLExtras_8h_html"><div class="ttname"><a href="STLExtras_8h.html">STLExtras.h</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a29cffc9779968caccc3dd405819e55f5"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a29cffc9779968caccc3dd405819e55f5">llvm::ScalarEvolution::getEqualPredicate</a></div><div class="ttdeci">const SCEVPredicate * getEqualPredicate(const SCEV *LHS, const SCEV *RHS)</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l12134">ScalarEvolution.cpp:12134</a></div></div>
<div class="ttc" id="namespacefalse_html"><div class="ttname"><a href="namespacefalse.html">false</a></div><div class="ttdef"><b>Definition:</b> <a href="StackSlotColoring_8cpp_source.html#l00142">StackSlotColoring.cpp:142</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_a24e5c89884a8b7b92a1d27da4e94e230"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#a24e5c89884a8b7b92a1d27da4e94e230">llvm::RuntimePointerChecking::getNumberOfChecks</a></div><div class="ttdeci">unsigned getNumberOfChecks() const</div><div class="ttdoc">Returns the number of run-time checks required according to needsChecking. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00440">LoopAccessAnalysis.h:440</a></div></div>
<div class="ttc" id="namespacellvm_1_1Intrinsic_html_a80add6b3b1cdaec560907995127adc16"><div class="ttname"><a href="namespacellvm_1_1Intrinsic.html#a80add6b3b1cdaec560907995127adc16">llvm::Intrinsic::ID</a></div><div class="ttdeci">unsigned ID</div><div class="ttdef"><b>Definition:</b> <a href="TargetTransformInfo_8h_source.html#l00039">TargetTransformInfo.h:39</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html"><div class="ttname"><a href="classllvm_1_1Instruction.html">llvm::Instruction</a></div><div class="ttdef"><b>Definition:</b> <a href="IR_2Instruction_8h_source.html#l00043">Instruction.h:43</a></div></div>
<div class="ttc" id="TargetLibraryInfo_8h_html"><div class="ttname"><a href="TargetLibraryInfo_8h.html">TargetLibraryInfo.h</a></div></div>
<div class="ttc" id="classllvm_1_1PredicatedScalarEvolution_html_a0b369e991301543c2120405809119d36"><div class="ttname"><a href="classllvm_1_1PredicatedScalarEvolution.html#a0b369e991301543c2120405809119d36">llvm::PredicatedScalarEvolution::addPredicate</a></div><div class="ttdeci">void addPredicate(const SCEVPredicate &amp;Pred)</div><div class="ttdoc">Adds a new predicate. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l12479">ScalarEvolution.cpp:12479</a></div></div>
<div class="ttc" id="APInt_8h_html"><div class="ttname"><a href="APInt_8h.html">APInt.h</a></div><div class="ttdoc">This file implements a class to represent arbitrary precision integral constant values and operations...</div></div>
<div class="ttc" id="structllvm_1_1MemoryDepChecker_1_1Dependence_html_af1ce4569bdd7d1341b095de3aeeb2765"><div class="ttname"><a href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#af1ce4569bdd7d1341b095de3aeeb2765">llvm::MemoryDepChecker::Dependence::DepName</a></div><div class="ttdeci">static const char * DepName[]</div><div class="ttdoc">String version of the types. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00143">LoopAccessAnalysis.h:143</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVConstant_html_a17304ab072a5b259c03e766a2b78a30b"><div class="ttname"><a href="classllvm_1_1SCEVConstant.html#a17304ab072a5b259c03e766a2b78a30b">llvm::SCEVConstant::getAPInt</a></div><div class="ttdeci">const APInt &amp; getAPInt() const</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00057">ScalarEvolutionExpressions.h:57</a></div></div>
<div class="ttc" id="Dominators_8h_html"><div class="ttname"><a href="Dominators_8h.html">Dominators.h</a></div></div>
<div class="ttc" id="classllvm_1_1LoopBase_html_a58c5b170ea68b41e94ebb0019523a68f"><div class="ttname"><a href="classllvm_1_1LoopBase.html#a58c5b170ea68b41e94ebb0019523a68f">llvm::LoopBase::getHeader</a></div><div class="ttdeci">BlockT * getHeader() const</div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l00105">LoopInfo.h:105</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVConstant_html_ab319aacb4209aeca2c72d50a0d585b47"><div class="ttname"><a href="classllvm_1_1SCEVConstant.html#ab319aacb4209aeca2c72d50a0d585b47">llvm::SCEVConstant::getValue</a></div><div class="ttdeci">ConstantInt * getValue() const</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00056">ScalarEvolutionExpressions.h:56</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolutionWrapperPass_html"><div class="ttname"><a href="classllvm_1_1ScalarEvolutionWrapperPass.html">llvm::ScalarEvolutionWrapperPass</a></div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l01943">ScalarEvolution.h:1943</a></div></div>
<div class="ttc" id="namespacellvm_1_1AMDGPU_1_1PALMD_html_af892c75285b0f64d58ca76cb73059adf"><div class="ttname"><a href="namespacellvm_1_1AMDGPU_1_1PALMD.html#af892c75285b0f64d58ca76cb73059adf">llvm::AMDGPU::PALMD::Key</a></div><div class="ttdeci">Key</div><div class="ttdoc">PAL metadata keys. </div><div class="ttdef"><b>Definition:</b> <a href="AMDGPUMetadata_8h_source.html#l00471">AMDGPUMetadata.h:471</a></div></div>
<div class="ttc" id="SIInstrInfo_8cpp_html_a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791"><div class="ttname"><a href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a></div><div class="ttdef"><b>Definition:</b> <a href="SIInstrInfo_8cpp_source.html#l06317">SIInstrInfo.cpp:6317</a></div></div>
<div class="ttc" id="classllvm_1_1IRBuilder_html_a5e3bfda687f0bb870891d2b7722e7c2a"><div class="ttname"><a href="classllvm_1_1IRBuilder.html#a5e3bfda687f0bb870891d2b7722e7c2a">llvm::IRBuilder::CreateBitCast</a></div><div class="ttdeci">Value * CreateBitCast(Value *V, Type *DestTy, const Twine &amp;Name=&quot;&quot;)</div><div class="ttdef"><b>Definition:</b> <a href="IRBuilder_8h_source.html#l02101">IRBuilder.h:2101</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_af2daa0ee117afefed4c82eee55bf97b7"><div class="ttname"><a href="classllvm_1_1APInt.html#af2daa0ee117afefed4c82eee55bf97b7">llvm::APInt::getSExtValue</a></div><div class="ttdeci">int64_t getSExtValue() const</div><div class="ttdoc">Get sign extended value. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l01632">APInt.h:1632</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_a6393a2d4fe7e10b28a0dcc35f881567b"><div class="ttname"><a href="classllvm_1_1Value.html#a6393a2d4fe7e10b28a0dcc35f881567b">llvm::Value::getType</a></div><div class="ttdeci">Type * getType() const</div><div class="ttdoc">All values are typed, get the type of this value. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00246">Value.h:246</a></div></div>
<div class="ttc" id="Operator_8h_html"><div class="ttname"><a href="Operator_8h.html">Operator.h</a></div></div>
<div class="ttc" id="classllvm_1_1EquivalenceClasses_html_afa7f2c45050e420ca2c11e339d869c20"><div class="ttname"><a href="classllvm_1_1EquivalenceClasses.html#afa7f2c45050e420ca2c11e339d869c20">llvm::EquivalenceClasses::member_begin</a></div><div class="ttdeci">member_iterator member_begin(iterator I) const</div><div class="ttdef"><b>Definition:</b> <a href="EquivalenceClasses_8h_source.html#l00153">EquivalenceClasses.h:153</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVAddRecExpr_html"><div class="ttname"><a href="classllvm_1_1SCEVAddRecExpr.html">llvm::SCEVAddRecExpr</a></div><div class="ttdoc">This node represents a polynomial recurrence on the trip count of the specified loop. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00296">ScalarEvolutionExpressions.h:296</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_acfcd22eb38dbfe1acbf138754297437a"><div class="ttname"><a href="classllvm_1_1DataLayout.html#acfcd22eb38dbfe1acbf138754297437a">llvm::DataLayout::getTypeStoreSize</a></div><div class="ttdeci">TypeSize getTypeStoreSize(Type *Ty) const</div><div class="ttdoc">Returns the maximum number of bytes that may be overwritten by storing the specified type...</div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00454">DataLayout.h:454</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_aca99374d317f84dc3b73915b7f2e955c"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#aca99374d317f84dc3b73915b7f2e955c">EnableForwardingConflictDetection</a></div><div class="ttdeci">static cl::opt&lt; bool &gt; EnableForwardingConflictDetection(&quot;store-to-load-forwarding-conflict-detection&quot;, cl::Hidden, cl::desc(&quot;Enable conflict detection in loop-access analysis&quot;), cl::init(true))</div><div class="ttdoc">Enable store-to-load forwarding conflict detection. </div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a9b5fc98b47d44d1150d3610bdfab1430"><div class="ttname"><a href="classllvm_1_1APInt.html#a9b5fc98b47d44d1150d3610bdfab1430">llvm::APInt::sextOrTrunc</a></div><div class="ttdeci">APInt sextOrTrunc(unsigned width) const</div><div class="ttdoc">Sign extend or truncate to width. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8cpp_source.html#l00963">APInt.cpp:963</a></div></div>
<div class="ttc" id="classllvm_1_1EquivalenceClasses_html_a902c4503f25e4565da04114268650985"><div class="ttname"><a href="classllvm_1_1EquivalenceClasses.html#a902c4503f25e4565da04114268650985">llvm::EquivalenceClasses::insert</a></div><div class="ttdeci">iterator insert(const ElemTy &amp;Data)</div><div class="ttdoc">insert - Insert a new value into the union/find set, ignoring the request if the value already exists...</div><div class="ttdef"><b>Definition:</b> <a href="EquivalenceClasses_8h_source.html#l00199">EquivalenceClasses.h:199</a></div></div>
<div class="ttc" id="SmallPtrSet_8h_html"><div class="ttname"><a href="SmallPtrSet_8h.html">SmallPtrSet.h</a></div></div>
<div class="ttc" id="classllvm_1_1PredicatedScalarEvolution_html_aa364810e8fe30937277d9dd8a301c4c9"><div class="ttname"><a href="classllvm_1_1PredicatedScalarEvolution.html#aa364810e8fe30937277d9dd8a301c4c9">llvm::PredicatedScalarEvolution::getAsAddRec</a></div><div class="ttdeci">const SCEVAddRecExpr * getAsAddRec(Value *V)</div><div class="ttdoc">Attempts to produce an AddRecExpr for V by adding additional SCEV predicates. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l12532">ScalarEvolution.cpp:12532</a></div></div>
<div class="ttc" id="LoopAnalysisManager_8h_html"><div class="ttname"><a href="LoopAnalysisManager_8h.html">LoopAnalysisManager.h</a></div><div class="ttdoc">This header provides classes for managing per-loop analyses. </div></div>
<div class="ttc" id="classllvm_1_1ArrayRef_html"><div class="ttname"><a href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a></div><div class="ttdoc">ArrayRef - Represent a constant reference to an array (0 or more elements consecutively in memory)...</div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l00032">APInt.h:32</a></div></div>
<div class="ttc" id="classllvm_1_1SCEV_html_af43000d4dcb7d6d63cb6e36933ed3f6fa2f7a8775a783f7ea3ad24b3f9cb5d949"><div class="ttname"><a href="classllvm_1_1SCEV.html#af43000d4dcb7d6d63cb6e36933ed3f6fa2f7a8775a783f7ea3ad24b3f9cb5d949">llvm::SCEV::FlagNSW</a></div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l00117">ScalarEvolution.h:117</a></div></div>
<div class="ttc" id="classllvm_1_1EquivalenceClasses_html_a1445a41f4405069e553c6a91ab7d6df0"><div class="ttname"><a href="classllvm_1_1EquivalenceClasses.html#a1445a41f4405069e553c6a91ab7d6df0">llvm::EquivalenceClasses::findValue</a></div><div class="ttdeci">iterator findValue(const ElemTy &amp;V) const</div><div class="ttdoc">findValue - Return an iterator to the specified value. </div><div class="ttdef"><b>Definition:</b> <a href="EquivalenceClasses_8h_source.html#l00163">EquivalenceClasses.h:163</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html_ae7a4de5d3c7d0f2ba56e3933fb2007bf"><div class="ttname"><a href="classllvm_1_1Value.html#ae7a4de5d3c7d0f2ba56e3933fb2007bf">llvm::Value::stripAndAccumulateInBoundsConstantOffsets</a></div><div class="ttdeci">const Value * stripAndAccumulateInBoundsConstantOffsets(const DataLayout &amp;DL, APInt &amp;Offset) const</div><div class="ttdoc">This is a wrapper around stripAndAccumulateConstantOffsets with the in-bounds requirement set to fals...</div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00602">Value.h:602</a></div></div>
<div class="ttc" id="classllvm_1_1StoreInst_html"><div class="ttname"><a href="classllvm_1_1StoreInst.html">llvm::StoreInst</a></div><div class="ttdoc">An instruction for storing to memory. </div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00331">Instructions.h:331</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVAddRecExpr_html_a7eec28400b00678b1fb2b5f55ef7ac1b"><div class="ttname"><a href="classllvm_1_1SCEVAddRecExpr.html#a7eec28400b00678b1fb2b5f55ef7ac1b">llvm::SCEVAddRecExpr::getStepRecurrence</a></div><div class="ttdeci">const SCEV * getStepRecurrence(ScalarEvolution &amp;SE) const</div><div class="ttdoc">Constructs and returns the recurrence indicating how much this expression steps by. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00313">ScalarEvolutionExpressions.h:313</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a6df4e7db7761942ca740d19fba41b857"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a6df4e7db7761942ca740d19fba41b857">getFirstInst</a></div><div class="ttdeci">static Instruction * getFirstInst(Instruction *FirstInst, Value *V, Instruction *Loc)</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02121">LoopAccessAnalysis.cpp:2121</a></div></div>
<div class="ttc" id="classllvm_1_1DominatorTree_html"><div class="ttname"><a href="classllvm_1_1DominatorTree.html">llvm::DominatorTree</a></div><div class="ttdoc">Concrete subclass of DominatorTreeBase that is used to compute a normal dominator tree...</div><div class="ttdef"><b>Definition:</b> <a href="Dominators_8h_source.html#l00144">Dominators.h:144</a></div></div>
<div class="ttc" id="DepthFirstIterator_8h_html"><div class="ttname"><a href="DepthFirstIterator_8h.html">DepthFirstIterator.h</a></div></div>
<div class="ttc" id="namespacellvm_1_1dwarf_html_a5d3c920b66ea797d6adb243862fdf47a"><div class="ttname"><a href="namespacellvm_1_1dwarf.html#a5d3c920b66ea797d6adb243862fdf47a">llvm::dwarf::Index</a></div><div class="ttdeci">Index</div><div class="ttdef"><b>Definition:</b> <a href="Dwarf_8h_source.html#l00374">Dwarf.h:374</a></div></div>
<div class="ttc" id="classllvm_1_1PredicatedScalarEvolution_html_ae0994d8207b94ad22ecebc1a6bc580f1"><div class="ttname"><a href="classllvm_1_1PredicatedScalarEvolution.html#ae0994d8207b94ad22ecebc1a6bc580f1">llvm::PredicatedScalarEvolution::getSCEV</a></div><div class="ttdeci">const SCEV * getSCEV(Value *V)</div><div class="ttdoc">Returns the SCEV expression of V, in the context of the current SCEV predicate. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l12451">ScalarEvolution.cpp:12451</a></div></div>
<div class="ttc" id="classllvm_1_1IRBuilder_html_ab1475cfd218c3655256eec53a9d6b1dd"><div class="ttname"><a href="classllvm_1_1IRBuilder.html#ab1475cfd218c3655256eec53a9d6b1dd">llvm::IRBuilder::CreateOr</a></div><div class="ttdeci">Value * CreateOr(Value *LHS, Value *RHS, const Twine &amp;Name=&quot;&quot;)</div><div class="ttdef"><b>Definition:</b> <a href="IRBuilder_8h_source.html#l01387">IRBuilder.h:1387</a></div></div>
<div class="ttc" id="classllvm_1_1DenseMapBase_html_a0c047f127ed4380a6f383d70bec4eb94"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a0c047f127ed4380a6f383d70bec4eb94">llvm::DenseMapBase::find</a></div><div class="ttdeci">iterator find(const_arg_type_t&lt; KeyT &gt; Val)</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00150">DenseMap.h:150</a></div></div>
<div class="ttc" id="classllvm_1_1SCEV_html_af43000d4dcb7d6d63cb6e36933ed3f6fae022582ed4b56bdb108b4488809e11e6"><div class="ttname"><a href="classllvm_1_1SCEV.html#af43000d4dcb7d6d63cb6e36933ed3f6fae022582ed4b56bdb108b4488809e11e6">llvm::SCEV::NoWrapMask</a></div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l00118">ScalarEvolution.h:118</a></div></div>
<div class="ttc" id="namespacellvm_html_ab1b85be3cd0fffad1d76673016015e02"><div class="ttname"><a href="namespacellvm.html#ab1b85be3cd0fffad1d76673016015e02">llvm::isConsecutiveAccess</a></div><div class="ttdeci">bool isConsecutiveAccess(Value *A, Value *B, const DataLayout &amp;DL, ScalarEvolution &amp;SE, bool CheckType=true)</div><div class="ttdoc">Returns true if the memory operations A and B are consecutive. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01172">LoopAccessAnalysis.cpp:1172</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessInfo_html_a84a5de37c9e2f182943639f92cf684b7"><div class="ttname"><a href="classllvm_1_1LoopAccessInfo.html#a84a5de37c9e2f182943639f92cf684b7">llvm::LoopAccessInfo::addRuntimeChecks</a></div><div class="ttdeci">std::pair&lt; Instruction *, Instruction * &gt; addRuntimeChecks(Instruction *Loc) const</div><div class="ttdoc">Add code that checks at runtime if the accessed arrays overlap. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02275">LoopAccessAnalysis.cpp:2275</a></div></div>
<div class="ttc" id="structllvm_1_1MemoryDepChecker_1_1Dependence_html_a623aabb69f601ada6b290ac7d15e69a5"><div class="ttname"><a href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a623aabb69f601ada6b290ac7d15e69a5">llvm::MemoryDepChecker::Dependence::isForward</a></div><div class="ttdeci">bool isForward() const</div><div class="ttdoc">Lexically forward dependence. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01274">LoopAccessAnalysis.cpp:1274</a></div></div>
<div class="ttc" id="classllvm_1_1GetElementPtrInst_html"><div class="ttname"><a href="classllvm_1_1GetElementPtrInst.html">llvm::GetElementPtrInst</a></div><div class="ttdoc">an instruction for type-safe pointer arithmetic to access elements of arrays and structs ...</div><div class="ttdef"><b>Definition:</b> <a href="Instructions_8h_source.html#l00892">Instructions.h:892</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_a6804d9caf15411f55e7b9e9f397f0422"><div class="ttname"><a href="classllvm_1_1APInt.html#a6804d9caf15411f55e7b9e9f397f0422">llvm::APInt::isNegative</a></div><div class="ttdeci">bool isNegative() const</div><div class="ttdoc">Determine sign of this APInt. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l00363">APInt.h:363</a></div></div>
<div class="ttc" id="CommandLine_8h_html"><div class="ttname"><a href="CommandLine_8h.html">CommandLine.h</a></div></div>
<div class="ttc" id="classllvm_1_1MemoryLocation_html_a18e5a3f1d71ba10a624f2a8e5121cf1f"><div class="ttname"><a href="classllvm_1_1MemoryLocation.html#a18e5a3f1d71ba10a624f2a8e5121cf1f">llvm::MemoryLocation::get</a></div><div class="ttdeci">static MemoryLocation get(const LoadInst *LI)</div><div class="ttdoc">Return a location with information about the memory reference by the given instruction. </div><div class="ttdef"><b>Definition:</b> <a href="MemoryLocation_8cpp_source.html#l00035">MemoryLocation.cpp:35</a></div></div>
<div class="ttc" id="namespacellvm_1_1cl_html_a10a041239ae1870cfcc064bfaa79fb65"><div class="ttname"><a href="namespacellvm_1_1cl.html#a10a041239ae1870cfcc064bfaa79fb65">llvm::cl::init</a></div><div class="ttdeci">initializer&lt; Ty &gt; init(const Ty &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00435">CommandLine.h:435</a></div></div>
<div class="ttc" id="classllvm_1_1sys_1_1path_1_1const__iterator_html_a8a503d1cbee10d1b8c8f5ac2a03b90df"><div class="ttname"><a href="classllvm_1_1sys_1_1path_1_1const__iterator.html#a8a503d1cbee10d1b8c8f5ac2a03b90df">llvm::sys::path::const_iterator::end</a></div><div class="ttdeci">friend const_iterator end(StringRef path)</div><div class="ttdoc">Get end iterator over path. </div><div class="ttdef"><b>Definition:</b> <a href="Path_8cpp_source.html#l00233">Path.cpp:233</a></div></div>
<div class="ttc" id="namespacellvm_html_ad3428471506e6c03e9395a697a897a83"><div class="ttname"><a href="namespacellvm.html#ad3428471506e6c03e9395a697a897a83">llvm::GetUnderlyingObjects</a></div><div class="ttdeci">void GetUnderlyingObjects(const Value *V, SmallVectorImpl&lt; const Value *&gt; &amp;Objects, const DataLayout &amp;DL, LoopInfo *LI=nullptr, unsigned MaxLookup=6)</div><div class="ttdoc">This method is similar to GetUnderlyingObject except that it can look through phi and select instruct...</div><div class="ttdef"><b>Definition:</b> <a href="ValueTracking_8cpp_source.html#l03926">ValueTracking.cpp:3926</a></div></div>
<div class="ttc" id="BuiltinGCs_8cpp_html_a7abf5fb4071cb25dbce06dfb5ee3c937"><div class="ttname"><a href="BuiltinGCs_8cpp.html#a7abf5fb4071cb25dbce06dfb5ee3c937">B</a></div><div class="ttdeci">static GCRegistry::Add&lt; OcamlGC &gt; B(&quot;ocaml&quot;, &quot;ocaml 3.10-compatible GC&quot;)</div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_ac93dd46031b1e2f9fdb0cee7a99681df"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#ac93dd46031b1e2f9fdb0cee7a99681df">llvm::ScalarEvolution::getOne</a></div><div class="ttdeci">const SCEV * getOne(Type *Ty)</div><div class="ttdoc">Return a SCEV for the constant 1 of a specific type. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l00591">ScalarEvolution.h:591</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_ac5b4263fea4de0564c41099b43bd72a7"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#ac5b4263fea4de0564c41099b43bd72a7">llvm::RuntimePointerChecking::needsChecking</a></div><div class="ttdeci">bool needsChecking(const CheckingPtrGroup &amp;M, const CheckingPtrGroup &amp;N) const</div><div class="ttdoc">Decide if we need to add a check between two groups of pointers, according to needsChecking. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00257">LoopAccessAnalysis.cpp:257</a></div></div>
<div class="ttc" id="classllvm_1_1AAResults_html"><div class="ttname"><a href="classllvm_1_1AAResults.html">llvm::AAResults</a></div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8h_source.html#l00311">AliasAnalysis.h:311</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html_aa17c104fbda554c818cf87e53f32f20a"><div class="ttname"><a href="classllvm_1_1APInt.html#aa17c104fbda554c818cf87e53f32f20a">llvm::APInt::isStrictlyPositive</a></div><div class="ttdeci">bool isStrictlyPositive() const</div><div class="ttdoc">Determine if this APInt Value is positive. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l00390">APInt.h:390</a></div></div>
<div class="ttc" id="classllvm_1_1AliasSetTracker_html"><div class="ttname"><a href="classllvm_1_1AliasSetTracker.html">llvm::AliasSetTracker</a></div><div class="ttdef"><b>Definition:</b> <a href="AliasSetTracker_8h_source.html#l00328">AliasSetTracker.h:328</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html_aac0ea55010b7b1a301e65a0baea057aa"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html#aac0ea55010b7b1a301e65a0baea057aa">llvm::SmallVectorImpl::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00339">SmallVector.h:339</a></div></div>
<div class="ttc" id="classllvm_1_1BasicBlock_html"><div class="ttname"><a href="classllvm_1_1BasicBlock.html">llvm::BasicBlock</a></div><div class="ttdoc">LLVM Basic Block Representation. </div><div class="ttdef"><b>Definition:</b> <a href="BasicBlock_8h_source.html#l00057">BasicBlock.h:57</a></div></div>
<div class="ttc" id="classllvm_1_1PointerIntPair_html"><div class="ttname"><a href="classllvm_1_1PointerIntPair.html">llvm::PointerIntPair&lt; Value *, 1, bool &gt;</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html"><div class="ttname"><a href="classllvm_1_1Type.html">llvm::Type</a></div><div class="ttdoc">The instances of the Type class are immutable: once they are created, they are never changed...</div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00046">Type.h:46</a></div></div>
<div class="ttc" id="classllvm_1_1LLVMContext_html"><div class="ttname"><a href="classllvm_1_1LLVMContext.html">llvm::LLVMContext</a></div><div class="ttdoc">This is an important class for using LLVM in a threaded context. </div><div class="ttdef"><b>Definition:</b> <a href="LLVMContext_8h_source.html#l00063">LLVMContext.h:63</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_ab815434ba412e9565ad40caa0413cc26"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#ab815434ba412e9565ad40caa0413cc26">MaxDependences</a></div><div class="ttdeci">static cl::opt&lt; unsigned &gt; MaxDependences(&quot;max-dependences&quot;, cl::Hidden, cl::desc(&quot;Maximum number of dependences collected by &quot; &quot;loop-access analysis (default = 100)&quot;), cl::init(100))</div><div class="ttdoc">We collect dependences up to this threshold. </div></div>
<div class="ttc" id="classllvm_1_1TrackingVH_html"><div class="ttname"><a href="classllvm_1_1TrackingVH.html">llvm::TrackingVH</a></div><div class="ttdoc">Value handle that tracks a Value across RAUW. </div><div class="ttdef"><b>Definition:</b> <a href="ValueHandle_8h_source.html#l00347">ValueHandle.h:347</a></div></div>
<div class="ttc" id="classllvm_1_1ArrayRef_html_a85ffb6531d4cda988ea81f18d4e56fb7"><div class="ttname"><a href="classllvm_1_1ArrayRef.html#a85ffb6531d4cda988ea81f18d4e56fb7">llvm::ArrayRef::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdoc">size - Get the array size. </div><div class="ttdef"><b>Definition:</b> <a href="ArrayRef_8h_source.html#l00158">ArrayRef.h:158</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessLegacyAnalysis_html"><div class="ttname"><a href="classllvm_1_1LoopAccessLegacyAnalysis.html">llvm::LoopAccessLegacyAnalysis</a></div><div class="ttdoc">This analysis provides dependence information for the memory accesses of a loop. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00723">LoopAccessAnalysis.h:723</a></div></div>
<div class="ttc" id="ScalarEvolutionExpressions_8h_html"><div class="ttname"><a href="ScalarEvolutionExpressions_8h.html">ScalarEvolutionExpressions.h</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessInfo_html_a8acfde41662b7ec9d592d905da1dbb22"><div class="ttname"><a href="classllvm_1_1LoopAccessInfo.html#a8acfde41662b7ec9d592d905da1dbb22">llvm::LoopAccessInfo::print</a></div><div class="ttdeci">void print(raw_ostream &amp;OS, unsigned Depth=0) const</div><div class="ttdoc">Print the information about the memory accesses in the loop. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02358">LoopAccessAnalysis.cpp:2358</a></div></div>
<div class="ttc" id="classllvm_1_1SmallSet_html"><div class="ttname"><a href="classllvm_1_1SmallSet.html">llvm::SmallSet&lt; unsigned, 2 &gt;</a></div></div>
<div class="ttc" id="Constants_8h_html"><div class="ttname"><a href="Constants_8h.html">Constants.h</a></div><div class="ttdoc">This file contains the declarations for the subclasses of Constant, which represent the different fla...</div></div>
<div class="ttc" id="classllvm_1_1Type_html_a3b996fbf8458aafffc86cb98a68d0a47"><div class="ttname"><a href="classllvm_1_1Type.html#a3b996fbf8458aafffc86cb98a68d0a47">llvm::Type::isPointerTy</a></div><div class="ttdeci">bool isPointerTy() const</div><div class="ttdoc">True if this is an instance of PointerType. </div><div class="ttdef"><b>Definition:</b> <a href="Type_8h_source.html#l00224">Type.h:224</a></div></div>
<div class="ttc" id="InitializePasses_8h_html"><div class="ttname"><a href="InitializePasses_8h.html">InitializePasses.h</a></div></div>
<div class="ttc" id="classllvm_1_1DataLayout_html_aa48b3b7e554b44f4e513d5dd8d9f9343"><div class="ttname"><a href="classllvm_1_1DataLayout.html#aa48b3b7e554b44f4e513d5dd8d9f9343">llvm::DataLayout::getTypeAllocSize</a></div><div class="ttdeci">TypeSize getTypeAllocSize(Type *Ty) const</div><div class="ttdoc">Returns the offset in bytes between successive objects of the specified type, including alignment pad...</div><div class="ttdef"><b>Definition:</b> <a href="DataLayout_8h_source.html#l00486">DataLayout.h:486</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a607583a4185a380ea70c4d32ab3c872f"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a607583a4185a380ea70c4d32ab3c872f">hasComputableBounds</a></div><div class="ttdeci">static bool hasComputableBounds(PredicatedScalarEvolution &amp;PSE, const ValueToValueMap &amp;Strides, Value *Ptr, Loop *L, bool Assume)</div><div class="ttdoc">Check whether a pointer can participate in a runtime bounds check. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00620">LoopAccessAnalysis.cpp:620</a></div></div>
<div class="ttc" id="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup_html_a79314926b75a22c414c8ce073e332dc0"><div class="ttname"><a href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a79314926b75a22c414c8ce073e332dc0">llvm::RuntimePointerChecking::CheckingPtrGroup::addPointer</a></div><div class="ttdeci">bool addPointer(unsigned Index)</div><div class="ttdoc">Tries to add the pointer recorded in RtCheck at index Index to this pointer checking group...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00280">LoopAccessAnalysis.cpp:280</a></div></div>
<div class="ttc" id="structllvm_1_1cl_1_1desc_html"><div class="ttname"><a href="structllvm_1_1cl_1_1desc.html">llvm::cl::desc</a></div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00406">CommandLine.h:406</a></div></div>
<div class="ttc" id="classllvm_1_1SmallPtrSetImpl_html_a6bc6fb89fe2e91c25559a8631f56e27e"><div class="ttname"><a href="classllvm_1_1SmallPtrSetImpl.html#a6bc6fb89fe2e91c25559a8631f56e27e">llvm::SmallPtrSetImpl::insert</a></div><div class="ttdeci">std::pair&lt; iterator, bool &gt; insert(PtrType Ptr)</div><div class="ttdoc">Inserts Ptr if and only if there is no element in the container equal to Ptr. </div><div class="ttdef"><b>Definition:</b> <a href="SmallPtrSet_8h_source.html#l00370">SmallPtrSet.h:370</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a83f34da3409085dd69e2da4a7f85e0f7"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a83f34da3409085dd69e2da4a7f85e0f7">llvm::ScalarEvolution::getAddExpr</a></div><div class="ttdeci">const SCEV * getAddExpr(SmallVectorImpl&lt; const SCEV *&gt; &amp;Ops, SCEV::NoWrapFlags Flags=SCEV::FlagAnyWrap, unsigned Depth=0)</div><div class="ttdoc">Get a canonical add expression, or something simpler if possible. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l02413">ScalarEvolution.cpp:2413</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVAddRecExpr_html_a33583576f220997d1c415df033559a57"><div class="ttname"><a href="classllvm_1_1SCEVAddRecExpr.html#a33583576f220997d1c415df033559a57">llvm::SCEVAddRecExpr::evaluateAtIteration</a></div><div class="ttdeci">const SCEV * evaluateAtIteration(const SCEV *It, ScalarEvolution &amp;SE) const</div><div class="ttdoc">Return the value of this chain of recurrences at the specified iteration number. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l01241">ScalarEvolution.cpp:1241</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8h_html"><div class="ttname"><a href="LoopAccessAnalysis_8h.html">LoopAccessAnalysis.h</a></div></div>
<div class="ttc" id="classllvm_1_1EquivalenceClasses_html"><div class="ttname"><a href="classllvm_1_1EquivalenceClasses.html">llvm::EquivalenceClasses</a></div><div class="ttdoc">EquivalenceClasses - This represents a collection of equivalence classes and supports three efficient...</div><div class="ttdef"><b>Definition:</b> <a href="EquivalenceClasses_8h_source.html#l00058">EquivalenceClasses.h:58</a></div></div>
<div class="ttc" id="classllvm_1_1EquivalenceClasses_html_a82ecd46540fecf164bcea31530a1bd02"><div class="ttname"><a href="classllvm_1_1EquivalenceClasses.html#a82ecd46540fecf164bcea31530a1bd02">llvm::EquivalenceClasses::member_end</a></div><div class="ttdeci">member_iterator member_end() const</div><div class="ttdef"><b>Definition:</b> <a href="EquivalenceClasses_8h_source.html#l00157">EquivalenceClasses.h:157</a></div></div>
<div class="ttc" id="classllvm_1_1AnalysisUsage_html"><div class="ttname"><a href="classllvm_1_1AnalysisUsage.html">llvm::AnalysisUsage</a></div><div class="ttdoc">Represent the analysis usage information of a pass. </div><div class="ttdef"><b>Definition:</b> <a href="PassAnalysisSupport_8h_source.html#l00042">PassAnalysisSupport.h:42</a></div></div>
<div class="ttc" id="classllvm_1_1MemoryDepChecker_html_ac661dd363bcde8b1e9516390eff1c400"><div class="ttname"><a href="classllvm_1_1MemoryDepChecker.html#ac661dd363bcde8b1e9516390eff1c400">llvm::MemoryDepChecker::VectorizationSafetyStatus</a></div><div class="ttdeci">VectorizationSafetyStatus</div><div class="ttdoc">Type to keep track of the status of the dependence check. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00102">LoopAccessAnalysis.h:102</a></div></div>
<div class="ttc" id="classllvm_1_1GlobalValue_html_a0557bd873ed2afae533faa02e3168d70"><div class="ttname"><a href="classllvm_1_1GlobalValue.html#a0557bd873ed2afae533faa02e3168d70">llvm::GlobalValue::getAddressSpace</a></div><div class="ttdeci">unsigned getAddressSpace() const</div><div class="ttdef"><b>Definition:</b> <a href="Globals_8cpp_source.html#l00111">Globals.cpp:111</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessLegacyAnalysis_html_ab43633352c881df20ceca554ca60dd9f"><div class="ttname"><a href="classllvm_1_1LoopAccessLegacyAnalysis.html#ab43633352c881df20ceca554ca60dd9f">llvm::LoopAccessLegacyAnalysis::ID</a></div><div class="ttdeci">static char ID</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00725">LoopAccessAnalysis.h:725</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVExpander_html_a583d3ca95f83216d632a4d1ae0330dd0"><div class="ttname"><a href="classllvm_1_1SCEVExpander.html#a583d3ca95f83216d632a4d1ae0330dd0">llvm::SCEVExpander::expandCodeFor</a></div><div class="ttdeci">Value * expandCodeFor(const SCEV *SH, Type *Ty, Instruction *I)</div><div class="ttdoc">Insert code to directly compute the specified SCEV expression into the program. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpander_8cpp_source.html#l01761">ScalarEvolutionExpander.cpp:1761</a></div></div>
<div class="ttc" id="classllvm_1_1FunctionPass_html"><div class="ttname"><a href="classllvm_1_1FunctionPass.html">llvm::FunctionPass</a></div><div class="ttdoc">FunctionPass class - This class is used to implement most global optimizations. </div><div class="ttdef"><b>Definition:</b> <a href="Pass_8h_source.html#l00282">Pass.h:282</a></div></div>
<div class="ttc" id="structllvm_1_1RuntimePointerChecking_1_1PointerInfo_html"><div class="ttname"><a href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html">llvm::RuntimePointerChecking::PointerInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00336">LoopAccessAnalysis.h:336</a></div></div>
<div class="ttc" id="namespacellvm_html_aa92a7ada2797ca16a2c0c540faafd7e1"><div class="ttname"><a href="namespacellvm.html#aa92a7ada2797ca16a2c0c540faafd7e1">llvm::replaceSymbolicStrideSCEV</a></div><div class="ttdeci">const SCEV * replaceSymbolicStrideSCEV(PredicatedScalarEvolution &amp;PSE, const ValueToValueMap &amp;PtrToStride, Value *Ptr, Value *OrigPtr=nullptr)</div><div class="ttdoc">Return the SCEV corresponding to a pointer with the symbolic stride replaced with constant one...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00145">LoopAccessAnalysis.cpp:145</a></div></div>
<div class="ttc" id="VectorUtils_8h_html"><div class="ttname"><a href="VectorUtils_8h.html">VectorUtils.h</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVAddRecExpr_html_a54bb7394d874cbbef1d81e6bea89d4f3"><div class="ttname"><a href="classllvm_1_1SCEVAddRecExpr.html#a54bb7394d874cbbef1d81e6bea89d4f3">llvm::SCEVAddRecExpr::isAffine</a></div><div class="ttdeci">bool isAffine() const</div><div class="ttdoc">Return true if this represents an expression A + B*x where A and B are loop invariant values...</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00322">ScalarEvolutionExpressions.h:322</a></div></div>
<div class="ttc" id="classllvm_1_1SmallPtrSetImpl_html_a1f475b0df44ebd7169e720fa1bf9169e"><div class="ttname"><a href="classllvm_1_1SmallPtrSetImpl.html#a1f475b0df44ebd7169e720fa1bf9169e">llvm::SmallPtrSetImpl::count</a></div><div class="ttdeci">size_type count(ConstPtrType Ptr) const</div><div class="ttdoc">count - Return 1 if the specified pointer is in the set, 0 otherwise. </div><div class="ttdef"><b>Definition:</b> <a href="SmallPtrSet_8h_source.html#l00381">SmallPtrSet.h:381</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVAddRecExpr_html_a1d3a0e869e478018c481a577ed9d25ee"><div class="ttname"><a href="classllvm_1_1SCEVAddRecExpr.html#a1d3a0e869e478018c481a577ed9d25ee">llvm::SCEVAddRecExpr::getStart</a></div><div class="ttdeci">const SCEV * getStart() const</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00306">ScalarEvolutionExpressions.h:306</a></div></div>
<div class="ttc" id="classllvm_1_1SmallSet_html_a892daa20eb21173ba89e9fe9702e7f6c"><div class="ttname"><a href="classllvm_1_1SmallSet.html#a892daa20eb21173ba89e9fe9702e7f6c">llvm::SmallSet::insert</a></div><div class="ttdeci">std::pair&lt; NoneType, bool &gt; insert(const T &amp;V)</div><div class="ttdoc">insert - Insert an element into the set if it isn&amp;#39;t already there. </div><div class="ttdef"><b>Definition:</b> <a href="SmallSet_8h_source.html#l00180">SmallSet.h:180</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a8bcb86d8d126d95b0dc05f09e8f3df96"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a8bcb86d8d126d95b0dc05f09e8f3df96">llvm::ScalarEvolution::getMinusSCEV</a></div><div class="ttdeci">const SCEV * getMinusSCEV(const SCEV *LHS, const SCEV *RHS, SCEV::NoWrapFlags Flags=SCEV::FlagAnyWrap, unsigned Depth=0)</div><div class="ttdoc">Return LHS-RHS. Minus is represented in SCEV as A+B*-1. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l04011">ScalarEvolution.cpp:4011</a></div></div>
<div class="ttc" id="DenseMap_8h_html"><div class="ttname"><a href="DenseMap_8h.html">DenseMap.h</a></div></div>
<div class="ttc" id="structStatus_html"><div class="ttname"><a href="structStatus.html">Status</a></div><div class="ttdef"><b>Definition:</b> <a href="SIModeRegister_8cpp_source.html#l00039">SIModeRegister.cpp:39</a></div></div>
<div class="ttc" id="classllvm_1_1MemoryDepChecker_html_a67819b448429b42f3558c9b2e4ae4b45"><div class="ttname"><a href="classllvm_1_1MemoryDepChecker.html#a67819b448429b42f3558c9b2e4ae4b45">llvm::MemoryDepChecker::clearDependences</a></div><div class="ttdeci">void clearDependences()</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00234">LoopAccessAnalysis.h:234</a></div></div>
<div class="ttc" id="classllvm_1_1Loop_html_a615131659002c10601eef598d42d025e"><div class="ttname"><a href="classllvm_1_1Loop.html#a615131659002c10601eef598d42d025e">llvm::Loop::getStartLoc</a></div><div class="ttdeci">DebugLoc getStartLoc() const</div><div class="ttdoc">Return the debug location of the start of this loop. </div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8cpp_source.html#l00612">LoopInfo.cpp:612</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_a4f9b2d55586e573727e97cd51a3e0a9a"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#a4f9b2d55586e573727e97cd51a3e0a9a">llvm::RuntimePointerChecking::PointerCheck</a></div><div class="ttdeci">std::pair&lt; const CheckingPtrGroup *, const CheckingPtrGroup * &gt; PointerCheck</div><div class="ttdoc">A memcheck which made up of a pair of grouped pointers. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00423">LoopAccessAnalysis.h:423</a></div></div>
<div class="ttc" id="classllvm_1_1PredicatedScalarEvolution_html_a872704344573663359494dca7554c198"><div class="ttname"><a href="classllvm_1_1PredicatedScalarEvolution.html#a872704344573663359494dca7554c198">llvm::PredicatedScalarEvolution::getSE</a></div><div class="ttdeci">ScalarEvolution * getSE() const</div><div class="ttdoc">Returns the ScalarEvolution analysis used. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l02006">ScalarEvolution.h:2006</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorBase_html_ac8624043115fb3a5076c964820001b61"><div class="ttname"><a href="classllvm_1_1SmallVectorBase.html#ac8624043115fb3a5076c964820001b61">llvm::SmallVectorBase::size</a></div><div class="ttdeci">size_t size() const</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00052">SmallVector.h:52</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a7fe9ccd4893f4e2caa826126c09545ea"><div class="ttname"><a href="classllvm_1_1Type.html#a7fe9ccd4893f4e2caa826126c09545ea">llvm::Type::getInt8PtrTy</a></div><div class="ttdeci">static PointerType * getInt8PtrTy(LLVMContext &amp;C, unsigned AS=0)</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00224">Type.cpp:224</a></div></div>
<div class="ttc" id="namespacellvm_html_a62fbc6c535baa6d7d82bbf63f6c2621f"><div class="ttname"><a href="namespacellvm.html#a62fbc6c535baa6d7d82bbf63f6c2621f">llvm::stripIntegerCast</a></div><div class="ttdeci">Value * stripIntegerCast(Value *V)</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00138">LoopAccessAnalysis.cpp:138</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a805c8bc133a45fce61c32ee6c0ce01b9"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a805c8bc133a45fce61c32ee6c0ce01b9">llvm::ScalarEvolution::getMulExpr</a></div><div class="ttdeci">const SCEV * getMulExpr(SmallVectorImpl&lt; const SCEV *&gt; &amp;Ops, SCEV::NoWrapFlags Flags=SCEV::FlagAnyWrap, unsigned Depth=0)</div><div class="ttdoc">Get a canonical multiply expression, or something simpler if possible. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l02914">ScalarEvolution.cpp:2914</a></div></div>
<div class="ttc" id="namespacellvm_html_a5a8d41e9958a4ff2156f1f03f26a2eb3"><div class="ttname"><a href="namespacellvm.html#a5a8d41e9958a4ff2156f1f03f26a2eb3">llvm::GetUnderlyingObject</a></div><div class="ttdeci">Value * GetUnderlyingObject(Value *V, const DataLayout &amp;DL, unsigned MaxLookup=6)</div><div class="ttdoc">This method strips off any GEP address adjustments and pointer casts from the specified value...</div><div class="ttdef"><b>Definition:</b> <a href="ValueTracking_8cpp_source.html#l03877">ValueTracking.cpp:3877</a></div></div>
<div class="ttc" id="RegBankSelect_8cpp_html_a0eee13989797c0d4612066f84ff7a7b8"><div class="ttname"><a href="RegBankSelect_8cpp.html#a0eee13989797c0d4612066f84ff7a7b8">INITIALIZE_PASS_END</a></div><div class="ttdeci">INITIALIZE_PASS_END(RegBankSelect, DEBUG_TYPE, &quot;Assign register bank of generic virtual registers&quot;, false, false) RegBankSelect</div><div class="ttdef"><b>Definition:</b> <a href="RegBankSelect_8cpp_source.html#l00069">RegBankSelect.cpp:69</a></div></div>
<div class="ttc" id="Support_2ErrorHandling_8h_html_ace243f5c25697a1107cce46626b3dc94"><div class="ttname"><a href="Support_2ErrorHandling_8h.html#ace243f5c25697a1107cce46626b3dc94">llvm_unreachable</a></div><div class="ttdeci">#define llvm_unreachable(msg)</div><div class="ttdoc">Marks that the current location is not supposed to be reachable. </div><div class="ttdef"><b>Definition:</b> <a href="Support_2ErrorHandling_8h_source.html#l00135">ErrorHandling.h:135</a></div></div>
<div class="ttc" id="structllvm_1_1RuntimePointerChecking_1_1PointerInfo_html_aa4ba7560118a4dcd0907b66f9a58384d"><div class="ttname"><a href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html#aa4ba7560118a4dcd0907b66f9a58384d">llvm::RuntimePointerChecking::PointerInfo::AliasSetId</a></div><div class="ttdeci">unsigned AliasSetId</div><div class="ttdoc">Holds the id of the disjoint alias set to which this pointer belongs. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00351">LoopAccessAnalysis.h:351</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html_a2a8c8be274f3bd351e083ab3828c14c7"><div class="ttname"><a href="classllvm_1_1ConstantInt.html#a2a8c8be274f3bd351e083ab3828c14c7">llvm::ConstantInt::isNegative</a></div><div class="ttdeci">bool isNegative() const</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8h_source.html#l00187">Constants.h:187</a></div></div>
<div class="ttc" id="structllvm_1_1MemoryDepChecker_1_1Dependence_html_ae336b0e8514b99a44e73c3e2494c3cea"><div class="ttname"><a href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#ae336b0e8514b99a44e73c3e2494c3cea">llvm::MemoryDepChecker::Dependence::DepType</a></div><div class="ttdeci">DepType</div><div class="ttdoc">The type of the dependence. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00115">LoopAccessAnalysis.h:115</a></div></div>
<div class="ttc" id="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup_html_a90bc32387fd6351a131d06f1e0ed4a37"><div class="ttname"><a href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a90bc32387fd6351a131d06f1e0ed4a37">llvm::RuntimePointerChecking::CheckingPtrGroup::Members</a></div><div class="ttdeci">SmallVector&lt; unsigned, 2 &gt; Members</div><div class="ttdoc">Indices of all the pointers that constitute this grouping. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00413">LoopAccessAnalysis.h:413</a></div></div>
<div class="ttc" id="classllvm_1_1MemoryLocation_html_a9550ce4a179e46db37f653ce28feca7a"><div class="ttname"><a href="classllvm_1_1MemoryLocation.html#a9550ce4a179e46db37f653ce28feca7a">llvm::MemoryLocation::Ptr</a></div><div class="ttdeci">const Value * Ptr</div><div class="ttdoc">The address of the start of the location. </div><div class="ttdef"><b>Definition:</b> <a href="MemoryLocation_8h_source.html#l00182">MemoryLocation.h:182</a></div></div>
<div class="ttc" id="classllvm_1_1MemoryLocation_html"><div class="ttname"><a href="classllvm_1_1MemoryLocation.html">llvm::MemoryLocation</a></div><div class="ttdoc">Representation for a specific memory location. </div><div class="ttdef"><b>Definition:</b> <a href="MemoryLocation_8h_source.html#l00174">MemoryLocation.h:174</a></div></div>
<div class="ttc" id="classllvm_1_1MemoryDepChecker_html_acf3e8a08219f76d58762836fe99d4bec"><div class="ttname"><a href="classllvm_1_1MemoryDepChecker.html#acf3e8a08219f76d58762836fe99d4bec">llvm::MemoryDepChecker::areDepsSafe</a></div><div class="ttdeci">bool areDepsSafe(DepCandidates &amp;AccessSets, MemAccessInfoList &amp;CheckDeps, const ValueToValueMap &amp;Strides)</div><div class="ttdoc">Check whether the dependencies between the accesses are safe. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01635">LoopAccessAnalysis.cpp:1635</a></div></div>
<div class="ttc" id="namespacellvm_html_ad1a91b49e0c092818a0b82f6cc130a1b"><div class="ttname"><a href="namespacellvm.html#ad1a91b49e0c092818a0b82f6cc130a1b">llvm::make_range</a></div><div class="ttdeci">iterator_range&lt; T &gt; make_range(T x, T y)</div><div class="ttdoc">Convenience function for iterating over sub-ranges. </div><div class="ttdef"><b>Definition:</b> <a href="iterator__range_8h_source.html#l00054">iterator_range.h:54</a></div></div>
<div class="ttc" id="X86InstrFMA3Info_8cpp_html_ab138684de9096eb96683328900f78e48"><div class="ttname"><a href="X86InstrFMA3Info_8cpp.html#ab138684de9096eb96683328900f78e48">Groups</a></div><div class="ttdeci">static const X86InstrFMA3Group Groups[]</div><div class="ttdef"><b>Definition:</b> <a href="X86InstrFMA3Info_8cpp_source.html#l00065">X86InstrFMA3Info.cpp:65</a></div></div>
<div class="ttc" id="classllvm_1_1LoopBase_html_a04337b572d34ea413c35dbac5d75530b"><div class="ttname"><a href="classllvm_1_1LoopBase.html#a04337b572d34ea413c35dbac5d75530b">llvm::LoopBase::contains</a></div><div class="ttdeci">bool contains(const LoopT *L) const</div><div class="ttdoc">Return true if the specified loop is contained within in this loop. </div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l00115">LoopInfo.h:115</a></div></div>
<div class="ttc" id="classllvm_1_1PredicatedScalarEvolution_html_a6fb96c9b4d017d69818db581dae5bd96"><div class="ttname"><a href="classllvm_1_1PredicatedScalarEvolution.html#a6fb96c9b4d017d69818db581dae5bd96">llvm::PredicatedScalarEvolution::hasNoOverflow</a></div><div class="ttdeci">bool hasNoOverflow(Value *V, SCEVWrapPredicate::IncrementWrapFlags Flags)</div><div class="ttdoc">Returns true if we&amp;#39;ve proved that V doesn&amp;#39;t wrap by means of a SCEV predicate. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l12516">ScalarEvolution.cpp:12516</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a9d9847ba3ad2bc2837b041581277a8fb"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a9d9847ba3ad2bc2837b041581277a8fb">isNoWrapAddRec</a></div><div class="ttdeci">static bool isNoWrapAddRec(Value *Ptr, const SCEVAddRecExpr *AR, PredicatedScalarEvolution &amp;PSE, const Loop *L)</div><div class="ttdoc">Return true if an AddRec pointer Ptr is unsigned non-wrapping, i.e. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00944">LoopAccessAnalysis.cpp:944</a></div></div>
<div class="ttc" id="classllvm_1_1SmallPtrSet_html"><div class="ttname"><a href="classllvm_1_1SmallPtrSet.html">llvm::SmallPtrSet&lt; Value *, 16 &gt;</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a5a672708a81ae8da8fb56e32638ca9b3"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a5a672708a81ae8da8fb56e32638ca9b3">llvm::ScalarEvolution::isKnownPositive</a></div><div class="ttdeci">bool isKnownPositive(const SCEV *S)</div><div class="ttdoc">Test if the given expression is known to be positive. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l09157">ScalarEvolution.cpp:9157</a></div></div>
<div class="ttc" id="classllvm_1_1SCEV_html_aefeda9454a5e8dfcec3deb106964832a"><div class="ttname"><a href="classllvm_1_1SCEV.html#aefeda9454a5e8dfcec3deb106964832a">llvm::SCEV::getType</a></div><div class="ttdeci">Type * getType() const</div><div class="ttdoc">Return the LLVM type of this SCEV expression. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l00363">ScalarEvolution.cpp:363</a></div></div>
<div class="ttc" id="namespacellvm_html_a81b52e18d84e3cc61df7e897bba1b259"><div class="ttname"><a href="namespacellvm.html#a81b52e18d84e3cc61df7e897bba1b259">llvm::max</a></div><div class="ttdeci">Align max(MaybeAlign Lhs, Align Rhs)</div><div class="ttdef"><b>Definition:</b> <a href="Alignment_8h_source.html#l00390">Alignment.h:390</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessInfo_html_a24eb2d9c42c36950317f2666255d7535"><div class="ttname"><a href="classllvm_1_1LoopAccessInfo.html#a24eb2d9c42c36950317f2666255d7535">llvm::LoopAccessInfo::isUniform</a></div><div class="ttdeci">bool isUniform(Value *V) const</div><div class="ttdoc">Returns true if the value V is uniform within the loop. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02108">LoopAccessAnalysis.cpp:2108</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessLegacyAnalysis_html_ae38799ea6afbe2f009f89d9f8958d198"><div class="ttname"><a href="classllvm_1_1LoopAccessLegacyAnalysis.html#ae38799ea6afbe2f009f89d9f8958d198">llvm::LoopAccessLegacyAnalysis::runOnFunction</a></div><div class="ttdeci">bool runOnFunction(Function &amp;F) override</div><div class="ttdoc">runOnFunction - Virtual method overriden by subclasses to do the per-function processing of the pass...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02425">LoopAccessAnalysis.cpp:2425</a></div></div>
<div class="ttc" id="classllvm_1_1Type_html_a9f382207d841377156d4c7868b66b9a5"><div class="ttname"><a href="classllvm_1_1Type.html#a9f382207d841377156d4c7868b66b9a5">llvm::Type::getScalarSizeInBits</a></div><div class="ttdeci">unsigned getScalarSizeInBits() const LLVM_READONLY</div><div class="ttdoc">If this is a vector type, return the getPrimitiveSizeInBits value for the element type...</div><div class="ttdef"><b>Definition:</b> <a href="Type_8cpp_source.html#l00134">Type.cpp:134</a></div></div>
<div class="ttc" id="OptimizationRemarkEmitter_8h_html"><div class="ttname"><a href="OptimizationRemarkEmitter_8h.html">OptimizationRemarkEmitter.h</a></div></div>
<div class="ttc" id="classllvm_1_1TargetLibraryInfo_html_a2fcef86fd476c438d77d7d7229d456e6"><div class="ttname"><a href="classllvm_1_1TargetLibraryInfo.html#a2fcef86fd476c438d77d7d7229d456e6">llvm::TargetLibraryInfo::isFunctionVectorizable</a></div><div class="ttdeci">bool isFunctionVectorizable(StringRef F, unsigned VF) const</div><div class="ttdef"><b>Definition:</b> <a href="TargetLibraryInfo_8h_source.html#l00304">TargetLibraryInfo.h:304</a></div></div>
<div class="ttc" id="classllvm_1_1EquivalenceClasses_1_1member__iterator_html"><div class="ttname"><a href="classllvm_1_1EquivalenceClasses_1_1member__iterator.html">llvm::EquivalenceClasses::member_iterator</a></div><div class="ttdef"><b>Definition:</b> <a href="EquivalenceClasses_8h_source.html#l00251">EquivalenceClasses.h:251</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVector_html"><div class="ttname"><a href="classllvm_1_1SmallVector.html">llvm::SmallVector&lt; RuntimePointerChecking::PointerCheck, 4 &gt;</a></div></div>
<div class="ttc" id="classllvm_1_1DominatorTree_html_ac3abe77784353227ce14dc7c5815c141"><div class="ttname"><a href="classllvm_1_1DominatorTree.html#ac3abe77784353227ce14dc7c5815c141">llvm::DominatorTree::dominates</a></div><div class="ttdeci">bool dominates(const Instruction *Def, const Use &amp;U) const</div><div class="ttdoc">Return true if Def dominates a use in User. </div><div class="ttdef"><b>Definition:</b> <a href="Dominators_8cpp_source.html#l00249">Dominators.cpp:249</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_ac2ba67bd461a728fbe186ef76f089a3a"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#ac2ba67bd461a728fbe186ef76f089a3a">getMinFromExprs</a></div><div class="ttdeci">static const SCEV * getMinFromExprs(const SCEV *I, const SCEV *J, ScalarEvolution *SE)</div><div class="ttdoc">Compare I and J and return the minimum. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00268">LoopAccessAnalysis.cpp:268</a></div></div>
<div class="ttc" id="classllvm_1_1TargetLibraryInfo_html"><div class="ttname"><a href="classllvm_1_1TargetLibraryInfo.html">llvm::TargetLibraryInfo</a></div><div class="ttdoc">Provides information about what library functions are available for the current target. </div><div class="ttdef"><b>Definition:</b> <a href="TargetLibraryInfo_8h_source.html#l00212">TargetLibraryInfo.h:212</a></div></div>
<div class="ttc" id="structllvm_1_1MemoryDepChecker_1_1Dependence_html_a490650c52b42bc9cac525437b364df29"><div class="ttname"><a href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#a490650c52b42bc9cac525437b364df29">llvm::MemoryDepChecker::Dependence::print</a></div><div class="ttdeci">void print(raw_ostream &amp;OS, unsigned Depth, const SmallVectorImpl&lt; Instruction *&gt; &amp;Instrs) const</div><div class="ttdoc">Print the dependence. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01728">LoopAccessAnalysis.cpp:1728</a></div></div>
<div class="ttc" id="classllvm_1_1LoopInfo_html"><div class="ttname"><a href="classllvm_1_1LoopInfo.html">llvm::LoopInfo</a></div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l01049">LoopInfo.h:1049</a></div></div>
<div class="ttc" id="classllvm_1_1PredicatedScalarEvolution_html"><div class="ttname"><a href="classllvm_1_1PredicatedScalarEvolution.html">llvm::PredicatedScalarEvolution</a></div><div class="ttdoc">An interface layer with SCEV used to manage how we see SCEV expressions for values in the context of ...</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l01974">ScalarEvolution.h:1974</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a38c440751f1bf5f19bc12b95f8f0f2a6"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a38c440751f1bf5f19bc12b95f8f0f2a6">llvm::ScalarEvolution::getNoopOrSignExtend</a></div><div class="ttdeci">const SCEV * getNoopOrSignExtend(const SCEV *V, Type *Ty)</div><div class="ttdoc">Return a SCEV corresponding to a conversion of the input value to the specified type. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l04087">ScalarEvolution.cpp:4087</a></div></div>
<div class="ttc" id="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup_html_a4e3c156ce6fa692f3528dfa3e660ecb2"><div class="ttname"><a href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a4e3c156ce6fa692f3528dfa3e660ecb2">llvm::RuntimePointerChecking::CheckingPtrGroup::Low</a></div><div class="ttdeci">const SCEV * Low</div><div class="ttdoc">The SCEV expression which represents the lower bound of all the pointers in this group. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00411">LoopAccessAnalysis.h:411</a></div></div>
<div class="ttc" id="PassSupport_8h_html_aaa970fc931c1c63037a8182e028d04b1"><div class="ttname"><a href="PassSupport_8h.html#aaa970fc931c1c63037a8182e028d04b1">INITIALIZE_PASS_BEGIN</a></div><div class="ttdeci">#define INITIALIZE_PASS_BEGIN(passName, arg, name, cfg, analysis)</div><div class="ttdef"><b>Definition:</b> <a href="PassSupport_8h_source.html#l00047">PassSupport.h:47</a></div></div>
<div class="ttc" id="Support_2ErrorHandling_8h_html"><div class="ttname"><a href="Support_2ErrorHandling_8h.html">ErrorHandling.h</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessInfo_html"><div class="ttname"><a href="classllvm_1_1LoopAccessInfo.html">llvm::LoopAccessInfo</a></div><div class="ttdoc">Drive the analysis of memory accesses in the loop. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00516">LoopAccessAnalysis.h:516</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a238566881f41b81cd8ff51eb1b3f4a8b"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a238566881f41b81cd8ff51eb1b3f4a8b">llvm::ScalarEvolution::getUMaxExpr</a></div><div class="ttdeci">const SCEV * getUMaxExpr(const SCEV *LHS, const SCEV *RHS)</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l03697">ScalarEvolution.cpp:3697</a></div></div>
<div class="ttc" id="classllvm_1_1ConstantInt_html_a82dbbd8e3688b0bc1eedb338864d0d0c"><div class="ttname"><a href="classllvm_1_1ConstantInt.html#a82dbbd8e3688b0bc1eedb338864d0d0c">llvm::ConstantInt::getTrue</a></div><div class="ttdeci">static ConstantInt * getTrue(LLVMContext &amp;Context)</div><div class="ttdef"><b>Definition:</b> <a href="Constants_8cpp_source.html#l00660">Constants.cpp:660</a></div></div>
<div class="ttc" id="namespacellvm_html_a7b03ed78a8e299bde6d26a8793cd4e06"><div class="ttname"><a href="namespacellvm.html#a7b03ed78a8e299bde6d26a8793cd4e06">llvm::NullPointerIsDefined</a></div><div class="ttdeci">bool NullPointerIsDefined(const Function *F, unsigned AS=0)</div><div class="ttdoc">Check whether null pointer dereferencing is considered undefined behavior for a given function or an ...</div><div class="ttdef"><b>Definition:</b> <a href="Function_8cpp_source.html#l01628">Function.cpp:1628</a></div></div>
<div class="ttc" id="namespacellvm_html_a7c46c742c31be54870e2038048e6b391"><div class="ttname"><a href="namespacellvm.html#a7c46c742c31be54870e2038048e6b391">llvm::dbgs</a></div><div class="ttdeci">raw_ostream &amp; dbgs()</div><div class="ttdoc">dbgs() - This returns a reference to a raw_ostream for debugging messages. </div><div class="ttdef"><b>Definition:</b> <a href="Debug_8cpp_source.html#l00132">Debug.cpp:132</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessLegacyAnalysis_html_ad340ccd20710b9c804283f3b1572c4fc"><div class="ttname"><a href="classllvm_1_1LoopAccessLegacyAnalysis.html#ad340ccd20710b9c804283f3b1572c4fc">llvm::LoopAccessLegacyAnalysis::getInfo</a></div><div class="ttdeci">const LoopAccessInfo &amp; getInfo(Loop *L)</div><div class="ttdoc">Query the result of the loop access information for the loop L. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02405">LoopAccessAnalysis.cpp:2405</a></div></div>
<div class="ttc" id="namespacestd_html_ab8424022895aee3e366fb9a32f2883cb"><div class="ttname"><a href="namespacestd.html#ab8424022895aee3e366fb9a32f2883cb">std::swap</a></div><div class="ttdeci">void swap(llvm::BitVector &amp;LHS, llvm::BitVector &amp;RHS)</div><div class="ttdoc">Implement std::swap in terms of BitVector swap. </div><div class="ttdef"><b>Definition:</b> <a href="BitVector_8h_source.html#l00940">BitVector.h:940</a></div></div>
<div class="ttc" id="classllvm_1_1APInt_html"><div class="ttname"><a href="classllvm_1_1APInt.html">llvm::APInt</a></div><div class="ttdoc">Class for arbitrary precision integers. </div><div class="ttdef"><b>Definition:</b> <a href="APInt_8h_source.html#l00069">APInt.h:69</a></div></div>
<div class="ttc" id="ScalarEvolution_8h_html"><div class="ttname"><a href="ScalarEvolution_8h.html">ScalarEvolution.h</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_a799b2020cc896db04085849aed060f20"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#a799b2020cc896db04085849aed060f20">llvm::RuntimePointerChecking::generateChecks</a></div><div class="ttdeci">void generateChecks(MemoryDepChecker::DepCandidates &amp;DepCands, bool UseDependencies)</div><div class="ttdoc">Generate the checks and store it. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00250">LoopAccessAnalysis.cpp:250</a></div></div>
<div class="ttc" id="namespacellvm_1_1cl_html_ac96f30ba8b117dbd380b88ab8a03732ba1e82b710efc2f25cc275e53b3833e6fa"><div class="ttname"><a href="namespacellvm_1_1cl.html#ac96f30ba8b117dbd380b88ab8a03732ba1e82b710efc2f25cc275e53b3833e6fa">llvm::cl::Sink</a></div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00176">CommandLine.h:176</a></div></div>
<div class="ttc" id="classllvm_1_1AnalysisUsage_html_af22b06a6a4f9df80454071685a0d6a02"><div class="ttname"><a href="classllvm_1_1AnalysisUsage.html#af22b06a6a4f9df80454071685a0d6a02">llvm::AnalysisUsage::setPreservesAll</a></div><div class="ttdeci">void setPreservesAll()</div><div class="ttdoc">Set by analyses that do not transform their input at all. </div><div class="ttdef"><b>Definition:</b> <a href="PassAnalysisSupport_8h_source.html#l00120">PassAnalysisSupport.h:120</a></div></div>
<div class="ttc" id="Pass_8h_html"><div class="ttname"><a href="Pass_8h.html">Pass.h</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVExpander_html"><div class="ttname"><a href="classllvm_1_1SCEVExpander.html">llvm::SCEVExpander</a></div><div class="ttdoc">This class uses information about analyze scalars to rewrite expressions in canonical form...</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpander_8h_source.html#l00045">ScalarEvolutionExpander.h:45</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html">llvm::RuntimePointerChecking</a></div><div class="ttdoc">Holds information about the memory runtime legality checks to verify that a group of pointers do not ...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00334">LoopAccessAnalysis.h:334</a></div></div>
<div class="ttc" id="Function_8h_html"><div class="ttname"><a href="Function_8h.html">Function.h</a></div></div>
<div class="ttc" id="namespacellvm_html_a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e"><div class="ttname"><a href="namespacellvm.html#a5d56157a385f8cd7d3e54ed87da1ba6aa88183b946cc5f0e8c96b2e66e1c74a7e">llvm::EHPersonality::Unknown</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorTemplateCommon_html_a8a045d250952c0867382a9840ee18fdf"><div class="ttname"><a href="classllvm_1_1SmallVectorTemplateCommon.html#a8a045d250952c0867382a9840ee18fdf">llvm::SmallVectorTemplateCommon::begin</a></div><div class="ttdeci">iterator begin()</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00127">SmallVector.h:127</a></div></div>
<div class="ttc" id="ValueHandle_8h_html"><div class="ttname"><a href="ValueHandle_8h.html">ValueHandle.h</a></div></div>
<div class="ttc" id="AliasAnalysis_8h_html"><div class="ttname"><a href="AliasAnalysis_8h.html">AliasAnalysis.h</a></div></div>
<div class="ttc" id="classllvm_1_1PredicatedScalarEvolution_html_ada1db826f3d2266fe2c4d06218d8d342"><div class="ttname"><a href="classllvm_1_1PredicatedScalarEvolution.html#ada1db826f3d2266fe2c4d06218d8d342">llvm::PredicatedScalarEvolution::getBackedgeTakenCount</a></div><div class="ttdeci">const SCEV * getBackedgeTakenCount()</div><div class="ttdoc">Get the (predicated) backedge count for the analyzed loop. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l12470">ScalarEvolution.cpp:12470</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessAnalysis_html"><div class="ttname"><a href="classllvm_1_1LoopAccessAnalysis.html">llvm::LoopAccessAnalysis</a></div><div class="ttdoc">This analysis provides dependence information for the memory accesses of a loop. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00765">LoopAccessAnalysis.h:765</a></div></div>
<div class="ttc" id="classllvm_1_1MemoryLocation_html_a926099ca5ca5db6ba2de398c2487b725"><div class="ttname"><a href="classllvm_1_1MemoryLocation.html#a926099ca5ca5db6ba2de398c2487b725">llvm::MemoryLocation::AATags</a></div><div class="ttdeci">AAMDNodes AATags</div><div class="ttdoc">The metadata nodes which describes the aliasing of the location (each member is null if that kind of ...</div><div class="ttdef"><b>Definition:</b> <a href="MemoryLocation_8h_source.html#l00195">MemoryLocation.h:195</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a5bf595721f9dd83efbc1fe6c6ae3c67d"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a5bf595721f9dd83efbc1fe6c6ae3c67d">expandBounds</a></div><div class="ttdeci">static PointerBounds expandBounds(const RuntimePointerChecking::CheckingPtrGroup *CG, Loop *TheLoop, Instruction *Loc, SCEVExpander &amp;Exp, ScalarEvolution *SE, const RuntimePointerChecking &amp;PtrRtChecking)</div><div class="ttdoc">Expand code for the lower and upper bound of the pointer group CG in TheLoop. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02146">LoopAccessAnalysis.cpp:2146</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_ab4f3bf98b5054831b608852e33427814"><div class="ttname"><a href="classllvm_1_1Instruction.html#ab4f3bf98b5054831b608852e33427814">llvm::Instruction::getDebugLoc</a></div><div class="ttdeci">const DebugLoc &amp; getDebugLoc() const</div><div class="ttdoc">Return the debug location for this node as a DebugLoc. </div><div class="ttdef"><b>Definition:</b> <a href="IR_2Instruction_8h_source.html#l00331">Instruction.h:331</a></div></div>
<div class="ttc" id="classllvm_1_1cl_1_1opt_html"><div class="ttname"><a href="classllvm_1_1cl_1_1opt.html">llvm::cl::opt</a></div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l01415">CommandLine.h:1415</a></div></div>
<div class="ttc" id="structllvm_1_1MemoryDepChecker_1_1Dependence_html"><div class="ttname"><a href="structllvm_1_1MemoryDepChecker_1_1Dependence.html">llvm::MemoryDepChecker::Dependence</a></div><div class="ttdoc">Dependece between memory access instructions. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00113">LoopAccessAnalysis.h:113</a></div></div>
<div class="ttc" id="classllvm_1_1SCEV_html"><div class="ttname"><a href="classllvm_1_1SCEV.html">llvm::SCEV</a></div><div class="ttdoc">This class represents an analyzed expression in the program. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8h_source.html#l00076">ScalarEvolution.h:76</a></div></div>
<div class="ttc" id="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup_html_a205c1f26515d92ec84b40be256bcba08"><div class="ttname"><a href="structllvm_1_1RuntimePointerChecking_1_1CheckingPtrGroup.html#a205c1f26515d92ec84b40be256bcba08">llvm::RuntimePointerChecking::CheckingPtrGroup::High</a></div><div class="ttdeci">const SCEV * High</div><div class="ttdoc">The SCEV expression which represents the upper bound of all the pointers in this group. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00408">LoopAccessAnalysis.h:408</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a7b58e159e9c7683ba37043d4288d643a"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a7b58e159e9c7683ba37043d4288d643a">EnableMemAccessVersioning</a></div><div class="ttdeci">static cl::opt&lt; bool &gt; EnableMemAccessVersioning(&quot;enable-mem-access-versioning&quot;, cl::init(true), cl::Hidden, cl::desc(&quot;Enable symbolic stride memory access versioning&quot;))</div><div class="ttdoc">This enables versioning on the strides of symbolically striding memory accesses in code like the foll...</div></div>
<div class="ttc" id="Value_8h_html"><div class="ttname"><a href="Value_8h.html">Value.h</a></div></div>
<div class="ttc" id="classllvm_1_1Loop_html"><div class="ttname"><a href="classllvm_1_1Loop.html">llvm::Loop</a></div><div class="ttdoc">Represents a single loop in the control flow graph. </div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l00509">LoopInfo.h:509</a></div></div>
<div class="ttc" id="MemoryLocation_8h_html"><div class="ttname"><a href="MemoryLocation_8h.html">MemoryLocation.h</a></div><div class="ttdoc">This file provides utility analysis objects describing memory locations. </div></div>
<div class="ttc" id="classllvm_1_1Value_html_adb5c319f5905c1d3ca9eb5df546388c5"><div class="ttname"><a href="classllvm_1_1Value.html#adb5c319f5905c1d3ca9eb5df546388c5">llvm::Value::getName</a></div><div class="ttdeci">StringRef getName() const</div><div class="ttdoc">Return a constant reference to the value&amp;#39;s name. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8cpp_source.html#l00215">Value.cpp:215</a></div></div>
<div class="ttc" id="DebugLoc_8h_html"><div class="ttname"><a href="DebugLoc_8h.html">DebugLoc.h</a></div></div>
<div class="ttc" id="classllvm_1_1BasicBlock_html_a38bee869ad41aebfef3de2641b12004c"><div class="ttname"><a href="classllvm_1_1BasicBlock.html#a38bee869ad41aebfef3de2641b12004c">llvm::BasicBlock::getParent</a></div><div class="ttdeci">const Function * getParent() const</div><div class="ttdoc">Return the enclosing method, or null if none. </div><div class="ttdef"><b>Definition:</b> <a href="BasicBlock_8h_source.html#l00106">BasicBlock.h:106</a></div></div>
<div class="ttc" id="MD5_8cpp_html_ac0eafdc9ee161b71e7af98af736952fd"><div class="ttname"><a href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a></div><div class="ttdeci">#define I(x, y, z)</div><div class="ttdef"><b>Definition:</b> <a href="MD5_8cpp_source.html#l00058">MD5.cpp:58</a></div></div>
<div class="ttc" id="regcomp_8c_html_a0240ac851181b84ac374872dc5434ee4"><div class="ttname"><a href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a></div><div class="ttdeci">#define N</div></div>
<div class="ttc" id="namespacellvm_html_a2816e84a08c108d18bc4665bc1817e01"><div class="ttname"><a href="namespacellvm.html#a2816e84a08c108d18bc4665bc1817e01">llvm::abs</a></div><div class="ttdeci">APFloat abs(APFloat X)</div><div class="ttdoc">Returns the absolute value of the argument. </div><div class="ttdef"><b>Definition:</b> <a href="APFloat_8h_source.html#l01233">APFloat.h:1233</a></div></div>
<div class="ttc" id="classllvm_1_1DenseMapBase_html_a65520b9c67759099e313d0f4e7b5ff9e"><div class="ttname"><a href="classllvm_1_1DenseMapBase.html#a65520b9c67759099e313d0f4e7b5ff9e">llvm::DenseMapBase::end</a></div><div class="ttdeci">iterator end()</div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00082">DenseMap.h:82</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_aa6ad96a1c2591e0a61c92e0be5776978"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#aa6ad96a1c2591e0a61c92e0be5776978">llvm::RuntimePointerChecking::Pointers</a></div><div class="ttdeci">SmallVector&lt; PointerInfo, 2 &gt; Pointers</div><div class="ttdoc">Information about the pointers that may require checking. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00453">LoopAccessAnalysis.h:453</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_ad6964f44e23ed8dd24b0dd628c0a9933"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#ad6964f44e23ed8dd24b0dd628c0a9933">VectorizationFactor</a></div><div class="ttdeci">static cl::opt&lt; unsigned, true &gt; VectorizationFactor(&quot;force-vector-width&quot;, cl::Hidden, cl::desc(&quot;Sets the SIMD width. Zero is autoselect.&quot;), cl::location(VectorizerParams::VectorizationFactor))</div></div>
<div class="ttc" id="namespacellvm_html_a4db2f71d62968b2be3c4bffc5050d8c7"><div class="ttname"><a href="namespacellvm.html#a4db2f71d62968b2be3c4bffc5050d8c7">llvm::dyn_cast</a></div><div class="ttdeci">LLVM_NODISCARD std::enable_if&lt;!is_simple_type&lt; Y &gt;::value, typename cast_retty&lt; X, const Y &gt;::ret_type &gt;::type dyn_cast(const Y &amp;Val)</div><div class="ttdef"><b>Definition:</b> <a href="Casting_8h_source.html#l00332">Casting.h:332</a></div></div>
<div class="ttc" id="Profile_8cpp_html_a1f5ab05b3305a959d954b796c63807c4"><div class="ttname"><a href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a></div><div class="ttdeci">uint32_t Size</div><div class="ttdef"><b>Definition:</b> <a href="Profile_8cpp_source.html#l00046">Profile.cpp:46</a></div></div>
<div class="ttc" id="namespacellvm_1_1ARM__MB_html_ad70272e2a9ec2a7e3a497458e1edbc85a7289f7156c17c31399fe5226bf556781"><div class="ttname"><a href="namespacellvm_1_1ARM__MB.html#ad70272e2a9ec2a7e3a497458e1edbc85a7289f7156c17c31399fe5226bf556781">llvm::ARM_MB::LD</a></div><div class="ttdef"><b>Definition:</b> <a href="MCTargetDesc_2ARMBaseInfo_8h_source.html#l00072">ARMBaseInfo.h:72</a></div></div>
<div class="ttc" id="ValueTracking_8h_html"><div class="ttname"><a href="ValueTracking_8h.html">ValueTracking.h</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a1ae9014fe6a94e931a9568117ce24dcf"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a1ae9014fe6a94e931a9568117ce24dcf">getAddressSpaceOperand</a></div><div class="ttdeci">static unsigned getAddressSpaceOperand(Value *I)</div><div class="ttdoc">Take the address space operand from the Load/Store instruction. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01163">LoopAccessAnalysis.cpp:1163</a></div></div>
<div class="ttc" id="classllvm_1_1IRBuilder_html_a840336af9ba351eb8c51640544519d64"><div class="ttname"><a href="classllvm_1_1IRBuilder.html#a840336af9ba351eb8c51640544519d64">llvm::IRBuilder::CreateAnd</a></div><div class="ttdeci">Value * CreateAnd(Value *LHS, Value *RHS, const Twine &amp;Name=&quot;&quot;)</div><div class="ttdef"><b>Definition:</b> <a href="IRBuilder_8h_source.html#l01361">IRBuilder.h:1361</a></div></div>
<div class="ttc" id="namespacellvm_html_a0d9313480c51aa626d0ce527b45471e3"><div class="ttname"><a href="namespacellvm.html#a0d9313480c51aa626d0ce527b45471e3">llvm::transform</a></div><div class="ttdeci">OutputIt transform(R &amp;&amp;Range, OutputIt d_first, UnaryPredicate P)</div><div class="ttdoc">Wrapper function around std::transform to apply a function to a range and store the result elsewhere...</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l01264">STLExtras.h:1264</a></div></div>
<div class="ttc" id="IRBuilder_8h_html"><div class="ttname"><a href="IRBuilder_8h.html">IRBuilder.h</a></div></div>
<div class="ttc" id="classllvm_1_1LoopBase_html_aa26f5f090ad68a30b5c33be53ef3e642"><div class="ttname"><a href="classllvm_1_1LoopBase.html#aa26f5f090ad68a30b5c33be53ef3e642">llvm::LoopBase::empty</a></div><div class="ttdeci">bool empty() const</div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l00151">LoopInfo.h:151</a></div></div>
<div class="ttc" id="classllvm_1_1IRBuilder_html_a9ec80ec33e99e7b6b459a4b2e4cb5e0a"><div class="ttname"><a href="classllvm_1_1IRBuilder.html#a9ec80ec33e99e7b6b459a4b2e4cb5e0a">llvm::IRBuilder::Insert</a></div><div class="ttdeci">InstTy * Insert(InstTy *I, const Twine &amp;Name=&quot;&quot;) const</div><div class="ttdoc">Insert and return the specified instruction. </div><div class="ttdef"><b>Definition:</b> <a href="IRBuilder_8h_source.html#l00917">IRBuilder.h:917</a></div></div>
<div class="ttc" id="SelectionDAGISel_8cpp_html_abe05d8ada7c1d48c65399af261ed3d67"><div class="ttname"><a href="SelectionDAGISel_8cpp.html#abe05d8ada7c1d48c65399af261ed3d67">CheckType</a></div><div class="ttdeci">static LLVM_ATTRIBUTE_ALWAYS_INLINE bool CheckType(const unsigned char *MatcherTable, unsigned &amp;MatcherIndex, SDValue N, const TargetLowering *TLI, const DataLayout &amp;DL)</div><div class="ttdef"><b>Definition:</b> <a href="SelectionDAGISel_8cpp_source.html#l02531">SelectionDAGISel.cpp:2531</a></div></div>
<div class="ttc" id="namespacellvm_html_add49d9f7abebe402adf1a57c762abeef"><div class="ttname"><a href="namespacellvm.html#add49d9f7abebe402adf1a57c762abeef">llvm::depth_first</a></div><div class="ttdeci">iterator_range&lt; df_iterator&lt; T &gt; &gt; depth_first(const T &amp;G)</div><div class="ttdef"><b>Definition:</b> <a href="DepthFirstIterator_8h_source.html#l00227">DepthFirstIterator.h:227</a></div></div>
<div class="ttc" id="SetVector_8h_html"><div class="ttname"><a href="SetVector_8h.html">SetVector.h</a></div></div>
<div class="ttc" id="structllvm_1_1MemoryDepChecker_1_1Dependence_html_af7e624cd937996851e961d72cdca670d"><div class="ttname"><a href="structllvm_1_1MemoryDepChecker_1_1Dependence.html#af7e624cd937996851e961d72cdca670d">llvm::MemoryDepChecker::Dependence::isSafeForVectorization</a></div><div class="ttdeci">static VectorizationSafetyStatus isSafeForVectorization(DepType Type)</div><div class="ttdoc">Dependence types that don&amp;#39;t prevent vectorization. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01237">LoopAccessAnalysis.cpp:1237</a></div></div>
<div class="ttc" id="classllvm_1_1EquivalenceClasses_html_ada7b2430928f6c94a0410f394c7d692b"><div class="ttname"><a href="classllvm_1_1EquivalenceClasses.html#ada7b2430928f6c94a0410f394c7d692b">llvm::EquivalenceClasses::iterator</a></div><div class="ttdeci">typename std::set&lt; ECValue &gt;::const_iterator iterator</div><div class="ttdoc">iterator* - Provides a way to iterate over all values in the set. </div><div class="ttdef"><b>Definition:</b> <a href="EquivalenceClasses_8h_source.html#l00144">EquivalenceClasses.h:144</a></div></div>
<div class="ttc" id="classllvm_1_1DenseMapIterator_html"><div class="ttname"><a href="classllvm_1_1DenseMapIterator.html">llvm::DenseMapIterator</a></div><div class="ttdef"><b>Definition:</b> <a href="DenseMap_8h_source.html#l00055">DenseMap.h:55</a></div></div>
<div class="ttc" id="SILowerControlFlow_8cpp_html_a4868c5d81c5ccc98c47aeab6244346a0"><div class="ttname"><a href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert</a></div><div class="ttdeci">assert(ImpDefSCC.getReg()==AMDGPU::SCC &amp;&amp;ImpDefSCC.isDef())</div></div>
<div class="ttc" id="classllvm_1_1Loop_html_a5bce47fa5e8edaf4eef3ddc67a78193c"><div class="ttname"><a href="classllvm_1_1Loop.html#a5bce47fa5e8edaf4eef3ddc67a78193c">llvm::Loop::isAnnotatedParallel</a></div><div class="ttdeci">bool isAnnotatedParallel() const</div><div class="ttdoc">Returns true if the loop is annotated parallel. </div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8cpp_source.html#l00537">LoopInfo.cpp:537</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_ac4acab35ff407510f8b4cf9a17c8c022"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#ac4acab35ff407510f8b4cf9a17c8c022">llvm::ScalarEvolution::getUMinExpr</a></div><div class="ttdeci">const SCEV * getUMinExpr(const SCEV *LHS, const SCEV *RHS)</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l03716">ScalarEvolution.cpp:3716</a></div></div>
<div class="ttc" id="namespacellvm_html_a076f93c387f454f0db13d4bc7d4e7f9c"><div class="ttname"><a href="namespacellvm.html#a076f93c387f454f0db13d4bc7d4e7f9c">llvm::stable_sort</a></div><div class="ttdeci">void stable_sort(R &amp;&amp;Range)</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l01306">STLExtras.h:1306</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a083bb1deb1d2ba244a99ceae9e734bc1"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a083bb1deb1d2ba244a99ceae9e734bc1">llvm::ScalarEvolution::getNegativeSCEV</a></div><div class="ttdeci">const SCEV * getNegativeSCEV(const SCEV *V, SCEV::NoWrapFlags Flags=SCEV::FlagAnyWrap)</div><div class="ttdoc">Return the SCEV object corresponding to -V. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l03953">ScalarEvolution.cpp:3953</a></div></div>
<div class="ttc" id="classllvm_1_1Value_html"><div class="ttname"><a href="classllvm_1_1Value.html">llvm::Value</a></div><div class="ttdoc">LLVM Value Representation. </div><div class="ttdef"><b>Definition:</b> <a href="Value_8h_source.html#l00074">Value.h:74</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a30bd18ac905eacf3601bc6a553a9ff49"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a30bd18ac905eacf3601bc6a553a9ff49">llvm::ScalarEvolution::getSCEV</a></div><div class="ttdeci">const SCEV * getSCEV(Value *V)</div><div class="ttdoc">Return a SCEV expression for the full generality of the specified expression. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l03906">ScalarEvolution.cpp:3906</a></div></div>
<div class="ttc" id="classllvm_1_1SetVector_html"><div class="ttname"><a href="classllvm_1_1SetVector.html">llvm::SetVector</a></div><div class="ttdoc">A vector that has set insertion semantics. </div><div class="ttdef"><b>Definition:</b> <a href="SetVector_8h_source.html#l00040">SetVector.h:40</a></div></div>
<div class="ttc" id="namespacellvm_html_a2554a96c67bdd7d0a62855a844ec55b0a92b09c7c48c520c3c55e497875da437c"><div class="ttname"><a href="namespacellvm.html#a2554a96c67bdd7d0a62855a844ec55b0a92b09c7c48c520c3c55e497875da437c">llvm::AlignStyle::Right</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a6d8769a72303e2b06ef63129cb231855"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a6d8769a72303e2b06ef63129cb231855">llvm::ScalarEvolution::isSCEVable</a></div><div class="ttdeci">bool isSCEVable(Type *Ty) const</div><div class="ttdoc">Test if values of the given type are analyzable within the SCEV framework. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l03773">ScalarEvolution.cpp:3773</a></div></div>
<div class="ttc" id="InstrTypes_8h_html"><div class="ttname"><a href="InstrTypes_8h.html">InstrTypes.h</a></div></div>
<div class="ttc" id="SmallVector_8h_html"><div class="ttname"><a href="SmallVector_8h.html">SmallVector.h</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessInfo_html_aa67d22298695c49e80b79cb8a271928b"><div class="ttname"><a href="classllvm_1_1LoopAccessInfo.html#aa67d22298695c49e80b79cb8a271928b">llvm::LoopAccessInfo::blockNeedsPredication</a></div><div class="ttdeci">static bool blockNeedsPredication(BasicBlock *BB, Loop *TheLoop, DominatorTree *DT)</div><div class="ttdoc">Return true if the block BB needs to be predicated in order for the loop to be vectorized. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02079">LoopAccessAnalysis.cpp:2079</a></div></div>
<div class="ttc" id="classllvm_1_1raw__ostream_html"><div class="ttname"><a href="classllvm_1_1raw__ostream.html">llvm::raw_ostream</a></div><div class="ttdoc">This class implements an extremely fast bulk output stream that can only output to a stream...</div><div class="ttdef"><b>Definition:</b> <a href="raw__ostream_8h_source.html#l00046">raw_ostream.h:46</a></div></div>
<div class="ttc" id="Casting_8h_html"><div class="ttname"><a href="Casting_8h.html">Casting.h</a></div></div>
<div class="ttc" id="classllvm_1_1LoopInfoWrapperPass_html"><div class="ttname"><a href="classllvm_1_1LoopInfoWrapperPass.html">llvm::LoopInfoWrapperPass</a></div><div class="ttdoc">The legacy pass manager&amp;#39;s analysis pass to compute loop information. </div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l01219">LoopInfo.h:1219</a></div></div>
<div class="ttc" id="structllvm_1_1VectorizerParams_html_a6a8f6b7564d1df823a8d8e8dcecf6802"><div class="ttname"><a href="structllvm_1_1VectorizerParams.html#a6a8f6b7564d1df823a8d8e8dcecf6802">llvm::VectorizerParams::VectorizationInterleave</a></div><div class="ttdeci">static unsigned VectorizationInterleave</div><div class="ttdoc">Interleave factor as overridden by the user. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00049">LoopAccessAnalysis.h:49</a></div></div>
<div class="ttc" id="IRTranslator_8cpp_html_abe44dfdea65b4f7e11e0a608ab708b76"><div class="ttname"><a href="IRTranslator_8cpp.html#abe44dfdea65b4f7e11e0a608ab708b76">MI</a></div><div class="ttdeci">IRTranslator LLVM IR MI</div><div class="ttdef"><b>Definition:</b> <a href="IRTranslator_8cpp_source.html#l00093">IRTranslator.cpp:93</a></div></div>
<div class="ttc" id="classllvm_1_1StringRef_html"><div class="ttname"><a href="classllvm_1_1StringRef.html">llvm::StringRef</a></div><div class="ttdoc">StringRef - Represent a constant reference to a string, i.e. </div><div class="ttdef"><b>Definition:</b> <a href="StringRef_8h_source.html#l00054">StringRef.h:54</a></div></div>
<div class="ttc" id="classllvm_1_1AnalysisManager_html"><div class="ttname"><a href="classllvm_1_1AnalysisManager.html">llvm::AnalysisManager</a></div><div class="ttdoc">A container for analyses that lazily runs them and caches their results. </div><div class="ttdef"><b>Definition:</b> <a href="InstructionSimplify_8h_source.html#l00041">InstructionSimplify.h:41</a></div></div>
<div class="ttc" id="classllvm_1_1DominatorTreeWrapperPass_html"><div class="ttname"><a href="classllvm_1_1DominatorTreeWrapperPass.html">llvm::DominatorTreeWrapperPass</a></div><div class="ttdoc">Legacy analysis pass which computes a DominatorTree. </div><div class="ttdef"><b>Definition:</b> <a href="Dominators_8h_source.html#l00259">Dominators.h:259</a></div></div>
<div class="ttc" id="raw__ostream_8h_html"><div class="ttname"><a href="raw__ostream_8h.html">raw_ostream.h</a></div></div>
<div class="ttc" id="classllvm_1_1AAResultsWrapperPass_html"><div class="ttname"><a href="classllvm_1_1AAResultsWrapperPass.html">llvm::AAResultsWrapperPass</a></div><div class="ttdoc">A wrapper pass to provide the legacy pass manager access to a suitably prepared AAResults object...</div><div class="ttdef"><b>Definition:</b> <a href="AliasAnalysis_8h_source.html#l01157">AliasAnalysis.h:1157</a></div></div>
<div class="ttc" id="PassManager_8h_html"><div class="ttname"><a href="PassManager_8h.html">PassManager.h</a></div><div class="ttdoc">This header defines various interfaces for pass management in LLVM. </div></div>
<div class="ttc" id="classllvm_1_1MemoryDepChecker_html_ac340403e4c2fd9116b74b7c2eb95633f"><div class="ttname"><a href="classllvm_1_1MemoryDepChecker.html#ac340403e4c2fd9116b74b7c2eb95633f">llvm::MemoryDepChecker::getInstructionsForAccess</a></div><div class="ttdeci">SmallVector&lt; Instruction *, 4 &gt; getInstructionsForAccess(Value *Ptr, bool isWrite) const</div><div class="ttdoc">Find the set of instructions that read or write via Ptr. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01713">LoopAccessAnalysis.cpp:1713</a></div></div>
<div class="ttc" id="structllvm_1_1VectorizerParams_html_a5ccaa3f1275b2e841f5c23852d61b872"><div class="ttname"><a href="structllvm_1_1VectorizerParams.html#a5ccaa3f1275b2e841f5c23852d61b872">llvm::VectorizerParams::isInterleaveForced</a></div><div class="ttdeci">static bool isInterleaveForced()</div><div class="ttdoc">True if force-vector-interleave was specified by the user. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00134">LoopAccessAnalysis.cpp:134</a></div></div>
<div class="ttc" id="Debug_8h_html_a08efc68d15935eb8889400a46c3749ba"><div class="ttname"><a href="Debug_8h.html#a08efc68d15935eb8889400a46c3749ba">LLVM_DEBUG</a></div><div class="ttdeci">#define LLVM_DEBUG(X)</div><div class="ttdef"><b>Definition:</b> <a href="Debug_8h_source.html#l00122">Debug.h:122</a></div></div>
<div class="ttc" id="namespacellvm_html_abb650e853db0ddbb60411b885c499737"><div class="ttname"><a href="namespacellvm.html#abb650e853db0ddbb60411b885c499737">llvm::copy</a></div><div class="ttdeci">OutputIt copy(R &amp;&amp;Range, OutputIt Out)</div><div class="ttdef"><b>Definition:</b> <a href="STLExtras_8h_source.html#l01234">STLExtras.h:1234</a></div></div>
<div class="ttc" id="classllvm_1_1LoopBase_html_a40f34cc77d2b3bc73384f535c8101858"><div class="ttname"><a href="classllvm_1_1LoopBase.html#a40f34cc77d2b3bc73384f535c8101858">llvm::LoopBase::blocks</a></div><div class="ttdeci">iterator_range&lt; block_iterator &gt; blocks() const</div><div class="ttdef"><b>Definition:</b> <a href="LoopInfo_8h_source.html#l00161">LoopInfo.h:161</a></div></div>
<div class="ttc" id="namespacellvm_html_ad93acb4fcb5adbd7e5f41deb092cb26d"><div class="ttname"><a href="namespacellvm.html#ad93acb4fcb5adbd7e5f41deb092cb26d">llvm::sortPtrAccesses</a></div><div class="ttdeci">bool sortPtrAccesses(ArrayRef&lt; Value *&gt; VL, const DataLayout &amp;DL, ScalarEvolution &amp;SE, SmallVectorImpl&lt; unsigned &gt; &amp;SortedIndices)</div><div class="ttdoc">Attempt to sort the pointers in VL and return the sorted indices in SortedIndices, if reordering is required. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l01101">LoopAccessAnalysis.cpp:1101</a></div></div>
<div class="ttc" id="classllvm_1_1LoopBase_html_adf6f53d7652b471c995b7d10f3dd2729"><div class="ttname"><a href="classllvm_1_1LoopBase.html#adf6f53d7652b471c995b7d10f3dd2729">llvm::LoopBase::getExitingBlock</a></div><div class="ttdeci">BlockT * getExitingBlock() const</div><div class="ttdoc">If getExitingBlocks would return exactly one block, return that block. </div><div class="ttdef"><b>Definition:</b> <a href="LoopInfoImpl_8h_source.html#l00049">LoopInfoImpl.h:49</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVNAryExpr_html_a7275347a4dce174f4fecd548fd3255dc"><div class="ttname"><a href="classllvm_1_1SCEVNAryExpr.html#a7275347a4dce174f4fecd548fd3255dc">llvm::SCEVNAryExpr::getNoWrapFlags</a></div><div class="ttdeci">NoWrapFlags getNoWrapFlags(NoWrapFlags Mask=NoWrapMask) const</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00175">ScalarEvolutionExpressions.h:175</a></div></div>
<div class="ttc" id="classllvm_1_1ScalarEvolution_html_a6d745b25efdc69435508f1e936919f8b"><div class="ttname"><a href="classllvm_1_1ScalarEvolution.html#a6d745b25efdc69435508f1e936919f8b">llvm::ScalarEvolution::getZeroExtendExpr</a></div><div class="ttdeci">const SCEV * getZeroExtendExpr(const SCEV *Op, Type *Ty, unsigned Depth=0)</div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolution_8cpp_source.html#l01645">ScalarEvolution.cpp:1645</a></div></div>
<div class="ttc" id="structllvm_1_1AnalysisKey_html"><div class="ttname"><a href="structllvm_1_1AnalysisKey.html">llvm::AnalysisKey</a></div><div class="ttdoc">A special type used by analysis passes to provide an address that identifies that particular analysis...</div><div class="ttdef"><b>Definition:</b> <a href="PassManager_8h_source.html#l00071">PassManager.h:71</a></div></div>
<div class="ttc" id="namespacellvm_1_1cl_html_aed47e4757f3240146f8ad40c2cdbf2d1"><div class="ttname"><a href="namespacellvm_1_1cl.html#aed47e4757f3240146f8ad40c2cdbf2d1">llvm::cl::location</a></div><div class="ttdeci">LocationClass&lt; Ty &gt; location(Ty &amp;L)</div><div class="ttdef"><b>Definition:</b> <a href="CommandLine_8h_source.html#l00451">CommandLine.h:451</a></div></div>
<div class="ttc" id="classllvm_1_1GlobalValue_html_a92041fc7f781ba4fe708eec99139b72f"><div class="ttname"><a href="classllvm_1_1GlobalValue.html#a92041fc7f781ba4fe708eec99139b72f">llvm::GlobalValue::getType</a></div><div class="ttdeci">PointerType * getType() const</div><div class="ttdoc">Global values are always pointers. </div><div class="ttdef"><b>Definition:</b> <a href="GlobalValue_8h_source.html#l00277">GlobalValue.h:277</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_a7adfee307ee23c8055467ddb7369dc16"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#a7adfee307ee23c8055467ddb7369dc16">RuntimeMemoryCheckThreshold</a></div><div class="ttdeci">static cl::opt&lt; unsigned, true &gt; RuntimeMemoryCheckThreshold(&quot;runtime-memory-check-threshold&quot;, cl::Hidden, cl::desc(&quot;When performing memory disambiguation checks at runtime do not &quot; &quot;generate more than this number of comparisons (default = 8).&quot;), cl::location(VectorizerParams::RuntimeMemoryCheckThreshold), cl::init(8))</div></div>
<div class="ttc" id="classllvm_1_1LoopAccessLegacyAnalysis_html_a6548db490a8ff769659787a27a5c94d7"><div class="ttname"><a href="classllvm_1_1LoopAccessLegacyAnalysis.html#a6548db490a8ff769659787a27a5c94d7">llvm::LoopAccessLegacyAnalysis::print</a></div><div class="ttdeci">void print(raw_ostream &amp;OS, const Module *M=nullptr) const override</div><div class="ttdoc">Print the result of the analysis when invoked with -analyze. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02414">LoopAccessAnalysis.cpp:2414</a></div></div>
<div class="ttc" id="structllvm_1_1RuntimePointerChecking_1_1PointerInfo_html_a80a449988c5d5b47f20c1b3bbd2e2a31"><div class="ttname"><a href="structllvm_1_1RuntimePointerChecking_1_1PointerInfo.html#a80a449988c5d5b47f20c1b3bbd2e2a31">llvm::RuntimePointerChecking::PointerInfo::DependencySetId</a></div><div class="ttdeci">unsigned DependencySetId</div><div class="ttdoc">Holds the id of the set of pointers that could be dependent because of a shared underlying object...</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00349">LoopAccessAnalysis.h:349</a></div></div>
<div class="ttc" id="LoopAccessAnalysis_8cpp_html_afa2510327b4f778a5926fc3bbd6fa58e"><div class="ttname"><a href="LoopAccessAnalysis_8cpp.html#afa2510327b4f778a5926fc3bbd6fa58e">isNoWrap</a></div><div class="ttdeci">static bool isNoWrap(PredicatedScalarEvolution &amp;PSE, const ValueToValueMap &amp;Strides, Value *Ptr, Loop *L)</div><div class="ttdoc">Check whether a pointer address cannot wrap. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l00641">LoopAccessAnalysis.cpp:641</a></div></div>
<div class="ttc" id="classllvm_1_1Instruction_html_a1a7f07aaef6a3bee130bf0e0f0536802"><div class="ttname"><a href="classllvm_1_1Instruction.html#a1a7f07aaef6a3bee130bf0e0f0536802">llvm::Instruction::getParent</a></div><div class="ttdeci">const BasicBlock * getParent() const</div><div class="ttdef"><b>Definition:</b> <a href="IR_2Instruction_8h_source.html#l00066">Instruction.h:66</a></div></div>
<div class="ttc" id="classllvm_1_1SCEVConstant_html"><div class="ttname"><a href="classllvm_1_1SCEVConstant.html">llvm::SCEVConstant</a></div><div class="ttdoc">This class represents a constant integer value. </div><div class="ttdef"><b>Definition:</b> <a href="ScalarEvolutionExpressions_8h_source.html#l00047">ScalarEvolutionExpressions.h:47</a></div></div>
<div class="ttc" id="classllvm_1_1RuntimePointerChecking_html_a177df4fcdf758fb57ca59102c15d30c3"><div class="ttname"><a href="classllvm_1_1RuntimePointerChecking.html#a177df4fcdf758fb57ca59102c15d30c3">llvm::RuntimePointerChecking::Need</a></div><div class="ttdeci">bool Need</div><div class="ttdoc">This flag indicates if we need to add the runtime check. </div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8h_source.html#l00450">LoopAccessAnalysis.h:450</a></div></div>
<div class="ttc" id="classllvm_1_1LoopAccessInfo_html_aaa610c0e0cd0c31c06cb09ca9dc50be0"><div class="ttname"><a href="classllvm_1_1LoopAccessInfo.html#aaa610c0e0cd0c31c06cb09ca9dc50be0">llvm::LoopAccessInfo::LoopAccessInfo</a></div><div class="ttdeci">LoopAccessInfo(Loop *L, ScalarEvolution *SE, const TargetLibraryInfo *TLI, AliasAnalysis *AA, DominatorTree *DT, LoopInfo *LI)</div><div class="ttdef"><b>Definition:</b> <a href="LoopAccessAnalysis_8cpp_source.html#l02345">LoopAccessAnalysis.cpp:2345</a></div></div>
<div class="ttc" id="classllvm_1_1SmallSet_html_a2a98f19750ba941ce791b75ca6d77e48"><div class="ttname"><a href="classllvm_1_1SmallSet.html#a2a98f19750ba941ce791b75ca6d77e48">llvm::SmallSet::count</a></div><div class="ttdeci">size_type count(const T &amp;V) const</div><div class="ttdoc">count - Return 1 if the element is in the set, 0 otherwise. </div><div class="ttdef"><b>Definition:</b> <a href="SmallSet_8h_source.html#l00164">SmallSet.h:164</a></div></div>
<div class="ttc" id="classllvm_1_1SmallVectorImpl_html_ad0b3d8447f88377b62d9c019f3c4e118"><div class="ttname"><a href="classllvm_1_1SmallVectorImpl.html#ad0b3d8447f88377b62d9c019f3c4e118">llvm::SmallVectorImpl::resize</a></div><div class="ttdeci">void resize(size_type N)</div><div class="ttdef"><b>Definition:</b> <a href="SmallVector_8h_source.html#l00344">SmallVector.h:344</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 24 2020 13:08:42 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
