<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: include/llvm/Analysis/CGSCCPassManager.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_dcde91663b8816e1e2311938ccd8f690.html">llvm</a></li><li class="navelem"><a class="el" href="dir_97cdd6ae7e6843add574fb55e792badd.html">Analysis</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CGSCCPassManager.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This header provides classes for managing passes over SCCs of the call graph.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="DenseMap_8h_source.html">llvm/ADT/DenseMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DenseSet_8h_source.html">llvm/ADT/DenseSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PriorityWorklist_8h_source.html">llvm/ADT/PriorityWorklist.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="STLExtras_8h_source.html">llvm/ADT/STLExtras.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallPtrSet_8h_source.html">llvm/ADT/SmallPtrSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallVector_8h_source.html">llvm/ADT/SmallVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LazyCallGraph_8h_source.html">llvm/Analysis/LazyCallGraph.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="CallSite_8h_source.html">llvm/IR/CallSite.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Function_8h_source.html">llvm/IR/Function.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstIterator_8h_source.html">llvm/IR/InstIterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PassManager_8h_source.html">llvm/IR/PassManager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ValueHandle_8h_source.html">llvm/IR/ValueHandle.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Debug_8h_source.html">llvm/Support/Debug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="raw__ostream_8h_source.html">llvm/Support/raw_ostream.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for CGSCCPassManager.h:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="CGSCCPassManager_8h__incl.svg" width="7014" height="963"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="CGSCCPassManager_8h__dep__incl.svg" width="3322" height="588"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="CGSCCPassManager_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1RequireAnalysisPass_3_01AnalysisT_00_01LazyCallGraph_1_1SCC_00_01CGSCCAnalysisMana0ed9ea89433c050c446a0a1ac6232466.html">llvm::RequireAnalysisPass&lt; AnalysisT, LazyCallGraph::SCC, CGSCCAnalysisManager, LazyCallGraph &amp;, CGSCCUpdateResult &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An explicit specialization of the require analysis template pass.  <a href="structllvm_1_1RequireAnalysisPass_3_01AnalysisT_00_01LazyCallGraph_1_1SCC_00_01CGSCCAnalysisMana0ed9ea89433c050c446a0a1ac6232466.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1CGSCCAnalysisManagerModuleProxy_1_1Result.html">llvm::CGSCCAnalysisManagerModuleProxy::Result&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We need a specialized result for the <code><a class="el" href="namespacellvm_1_1CGSCCAnalysisManagerModuleProxy.html">CGSCCAnalysisManagerModuleProxy</a></code> so it can have access to the call graph in order to walk all the SCCs when invalidating things.  <a href="classllvm_1_1CGSCCAnalysisManagerModuleProxy_1_1Result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structllvm_1_1CGSCCUpdateResult.html">llvm::CGSCCUpdateResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Support structure for SCC passes to communicate updates the call graph back to the CGSCC pass manager infrsatructure.  <a href="structllvm_1_1CGSCCUpdateResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1ModuleToPostOrderCGSCCPassAdaptor.html">llvm::ModuleToPostOrderCGSCCPassAdaptor&lt; CGSCCPassT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The core module pass which does a post-order walk of the SCCs and runs a CGSCC pass over each one.  <a href="classllvm_1_1ModuleToPostOrderCGSCCPassAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1FunctionAnalysisManagerCGSCCProxy.html">llvm::FunctionAnalysisManagerCGSCCProxy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy from a <code>FunctionAnalysisManager</code> to an <code>SCC</code>.  <a href="classllvm_1_1FunctionAnalysisManagerCGSCCProxy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1FunctionAnalysisManagerCGSCCProxy_1_1Result.html">llvm::FunctionAnalysisManagerCGSCCProxy::Result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1CGSCCToFunctionPassAdaptor.html">llvm::CGSCCToFunctionPassAdaptor&lt; FunctionPassT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adaptor that maps from a SCC to its functions.  <a href="classllvm_1_1CGSCCToFunctionPassAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1DevirtSCCRepeatedPass.html">llvm::DevirtSCCRepeatedPass&lt; PassT &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper that repeats an SCC pass each time an indirect call is refined to a direct call by that pass.  <a href="classllvm_1_1DevirtSCCRepeatedPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacellvm"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html">llvm</a></td></tr>
<tr class="memdesc:namespacellvm"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents lattice values for constants. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="CGSCCPassManager_8h.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;cgscc&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:abd17dd16e74c968cf01d3d32ea486696"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abd17dd16e74c968cf01d3d32ea486696">llvm::CGSCCAnalysisManager</a> = AnalysisManager&lt; LazyCallGraph::SCC, LazyCallGraph &amp; &gt;</td></tr>
<tr class="memdesc:abd17dd16e74c968cf01d3d32ea486696"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CGSCC analysis manager.  <a href="namespacellvm.html#abd17dd16e74c968cf01d3d32ea486696">More...</a><br /></td></tr>
<tr class="separator:abd17dd16e74c968cf01d3d32ea486696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b074607681632eb2640c5d50827c5e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a7b074607681632eb2640c5d50827c5e3">llvm::CGSCCPassManager</a> = PassManager&lt; LazyCallGraph::SCC, CGSCCAnalysisManager, LazyCallGraph &amp;, CGSCCUpdateResult &amp; &gt;</td></tr>
<tr class="memdesc:a7b074607681632eb2640c5d50827c5e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CGSCC pass manager.  <a href="namespacellvm.html#a7b074607681632eb2640c5d50827c5e3">More...</a><br /></td></tr>
<tr class="separator:a7b074607681632eb2640c5d50827c5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bacc57cadf852122d8aad51e2ed3c8c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0bacc57cadf852122d8aad51e2ed3c8c">llvm::CGSCCAnalysisManagerModuleProxy</a> = InnerAnalysisManagerProxy&lt; CGSCCAnalysisManager, Module &gt;</td></tr>
<tr class="memdesc:a0bacc57cadf852122d8aad51e2ed3c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy from a <code>CGSCCAnalysisManager</code> to a <code><a class="el" href="classllvm_1_1Module.html" title="A Module instance is used to store all the information related to an LLVM module. ...">Module</a></code>.  <a href="namespacellvm.html#a0bacc57cadf852122d8aad51e2ed3c8c">More...</a><br /></td></tr>
<tr class="separator:a0bacc57cadf852122d8aad51e2ed3c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eef85d42161a7fb10ee7ca423da9b0a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a5eef85d42161a7fb10ee7ca423da9b0a">llvm::ModuleAnalysisManagerCGSCCProxy</a> = OuterAnalysisManagerProxy&lt; ModuleAnalysisManager, LazyCallGraph::SCC, LazyCallGraph &amp; &gt;</td></tr>
<tr class="memdesc:a5eef85d42161a7fb10ee7ca423da9b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy from a <code>ModuleAnalysisManager</code> to an <code>SCC</code>.  <a href="namespacellvm.html#a5eef85d42161a7fb10ee7ca423da9b0a">More...</a><br /></td></tr>
<tr class="separator:a5eef85d42161a7fb10ee7ca423da9b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4fb1f363ba219f501d45c55187d9a6e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#ac4fb1f363ba219f501d45c55187d9a6e">llvm::CGSCCAnalysisManagerFunctionProxy</a> = OuterAnalysisManagerProxy&lt; CGSCCAnalysisManager, Function &gt;</td></tr>
<tr class="memdesc:ac4fb1f363ba219f501d45c55187d9a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A proxy from a <code>CGSCCAnalysisManager</code> to a <code><a class="el" href="classllvm_1_1Function.html">Function</a></code>.  <a href="namespacellvm.html#ac4fb1f363ba219f501d45c55187d9a6e">More...</a><br /></td></tr>
<tr class="separator:ac4fb1f363ba219f501d45c55187d9a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abc8fb052648437738e1aee4e879df7e1"><td class="memTemplParams" colspan="2">template&lt;typename CGSCCPassT &gt; </td></tr>
<tr class="memitem:abc8fb052648437738e1aee4e879df7e1"><td class="memTemplItemLeft" align="right" valign="top">ModuleToPostOrderCGSCCPassAdaptor&lt; CGSCCPassT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#abc8fb052648437738e1aee4e879df7e1">llvm::createModuleToPostOrderCGSCCPassAdaptor</a> (CGSCCPassT <a class="el" href="LCSSA_8cpp.html#aa687c4628fc7fd5d981fed380e1d0465">Pass</a>)</td></tr>
<tr class="memdesc:abc8fb052648437738e1aee4e879df7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to deduce a function pass type and wrap it in the templated adaptor.  <a href="namespacellvm.html#abc8fb052648437738e1aee4e879df7e1">More...</a><br /></td></tr>
<tr class="separator:abc8fb052648437738e1aee4e879df7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0594540986b6c63195a0de27e26eeb98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">LazyCallGraph::SCC</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm.html#a0594540986b6c63195a0de27e26eeb98">llvm::updateCGAndAnalysisManagerForFunctionPass</a> (<a class="el" href="classllvm_1_1LazyCallGraph.html">LazyCallGraph</a> &amp;<a class="el" href="RDFGraph_8cpp.html#af153ca0eadca8bc464492b7aba7feb00">G</a>, <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">LazyCallGraph::SCC</a> &amp;<a class="el" href="NVVMIntrRange_8cpp.html#a2ae53ee71b2ccbb52b883c0b4f59f8c2">C</a>, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">LazyCallGraph::Node</a> &amp;<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="namespacellvm.html#abd17dd16e74c968cf01d3d32ea486696">CGSCCAnalysisManager</a> &amp;AM, <a class="el" href="structllvm_1_1CGSCCUpdateResult.html">CGSCCUpdateResult</a> &amp;UR)</td></tr>
<tr class="memdesc:a0594540986b6c63195a0de27e26eeb98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to update the call graph after running a function pass.  <a href="namespacellvm.html#a0594540986b6c63195a0de27e26eeb98">More...</a><br /></td></tr>
<tr class="separator:a0594540986b6c63195a0de27e26eeb98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb7ae6d6b02ba650eddc2115fcbcfe6"><td class="memTemplParams" colspan="2">template&lt;typename FunctionPassT &gt; </td></tr>
<tr class="memitem:aceb7ae6d6b02ba650eddc2115fcbcfe6"><td class="memTemplItemLeft" align="right" valign="top">CGSCCToFunctionPassAdaptor&lt; FunctionPassT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aceb7ae6d6b02ba650eddc2115fcbcfe6">llvm::createCGSCCToFunctionPassAdaptor</a> (FunctionPassT <a class="el" href="LCSSA_8cpp.html#aa687c4628fc7fd5d981fed380e1d0465">Pass</a>)</td></tr>
<tr class="memdesc:aceb7ae6d6b02ba650eddc2115fcbcfe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to deduce a function pass type and wrap it in the templated adaptor.  <a href="namespacellvm.html#aceb7ae6d6b02ba650eddc2115fcbcfe6">More...</a><br /></td></tr>
<tr class="separator:aceb7ae6d6b02ba650eddc2115fcbcfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade8fcb58719a57a40dbd6237a6cd779"><td class="memTemplParams" colspan="2">template&lt;typename PassT &gt; </td></tr>
<tr class="memitem:aade8fcb58719a57a40dbd6237a6cd779"><td class="memTemplItemLeft" align="right" valign="top">DevirtSCCRepeatedPass&lt; PassT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacellvm.html#aade8fcb58719a57a40dbd6237a6cd779">llvm::createDevirtSCCRepeatedPass</a> (PassT <a class="el" href="LCSSA_8cpp.html#aa687c4628fc7fd5d981fed380e1d0465">Pass</a>, int <a class="el" href="CallGraphSCCPass_8cpp.html#a787c97cc3fe8c5f2ea1a5a09abaab710">MaxIterations</a>)</td></tr>
<tr class="memdesc:aade8fcb58719a57a40dbd6237a6cd779"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to deduce a function pass type and wrap it in the templated adaptor.  <a href="namespacellvm.html#aade8fcb58719a57a40dbd6237a6cd779">More...</a><br /></td></tr>
<tr class="separator:aade8fcb58719a57a40dbd6237a6cd779"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This header provides classes for managing passes over SCCs of the call graph. </p>
<p>These passes form an important component of LLVM's interprocedural optimizations. Because they operate on the SCCs of the call graph, and they traverse the graph in post-order, they can effectively do pair-wise interprocedural optimizations for all call edges in the program while incrementally refining it and improving the context of these pair-wise optimizations. At each call site edge, the callee has already been optimized as much as is possible. This in turn allows very accurate analysis of it for IPO.</p>
<p>A secondary more general goal is to be able to isolate optimization on unrelated parts of the IR module. This is useful to ensure our optimizations are principled and don't miss oportunities where refinement of one part of the module influence transformations in another part of the module. But this is also useful if we want to parallelize the optimizations across common large module graph shapes which tend to be very wide and have large regions of unrelated cliques.</p>
<p>To satisfy these goals, we use the LazyCallGraph which provides two graphs nested inside each other (and built lazily from the bottom-up): the call graph proper, and a reference graph. The reference graph is super set of the call graph and is a conservative approximation of what could through scalar or CGSCC transforms <em>become</em> the call graph. Using this allows us to ensure we optimize functions prior to them being introduced into the call graph by devirtualization or other technique, and thus ensures that subsequent pair-wise interprocedural optimizations observe the optimized form of these functions. The (potentially transitive) reference reachability used by the reference graph is a conservative approximation that still allows us to have independent regions of the graph.</p>
<p>FIXME: There is one major drawback of the reference graph: in its naive form it is quadratic because it contains a distinct edge for each (potentially indirect) reference, even if are all through some common global table of function pointers. This can be fixed in a number of ways that essentially preserve enough of the normalization. While it isn't expected to completely preclude the usability of this, it will need to be addressed.</p>
<p>All of these issues are made substantially more complex in the face of mutations to the call graph while optimization passes are being run. When mutations to the call graph occur we want to achieve two different things:</p>
<ul>
<li>We need to update the call graph in-flight and invalidate analyses cached on entities in the graph. Because of the cache-based analysis design of the pass manager, it is essential to have stable identities for the elements of the IR that passes traverse, and to invalidate any analyses cached on these elements as the mutations take place.</li>
<li>We want to preserve the incremental and post-order traversal of the graph even as it is refined and mutated. This means we want optimization to observe the most refined form of the call graph and to do so in post-order.</li>
</ul>
<p>To address this, the CGSCC manager uses both worklists that can be expanded by passes which transform the IR, and provides invalidation tests to skip entries that become dead. This extra data is provided to every SCC pass so that it can carefully update the manager's traversal as the call graph mutates.</p>
<p>We also provide support for running function passes within the CGSCC walk, and there we provide automatic update of the call graph including of the pass manager to reflect call graph changes that fall out naturally as part of scalar transformations.</p>
<p>The patterns used to ensure the goals of post-order visitation of the fully refined graph:</p>
<p>1) Sink toward the "bottom" as the graph is refined. This means that any iteration continues in some valid post-order sequence after the mutation has altered the structure.</p>
<p>2) Enqueue in post-order, including the current entity. If the current entity's shape changes, it and everything after it in post-order needs to be visited to observe that shape. </p>

<p class="definition">Definition in file <a class="el" href="CGSCCPassManager_8h_source.html">CGSCCPassManager.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;cgscc&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="CGSCCPassManager_8h_source.html#l00115">115</a> of file <a class="el" href="CGSCCPassManager_8h_source.html">CGSCCPassManager.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 24 2020 13:15:49 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
