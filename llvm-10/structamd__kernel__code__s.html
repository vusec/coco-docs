<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: amd_kernel_code_s Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structamd__kernel__code__s-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">amd_kernel_code_s Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>AMD Kernel Code Object (amd_kernel_code_t).  
 <a href="structamd__kernel__code__s.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="AMDKernelCodeT_8h_source.html">Target/AMDGPU/AMDKernelCodeT.h</a>&quot;</code></p>
<div class="dynheader">
Collaboration diagram for amd_kernel_code_s:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structamd__kernel__code__s__coll__graph.svg" width="1068" height="318"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1b1471432d05c97aa4c1848c1d852bbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a1b1471432d05c97aa4c1848c1d852bbf">amd_kernel_code_version_major</a></td></tr>
<tr class="separator:a1b1471432d05c97aa4c1848c1d852bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2862a0fae72aca5a5d2f736e7c5ecd8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a2862a0fae72aca5a5d2f736e7c5ecd8f">amd_kernel_code_version_minor</a></td></tr>
<tr class="separator:a2862a0fae72aca5a5d2f736e7c5ecd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ec65b2962862fd9dd574d03f703c03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a13ec65b2962862fd9dd574d03f703c03">amd_machine_kind</a></td></tr>
<tr class="separator:a13ec65b2962862fd9dd574d03f703c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe314d3e44dc3cd05b73b89687cbb0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#aabe314d3e44dc3cd05b73b89687cbb0c">amd_machine_version_major</a></td></tr>
<tr class="separator:aabe314d3e44dc3cd05b73b89687cbb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ca07a7804433b0e26ecc20d9e1a531"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a25ca07a7804433b0e26ecc20d9e1a531">amd_machine_version_minor</a></td></tr>
<tr class="separator:a25ca07a7804433b0e26ecc20d9e1a531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c41c5ce2132d8a93f27199dfc681f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a85c41c5ce2132d8a93f27199dfc681f6">amd_machine_version_stepping</a></td></tr>
<tr class="separator:a85c41c5ce2132d8a93f27199dfc681f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80a7b908b126b9edccb7812d1051e6e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab80a7b908b126b9edccb7812d1051e6e">kernel_code_entry_byte_offset</a></td></tr>
<tr class="memdesc:ab80a7b908b126b9edccb7812d1051e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byte offset (possibly negative) from start of amd_kernel_code_t object to kernel's entry point instruction.  <a href="#ab80a7b908b126b9edccb7812d1051e6e">More...</a><br /></td></tr>
<tr class="separator:ab80a7b908b126b9edccb7812d1051e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d19b3dfc497632c6d955628495a1dd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a79d19b3dfc497632c6d955628495a1dd">kernel_code_prefetch_byte_offset</a></td></tr>
<tr class="memdesc:a79d19b3dfc497632c6d955628495a1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range of bytes to consider prefetching expressed as an offset and size.  <a href="#a79d19b3dfc497632c6d955628495a1dd">More...</a><br /></td></tr>
<tr class="separator:a79d19b3dfc497632c6d955628495a1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fae4434b5596645ae4911169a18ba21"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a1fae4434b5596645ae4911169a18ba21">kernel_code_prefetch_byte_size</a></td></tr>
<tr class="separator:a1fae4434b5596645ae4911169a18ba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c9d6cce2fabfe6381599fe9f3914e2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a38c9d6cce2fabfe6381599fe9f3914e2">reserved0</a></td></tr>
<tr class="memdesc:a38c9d6cce2fabfe6381599fe9f3914e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserved. Must be 0.  <a href="#a38c9d6cce2fabfe6381599fe9f3914e2">More...</a><br /></td></tr>
<tr class="separator:a38c9d6cce2fabfe6381599fe9f3914e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4903883a5d71f2a447f17c0ceb65bb9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#aa4903883a5d71f2a447f17c0ceb65bb9">compute_pgm_resource_registers</a></td></tr>
<tr class="memdesc:aa4903883a5d71f2a447f17c0ceb65bb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shader program settings for CS.  <a href="#aa4903883a5d71f2a447f17c0ceb65bb9">More...</a><br /></td></tr>
<tr class="separator:aa4903883a5d71f2a447f17c0ceb65bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1bb613dbce7e5d95d7008343cc5263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a3a1bb613dbce7e5d95d7008343cc5263">code_properties</a></td></tr>
<tr class="memdesc:a3a1bb613dbce7e5d95d7008343cc5263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code properties.  <a href="#a3a1bb613dbce7e5d95d7008343cc5263">More...</a><br /></td></tr>
<tr class="separator:a3a1bb613dbce7e5d95d7008343cc5263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df57402a4d6bce6adc008a2c2703630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a4df57402a4d6bce6adc008a2c2703630">workitem_private_segment_byte_size</a></td></tr>
<tr class="memdesc:a4df57402a4d6bce6adc008a2c2703630"><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of memory required for the combined private, spill and arg segments for a work-item in bytes.  <a href="#a4df57402a4d6bce6adc008a2c2703630">More...</a><br /></td></tr>
<tr class="separator:a4df57402a4d6bce6adc008a2c2703630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d1342950ad5679cb75e5a551583961"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a76d1342950ad5679cb75e5a551583961">workgroup_group_segment_byte_size</a></td></tr>
<tr class="memdesc:a76d1342950ad5679cb75e5a551583961"><td class="mdescLeft">&#160;</td><td class="mdescRight">The amount of group segment memory required by a work-group in bytes.  <a href="#a76d1342950ad5679cb75e5a551583961">More...</a><br /></td></tr>
<tr class="separator:a76d1342950ad5679cb75e5a551583961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab131471b40714a56b941ba224df46401"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab131471b40714a56b941ba224df46401">gds_segment_byte_size</a></td></tr>
<tr class="memdesc:ab131471b40714a56b941ba224df46401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of byte of GDS required by kernel dispatch.  <a href="#ab131471b40714a56b941ba224df46401">More...</a><br /></td></tr>
<tr class="separator:ab131471b40714a56b941ba224df46401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa840eff57f443d0ad4f62ddd4d6d9e7f"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#aa840eff57f443d0ad4f62ddd4d6d9e7f">kernarg_segment_byte_size</a></td></tr>
<tr class="memdesc:aa840eff57f443d0ad4f62ddd4d6d9e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size in bytes of the kernarg segment that holds the values of the arguments to the kernel.  <a href="#aa840eff57f443d0ad4f62ddd4d6d9e7f">More...</a><br /></td></tr>
<tr class="separator:aa840eff57f443d0ad4f62ddd4d6d9e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd3b0027b18bfb68447eff86ae369de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint32__t.html">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a0fd3b0027b18bfb68447eff86ae369de">workgroup_fbarrier_count</a></td></tr>
<tr class="memdesc:a0fd3b0027b18bfb68447eff86ae369de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of fbarrier's used in the kernel and all functions it calls.  <a href="#a0fd3b0027b18bfb68447eff86ae369de">More...</a><br /></td></tr>
<tr class="separator:a0fd3b0027b18bfb68447eff86ae369de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ca3407b13af2f0d9a9c80ce582c37b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab8ca3407b13af2f0d9a9c80ce582c37b">wavefront_sgpr_count</a></td></tr>
<tr class="memdesc:ab8ca3407b13af2f0d9a9c80ce582c37b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of scalar registers used by a wavefront.  <a href="#ab8ca3407b13af2f0d9a9c80ce582c37b">More...</a><br /></td></tr>
<tr class="separator:ab8ca3407b13af2f0d9a9c80ce582c37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6400e51805c0d3e6658f51e0f4b1258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ad6400e51805c0d3e6658f51e0f4b1258">workitem_vgpr_count</a></td></tr>
<tr class="memdesc:ad6400e51805c0d3e6658f51e0f4b1258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of vector registers used by each work-item.  <a href="#ad6400e51805c0d3e6658f51e0f4b1258">More...</a><br /></td></tr>
<tr class="separator:ad6400e51805c0d3e6658f51e0f4b1258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110a82e27c4c538dd9265a897043f666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a110a82e27c4c538dd9265a897043f666">reserved_vgpr_first</a></td></tr>
<tr class="memdesc:a110a82e27c4c538dd9265a897043f666"><td class="mdescLeft">&#160;</td><td class="mdescRight">If reserved_vgpr_count is 0 then must be 0.  <a href="#a110a82e27c4c538dd9265a897043f666">More...</a><br /></td></tr>
<tr class="separator:a110a82e27c4c538dd9265a897043f666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6757964e0e2e4a2f85ea0d3aef282668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a6757964e0e2e4a2f85ea0d3aef282668">reserved_vgpr_count</a></td></tr>
<tr class="memdesc:a6757964e0e2e4a2f85ea0d3aef282668"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of consecutive VGPRs reserved by the client.  <a href="#a6757964e0e2e4a2f85ea0d3aef282668">More...</a><br /></td></tr>
<tr class="separator:a6757964e0e2e4a2f85ea0d3aef282668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ded9dece15b44ade5de4f64617bbc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab3ded9dece15b44ade5de4f64617bbc1">reserved_sgpr_first</a></td></tr>
<tr class="memdesc:ab3ded9dece15b44ade5de4f64617bbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If reserved_sgpr_count is 0 then must be 0.  <a href="#ab3ded9dece15b44ade5de4f64617bbc1">More...</a><br /></td></tr>
<tr class="separator:ab3ded9dece15b44ade5de4f64617bbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08abdcbd560da11ea18952a8addd07c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab08abdcbd560da11ea18952a8addd07c">reserved_sgpr_count</a></td></tr>
<tr class="memdesc:ab08abdcbd560da11ea18952a8addd07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of consecutive SGPRs reserved by the client.  <a href="#ab08abdcbd560da11ea18952a8addd07c">More...</a><br /></td></tr>
<tr class="separator:ab08abdcbd560da11ea18952a8addd07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d620d42712646db99a1161164288821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a7d620d42712646db99a1161164288821">debug_wavefront_private_segment_offset_sgpr</a></td></tr>
<tr class="memdesc:a7d620d42712646db99a1161164288821"><td class="mdescLeft">&#160;</td><td class="mdescRight">If is_debug_supported is 0 then must be 0.  <a href="#a7d620d42712646db99a1161164288821">More...</a><br /></td></tr>
<tr class="separator:a7d620d42712646db99a1161164288821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ab4a23378c0a0447856cab09d99d3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classuint16__t.html">uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#af9ab4a23378c0a0447856cab09d99d3b">debug_private_segment_buffer_sgpr</a></td></tr>
<tr class="memdesc:af9ab4a23378c0a0447856cab09d99d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If is_debug_supported is 0 then must be 0.  <a href="#af9ab4a23378c0a0447856cab09d99d3b">More...</a><br /></td></tr>
<tr class="separator:af9ab4a23378c0a0447856cab09d99d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85002142572904a6c1cfd34a7be4516"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#af85002142572904a6c1cfd34a7be4516">kernarg_segment_alignment</a></td></tr>
<tr class="memdesc:af85002142572904a6c1cfd34a7be4516"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum byte alignment of variables used by the kernel in the specified memory segment.  <a href="#af85002142572904a6c1cfd34a7be4516">More...</a><br /></td></tr>
<tr class="separator:af85002142572904a6c1cfd34a7be4516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc095c5422453e140bacab2f6ee4258"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a1dc095c5422453e140bacab2f6ee4258">group_segment_alignment</a></td></tr>
<tr class="separator:a1dc095c5422453e140bacab2f6ee4258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec21277f6bea3560d5e94e420c1552b"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a5ec21277f6bea3560d5e94e420c1552b">private_segment_alignment</a></td></tr>
<tr class="separator:a5ec21277f6bea3560d5e94e420c1552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e1a521e8178224bf3e065bbccbd94d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#ab1e1a521e8178224bf3e065bbccbd94d">wavefront_size</a></td></tr>
<tr class="memdesc:ab1e1a521e8178224bf3e065bbccbd94d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wavefront size expressed as a power of two.  <a href="#ab1e1a521e8178224bf3e065bbccbd94d">More...</a><br /></td></tr>
<tr class="separator:ab1e1a521e8178224bf3e065bbccbd94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bc90ded26f094af7a9c6f8e543c01d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a12bc90ded26f094af7a9c6f8e543c01d">call_convention</a></td></tr>
<tr class="separator:a12bc90ded26f094af7a9c6f8e543c01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f604ec796b7b3c6a711f2cbf235d6c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a44f604ec796b7b3c6a711f2cbf235d6c">reserved3</a> [12]</td></tr>
<tr class="separator:a44f604ec796b7b3c6a711f2cbf235d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4388bf1729c7913f4bcca568c2d8d02"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#af4388bf1729c7913f4bcca568c2d8d02">runtime_loader_kernel_symbol</a></td></tr>
<tr class="separator:af4388bf1729c7913f4bcca568c2d8d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba7e94f39f031a84a44f97d924ce850"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structamd__kernel__code__s.html#a9ba7e94f39f031a84a44f97d924ce850">control_directives</a> [16]</td></tr>
<tr class="separator:a9ba7e94f39f031a84a44f97d924ce850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>AMD Kernel Code Object (amd_kernel_code_t). </p>
<p>GPU CP uses the AMD Kernel Code Object to set up the hardware to execute the kernel dispatch.</p>
<p>Initial Kernel Register State.</p>
<p>Initial kernel register state will be set up by CP/SPI prior to the start of execution of every wavefront. This is limited by the constraints of the current hardware.</p>
<p>The order of the SGPR registers is defined, but the Finalizer can specify which ones are actually setup in the amd_kernel_code_t object using the enable_sgpr_* bit fields. The register numbers used for enabled registers are dense starting at SGPR0: the first enabled register is SGPR0, the next enabled register is SGPR1 etc.; disabled registers do not have an SGPR number.</p>
<p>The initial SGPRs comprise up to 16 User SRGPs that are set up by CP and apply to all waves of the grid. It is possible to specify more than 16 User SGPRs using the enable_sgpr_* bit fields, in which case only the first 16 are actually initialized. These are then immediately followed by the System SGPRs that are set up by ADC/SPI and can have different values for each wave of the grid dispatch.</p>
<p>SGPR register initial state is defined as follows:</p>
<p>Private Segment Buffer (enable_sgpr_private_segment_buffer): Number of User SGPR registers: 4. V# that can be used, together with Scratch Wave Offset as an offset, to access the Private/Spill/Arg segments using a segment address. It must be set as follows:</p><ul>
<li>Base address: of the scratch memory area used by the dispatch. It does not include the scratch wave offset. It will be the per process SH_HIDDEN_PRIVATE_BASE_VMID plus any offset from this dispatch (for example there may be a per pipe offset, or per AQL Queue offset).</li>
<li>Stride + data_format: Element Size * Index Stride (???)</li>
<li>Cache swizzle: ???</li>
<li>Swizzle enable: SH_STATIC_MEM_CONFIG.SWIZZLE_ENABLE (must be 1 for scratch)</li>
<li>Num records: Flat Scratch Work Item Size / Element Size (???)</li>
<li>Dst_sel_*: ???</li>
<li>Num_format: ???</li>
<li>Element_size: SH_STATIC_MEM_CONFIG.ELEMENT_SIZE (will be DWORD, must agree with amd_kernel_code_t.privateElementSize)</li>
<li>Index_stride: SH_STATIC_MEM_CONFIG.INDEX_STRIDE (will be 64 as must be number of wavefront lanes for scratch, must agree with amd_kernel_code_t.wavefrontSize)</li>
<li>Add tid enable: 1</li>
<li>ATC: from SH_MEM_CONFIG.PRIVATE_ATC,</li>
<li>Hash_enable: ???</li>
<li>Heap: ???</li>
<li>Mtype: from SH_STATIC_MEM_CONFIG.PRIVATE_MTYPE</li>
<li>Type: 0 (a buffer) (???)</li>
</ul>
<p>Dispatch Ptr (enable_sgpr_dispatch_ptr): Number of User SGPR registers: 2. 64 bit address of AQL dispatch packet for kernel actually executing.</p>
<p>Queue Ptr (enable_sgpr_queue_ptr): Number of User SGPR registers: 2. 64 bit address of AmdQueue object for AQL queue on which the dispatch packet was queued.</p>
<p>Kernarg Segment Ptr (enable_sgpr_kernarg_segment_ptr): Number of User SGPR registers: 2. 64 bit address of Kernarg segment. This is directly copied from the kernargPtr in the dispatch packet. Having CP load it once avoids loading it at the beginning of every wavefront.</p>
<p>Dispatch Id (enable_sgpr_dispatch_id): Number of User SGPR registers: 2. 64 bit Dispatch ID of the dispatch packet being executed.</p>
<p>Flat Scratch Init (enable_sgpr_flat_scratch_init): Number of User SGPR registers: 2. This is 2 SGPRs.</p>
<p>For CI/VI: The first SGPR is a 32 bit byte offset from SH_MEM_HIDDEN_PRIVATE_BASE to base of memory for scratch for this dispatch. This is the same offset used in computing the Scratch Segment Buffer base address. The value of Scratch Wave Offset must be added by the kernel code and moved to SGPRn-4 for use as the FLAT SCRATCH BASE in flat memory instructions.</p>
<p>The second SGPR is 32 bit byte size of a single work-item's scratch memory usage. This is directly loaded from the dispatch packet Private Segment Byte Size and rounded up to a multiple of DWORD.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>[Does CP need to round this to &gt;4 byte alignment?]</dd></dl>
<pre class="fragment">The kernel code must move to SGPRn-3 for use as the FLAT SCRATCH SIZE in
flat memory instructions. Having CP load it once avoids loading it at
the beginning of every wavefront.
</pre><p>For PI: This is the 64 bit base address of the scratch backing memory for allocated by CP for this dispatch.</p>
<p>Private Segment Size (enable_sgpr_private_segment_size): Number of User SGPR registers: 1. The 32 bit byte size of a single work-item's scratch memory allocation. This is the value from the dispatch packet. Private Segment Byte Size rounded up by CP to a multiple of DWORD.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>[Does CP need to round this to &gt;4 byte alignment?]</dd></dl>
<p>Having CP load it once avoids loading it at the beginning of every wavefront.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>[This will not be used for CI/VI since it is the same value as the second SGPR of Flat Scratch Init. However, it is need for PI which changes meaning of Flat Scratchg Init..]</dd></dl>
<p>Grid Work-Group Count X (enable_sgpr_grid_workgroup_count_x): Number of User SGPR registers: 1. 32 bit count of the number of work-groups in the X dimension for the grid being executed. Computed from the fields in the HsaDispatchPacket as ((gridSize.x+workgroupSize.x-1)/workgroupSize.x).</p>
<p>Grid Work-Group Count Y (enable_sgpr_grid_workgroup_count_y): Number of User SGPR registers: 1. 32 bit count of the number of work-groups in the Y dimension for the grid being executed. Computed from the fields in the HsaDispatchPacket as ((gridSize.y+workgroupSize.y-1)/workgroupSize.y).</p>
<p>Only initialized if &lt;16 previous SGPRs initialized.</p>
<p>Grid Work-Group Count Z (enable_sgpr_grid_workgroup_count_z): Number of User SGPR registers: 1. 32 bit count of the number of work-groups in the Z dimension for the grid being executed. Computed from the fields in the HsaDispatchPacket as ((gridSize.z+workgroupSize.z-1)/workgroupSize.z).</p>
<p>Only initialized if &lt;16 previous SGPRs initialized.</p>
<p>Work-Group Id X (enable_sgpr_workgroup_id_x): Number of System SGPR registers: 1. 32 bit work group id in X dimension of grid for wavefront. Always present.</p>
<p>Work-Group Id Y (enable_sgpr_workgroup_id_y): Number of System SGPR registers: 1. 32 bit work group id in Y dimension of grid for wavefront.</p>
<p>Work-Group Id Z (enable_sgpr_workgroup_id_z): Number of System SGPR registers: 1. 32 bit work group id in Z dimension of grid for wavefront. If present then Work-group Id Y will also be present</p>
<p>Work-Group Info (enable_sgpr_workgroup_info): Number of System SGPR registers: 1. {first_wave, 14'b0000, ordered_append_term[10:0], threadgroup_size_in_waves[5:0]}</p>
<p>Private Segment Wave Byte Offset (enable_sgpr_private_segment_wave_byte_offset): Number of System SGPR registers: 1. 32 bit byte offset from base of dispatch scratch base. Must be used as an offset with Private/Spill/Arg segment address when using Scratch Segment Buffer. It must be added to Flat Scratch Offset if setting up FLAT SCRATCH for flat addressing.</p>
<p>The order of the VGPR registers is defined, but the Finalizer can specify which ones are actually setup in the amd_kernel_code_t object using the enableVgpr* bit fields. The register numbers used for enabled registers are dense starting at VGPR0: the first enabled register is VGPR0, the next enabled register is VGPR1 etc.; disabled registers do not have an VGPR number.</p>
<p>VGPR register initial state is defined as follows:</p>
<p>Work-Item Id X (always initialized): Number of registers: 1. 32 bit work item id in X dimension of work-group for wavefront lane.</p>
<p>Work-Item Id X (enable_vgpr_workitem_id &gt; 0): Number of registers: 1. 32 bit work item id in Y dimension of work-group for wavefront lane.</p>
<p>Work-Item Id X (enable_vgpr_workitem_id &gt; 0): Number of registers: 1. 32 bit work item id in Z dimension of work-group for wavefront lane.</p>
<p>The setting of registers is being done by existing GPU hardware as follows: 1) SGPRs before the Work-Group Ids are set by CP using the 16 User Data registers. 2) Work-group Id registers X, Y, Z are set by SPI which supports any combination including none. 3) Scratch Wave Offset is also set by SPI which is why its value cannot be added into the value Flat Scratch Offset which would avoid the Finalizer generated prolog having to do the add. 4) The VGPRs are set by SPI which only supports specifying either (X), (X, Y) or (X, Y, Z).</p>
<p>Flat Scratch Dispatch Offset and Flat Scratch Size are adjacent SGRRs so they can be moved as a 64 bit value to the hardware required SGPRn-3 and SGPRn-4 respectively using the Finalizer ?FLAT_SCRATCH? Register.</p>
<p>The global segment can be accessed either using flat operations or buffer operations. If buffer operations are used then the Global Buffer used to access HSAIL Global/Readonly/Kernarg (which are combine) segments using a segment address is not passed into the kernel code by CP since its base address is always 0. Instead the Finalizer generates prolog code to initialize 4 SGPRs with a V# that has the following properties, and then uses that in the buffer instructions:</p><ul>
<li>base address of 0</li>
<li>no swizzle</li>
<li>ATC=1</li>
<li>MTYPE set to support memory coherence specified in amd_kernel_code_t.globalMemoryCoherence</li>
</ul>
<p>When the Global Buffer is used to access the Kernarg segment, must add the dispatch packet kernArgPtr to a kernarg segment address before using this V#. Alternatively scalar loads can be used if the kernarg offset is uniform, as the kernarg segment is constant for the duration of the kernel execution. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00530">530</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>
</div><h2 class="groupheader">Member Data Documentation</h2>
<a id="a1b1471432d05c97aa4c1848c1d852bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1471432d05c97aa4c1848c1d852bbf">&#9670;&nbsp;</a></span>amd_kernel_code_version_major</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint32__t.html">uint32_t</a> amd_kernel_code_s::amd_kernel_code_version_major</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00531">531</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a2862a0fae72aca5a5d2f736e7c5ecd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2862a0fae72aca5a5d2f736e7c5ecd8f">&#9670;&nbsp;</a></span>amd_kernel_code_version_minor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint32__t.html">uint32_t</a> amd_kernel_code_s::amd_kernel_code_version_minor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00532">532</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a13ec65b2962862fd9dd574d03f703c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ec65b2962862fd9dd574d03f703c03">&#9670;&nbsp;</a></span>amd_machine_kind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::amd_machine_kind</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00533">533</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="aabe314d3e44dc3cd05b73b89687cbb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe314d3e44dc3cd05b73b89687cbb0c">&#9670;&nbsp;</a></span>amd_machine_version_major</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::amd_machine_version_major</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00534">534</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a25ca07a7804433b0e26ecc20d9e1a531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ca07a7804433b0e26ecc20d9e1a531">&#9670;&nbsp;</a></span>amd_machine_version_minor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::amd_machine_version_minor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00535">535</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a85c41c5ce2132d8a93f27199dfc681f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c41c5ce2132d8a93f27199dfc681f6">&#9670;&nbsp;</a></span>amd_machine_version_stepping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::amd_machine_version_stepping</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00536">536</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a12bc90ded26f094af7a9c6f8e543c01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12bc90ded26f094af7a9c6f8e543c01d">&#9670;&nbsp;</a></span>call_convention</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t amd_kernel_code_s::call_convention</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00649">649</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a3a1bb613dbce7e5d95d7008343cc5263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1bb613dbce7e5d95d7008343cc5263">&#9670;&nbsp;</a></span>code_properties</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint32__t.html">uint32_t</a> amd_kernel_code_s::code_properties</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Code properties. </p>
<p>See amd_code_property_mask_t for a full list of properties. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00566">566</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUAsmPrinter_8cpp_source.html#l01208">getElementByteSizeValue()</a>, and <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="aa4903883a5d71f2a447f17c0ceb65bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4903883a5d71f2a447f17c0ceb65bb9">&#9670;&nbsp;</a></span>compute_pgm_resource_registers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t amd_kernel_code_s::compute_pgm_resource_registers</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shader program settings for CS. </p>
<p>Contains COMPUTE_PGM_RSRC1 and COMPUTE_PGM_RSRC2 registers. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00562">562</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUAsmPrinter_8cpp_source.html#l01208">getElementByteSizeValue()</a>, and <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a9ba7e94f39f031a84a44f97d924ce850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba7e94f39f031a84a44f97d924ce850">&#9670;&nbsp;</a></span>control_directives</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t amd_kernel_code_s::control_directives[16]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00652">652</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="af9ab4a23378c0a0447856cab09d99d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ab4a23378c0a0447856cab09d99d3b">&#9670;&nbsp;</a></span>debug_private_segment_buffer_sgpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::debug_private_segment_buffer_sgpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If is_debug_supported is 0 then must be 0. </p>
<p>Otherwise, this is the fixed SGPR number of the first of 4 SGPRs used to hold the scratch V# used for the entire kernel execution, or uint16_t(-1) if the registers are not used or not known. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00633">633</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="a7d620d42712646db99a1161164288821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d620d42712646db99a1161164288821">&#9670;&nbsp;</a></span>debug_wavefront_private_segment_offset_sgpr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::debug_wavefront_private_segment_offset_sgpr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If is_debug_supported is 0 then must be 0. </p>
<p>Otherwise, this is the fixed SGPR number used to hold the wave scratch offset for the entire kernel execution, or uint16_t(-1) if the register is not used or not known. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00627">627</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="ab131471b40714a56b941ba224df46401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab131471b40714a56b941ba224df46401">&#9670;&nbsp;</a></span>gds_segment_byte_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint32__t.html">uint32_t</a> amd_kernel_code_s::gds_segment_byte_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of byte of GDS required by kernel dispatch. </p>
<p>Must be 0 if not using GDS. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00582">582</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="a1dc095c5422453e140bacab2f6ee4258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc095c5422453e140bacab2f6ee4258">&#9670;&nbsp;</a></span>group_segment_alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t amd_kernel_code_s::group_segment_alignment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00639">639</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="af85002142572904a6c1cfd34a7be4516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85002142572904a6c1cfd34a7be4516">&#9670;&nbsp;</a></span>kernarg_segment_alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t amd_kernel_code_s::kernarg_segment_alignment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum byte alignment of variables used by the kernel in the specified memory segment. </p>
<p>Expressed as a power of two. Must be at least HSA_POWERTWO_16. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00638">638</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUAsmPrinter_8cpp_source.html#l01208">getElementByteSizeValue()</a>, and <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="aa840eff57f443d0ad4f62ddd4d6d9e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa840eff57f443d0ad4f62ddd4d6d9e7f">&#9670;&nbsp;</a></span>kernarg_segment_byte_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t amd_kernel_code_s::kernarg_segment_byte_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size in bytes of the kernarg segment that holds the values of the arguments to the kernel. </p>
<p>This could be used by CP to prefetch the kernarg segment pointed to by the dispatch packet. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00587">587</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUAsmPrinter_8cpp_source.html#l01208">getElementByteSizeValue()</a>.</p>

</div>
</div>
<a id="ab80a7b908b126b9edccb7812d1051e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80a7b908b126b9edccb7812d1051e6e">&#9670;&nbsp;</a></span>kernel_code_entry_byte_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t amd_kernel_code_s::kernel_code_entry_byte_offset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Byte offset (possibly negative) from start of amd_kernel_code_t object to kernel's entry point instruction. </p>
<p>The actual code for the kernel is required to be 256 byte aligned to match hardware requirements (SQ cache line is 16). The code must be position independent code (PIC) for AMD devices to give runtime the option of copying code to discrete GPU memory or APU L2 cache. The Finalizer should endeavour to allocate all kernel machine code in contiguous memory pages so that a device pre-fetcher will tend to only pre-fetch Kernel Code objects, improving cache performance. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00548">548</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a79d19b3dfc497632c6d955628495a1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d19b3dfc497632c6d955628495a1dd">&#9670;&nbsp;</a></span>kernel_code_prefetch_byte_offset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t amd_kernel_code_s::kernel_code_prefetch_byte_offset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range of bytes to consider prefetching expressed as an offset and size. </p>
<p>The offset is from the start (possibly negative) of amd_kernel_code_t object. Set both to 0 if no prefetch information is available. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00554">554</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="a1fae4434b5596645ae4911169a18ba21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fae4434b5596645ae4911169a18ba21">&#9670;&nbsp;</a></span>kernel_code_prefetch_byte_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t amd_kernel_code_s::kernel_code_prefetch_byte_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00555">555</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="a5ec21277f6bea3560d5e94e420c1552b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec21277f6bea3560d5e94e420c1552b">&#9670;&nbsp;</a></span>private_segment_alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t amd_kernel_code_s::private_segment_alignment</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00640">640</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a38c9d6cce2fabfe6381599fe9f3914e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c9d6cce2fabfe6381599fe9f3914e2">&#9670;&nbsp;</a></span>reserved0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t amd_kernel_code_s::reserved0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserved. Must be 0. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00558">558</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="a44f604ec796b7b3c6a711f2cbf235d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f604ec796b7b3c6a711f2cbf235d6c">&#9670;&nbsp;</a></span>reserved3</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t amd_kernel_code_s::reserved3[12]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00650">650</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="ab08abdcbd560da11ea18952a8addd07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08abdcbd560da11ea18952a8addd07c">&#9670;&nbsp;</a></span>reserved_sgpr_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::reserved_sgpr_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of consecutive SGPRs reserved by the client. </p>
<p>If is_debug_supported then this count includes SGPRs reserved for debugger use. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00621">621</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="ab3ded9dece15b44ade5de4f64617bbc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ded9dece15b44ade5de4f64617bbc1">&#9670;&nbsp;</a></span>reserved_sgpr_first</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::reserved_sgpr_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If reserved_sgpr_count is 0 then must be 0. </p>
<p>Otherwise, this is the first fixed SGPR number reserved. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00616">616</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="a6757964e0e2e4a2f85ea0d3aef282668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6757964e0e2e4a2f85ea0d3aef282668">&#9670;&nbsp;</a></span>reserved_vgpr_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::reserved_vgpr_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of consecutive VGPRs reserved by the client. </p>
<p>If is_debug_supported then this count includes VGPRs reserved for debugger use. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00612">612</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="a110a82e27c4c538dd9265a897043f666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110a82e27c4c538dd9265a897043f666">&#9670;&nbsp;</a></span>reserved_vgpr_first</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::reserved_vgpr_first</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If reserved_vgpr_count is 0 then must be 0. </p>
<p>Otherwise, this is the first fixed VGPR number reserved. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00607">607</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="af4388bf1729c7913f4bcca568c2d8d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4388bf1729c7913f4bcca568c2d8d02">&#9670;&nbsp;</a></span>runtime_loader_kernel_symbol</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t amd_kernel_code_s::runtime_loader_kernel_symbol</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00651">651</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="ab8ca3407b13af2f0d9a9c80ce582c37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ca3407b13af2f0d9a9c80ce582c37b">&#9670;&nbsp;</a></span>wavefront_sgpr_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::wavefront_sgpr_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of scalar registers used by a wavefront. </p>
<p>This includes the special SGPRs for VCC, Flat Scratch Base, Flat Scratch Size and XNACK (for GFX8 (VI)). It does not include the 16 SGPR added if a trap handler is enabled. Used to set COMPUTE_PGM_RSRC1.SGPRS. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00599">599</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUAsmPrinter_8cpp_source.html#l01208">getElementByteSizeValue()</a>.</p>

</div>
</div>
<a id="ab1e1a521e8178224bf3e065bbccbd94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e1a521e8178224bf3e065bbccbd94d">&#9670;&nbsp;</a></span>wavefront_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t amd_kernel_code_s::wavefront_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wavefront size expressed as a power of two. </p>
<p>Must be a power of 2 in range 1..64 inclusive. Used to support runtime query that obtains wavefront size, which may be used by application to allocated dynamic group memory and set the dispatch work-group size. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00647">647</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUBaseInfo_8cpp_source.html#l00482">llvm::AMDGPU::initDefaultAMDKernelCodeT()</a>.</p>

</div>
</div>
<a id="a0fd3b0027b18bfb68447eff86ae369de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd3b0027b18bfb68447eff86ae369de">&#9670;&nbsp;</a></span>workgroup_fbarrier_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint32__t.html">uint32_t</a> amd_kernel_code_s::workgroup_fbarrier_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of fbarrier's used in the kernel and all functions it calls. </p>
<p>If the implementation uses group memory to allocate the fbarriers then that amount must already be included in the workgroup_group_segment_byte_size total. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00593">593</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

</div>
</div>
<a id="a76d1342950ad5679cb75e5a551583961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76d1342950ad5679cb75e5a551583961">&#9670;&nbsp;</a></span>workgroup_group_segment_byte_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint32__t.html">uint32_t</a> amd_kernel_code_s::workgroup_group_segment_byte_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The amount of group segment memory required by a work-group in bytes. </p>
<p>This does not include any dynamically allocated group segment memory that may be added when the kernel is dispatched. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00578">578</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUAsmPrinter_8cpp_source.html#l01208">getElementByteSizeValue()</a>.</p>

</div>
</div>
<a id="a4df57402a4d6bce6adc008a2c2703630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df57402a4d6bce6adc008a2c2703630">&#9670;&nbsp;</a></span>workitem_private_segment_byte_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint32__t.html">uint32_t</a> amd_kernel_code_s::workitem_private_segment_byte_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The amount of memory required for the combined private, spill and arg segments for a work-item in bytes. </p>
<p>If is_dynamic_callstack is 1 then additional space must be added to this value for the call stack. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00572">572</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUAsmPrinter_8cpp_source.html#l01208">getElementByteSizeValue()</a>.</p>

</div>
</div>
<a id="ad6400e51805c0d3e6658f51e0f4b1258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6400e51805c0d3e6658f51e0f4b1258">&#9670;&nbsp;</a></span>workitem_vgpr_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classuint16__t.html">uint16_t</a> amd_kernel_code_s::workitem_vgpr_count</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of vector registers used by each work-item. </p>
<p>Used to set COMPUTE_PGM_RSRC1.VGPRS. </p>

<p class="definition">Definition at line <a class="el" href="AMDKernelCodeT_8h_source.html#l00603">603</a> of file <a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AMDGPUAsmPrinter_8cpp_source.html#l01208">getElementByteSizeValue()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lib/Target/AMDGPU/<a class="el" href="AMDKernelCodeT_8h_source.html">AMDKernelCodeT.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 24 2020 13:16:05 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
