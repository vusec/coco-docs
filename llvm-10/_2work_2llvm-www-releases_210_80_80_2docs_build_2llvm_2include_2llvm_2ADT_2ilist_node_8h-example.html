<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: /work/llvm-www-releases/10.0.0/docs_build/llvm/include/llvm/ADT/ilist_node.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">/work/llvm-www-releases/10.0.0/docs_build/llvm/include/llvm/ADT/ilist_node.h</div>  </div>
</div><!--header-->
<div class="contents">
<p>An intrusive list node.A base class to enable membership in intrusive lists, including <em>simple_ilist</em>, <em>iplist</em>, and <em>ilist</em>. The first template parameter is the <em>value_type</em> for the list.</p>
<p>An ilist node can be configured with compile-time options to change behaviour and/or add API.</p>
<p>By default, an <em>ilist_node</em> knows whether it is the list sentinel (an instance of <em>ilist_sentinel</em>) if and only if LLVM_ENABLE_ABI_BREAKING_CHECKS. The function <em>isKnownSentinel()</em> always returns <code>false</code> tracking is off. Sentinel tracking steals a bit from the "prev" link, which adds a mask operation when decrementing an iterator, but enables bug-finding assertions in <em>ilist_iterator</em>.</p>
<p>To turn sentinel tracking on all the time, pass in the ilist_sentinel_tracking&lt;true&gt; template parameter. This also enables the <em><a class="el" href="DWARFAcceleratorTable_8cpp.html#a1aed031578039adc6374053233f53d6f">isSentinel()</a></em> function. The same option must be passed to the intrusive list. (ilist_sentinel_tracking&lt;false&gt; turns sentinel tracking off all the time.)</p>
<p>A type can inherit from ilist_node multiple times by passing in different <em>ilist_tag</em> options. This allows a single instance to be inserted into multiple lists simultaneously, where each list is given the same tag.</p>
<p>struct A {}; struct B {}; struct N : ilist_node&lt;N, ilist_tag&gt;, ilist_node&lt;N, ilist_tag<b>&gt; {};</b></p>
<p><b>void foo() { simple_ilist&lt;N, ilist_tag&gt; ListA; simple_ilist&lt;N, ilist_tag<b>&gt; ListB; N N1; ListA.push_back(N1); ListB.push_back(N1); } </b></b></p>
<p><b><b>See <em>is_valid_option</em> for steps on adding a new option.</b></b></p>
<p><b><b></p><div class="fragment"><div class="line"><span class="comment">//===- llvm/ADT/ilist_node.h - Intrusive Linked List Helper -----*- C++ -*-===//</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.</span></div><div class="line"><span class="comment">// See https://llvm.org/LICENSE.txt for license information.</span></div><div class="line"><span class="comment">// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// This file defines the ilist_node class template, which is a convenient</span></div><div class="line"><span class="comment">// base class for creating classes that can be used with ilists.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifndef LLVM_ADT_ILIST_NODE_H</span></div><div class="line"><span class="preprocessor">#define LLVM_ADT_ILIST_NODE_H</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ilist__node__base_8h.html">llvm/ADT/ilist_node_base.h</a>&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ilist__node__options_8h.html">llvm/ADT/ilist_node_options.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">namespace </span><a class="code" href="namespacellvm.html">llvm</a> {</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ilist_detail {</div><div class="line"></div><div class="line"><span class="keyword">struct </span>NodeAccess;</div><div class="line"></div><div class="line">} <span class="comment">// end namespace ilist_detail</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT, <span class="keywordtype">bool</span> IsReverse, <span class="keywordtype">bool</span> IsConst&gt; <span class="keyword">class </span>ilist_iterator;</div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt; <span class="keyword">class </span>ilist_sentinel;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/// Implementation for an ilist node.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// Templated on an appropriate \a ilist_detail::node_options, usually computed</span></div><div class="line"><span class="comment">/// by \a ilist_detail::compute_node_options.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// This is a wrapper around \a ilist_node_base whose main purpose is to</span></div><div class="line"><span class="comment">/// provide type safety: you can&#39;t insert nodes of \a ilist_node_impl into the</span></div><div class="line"><span class="comment">/// wrong \a simple_ilist or \a iplist.</span></div><div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt; <span class="keyword">class </span>ilist_node_impl : OptionsT::node_base_type {</div><div class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> OptionsT::value_type;</div><div class="line">  <span class="keyword">using</span> node_base_type = <span class="keyword">typename</span> OptionsT::node_base_type;</div><div class="line">  <span class="keyword">using</span> list_base_type = <span class="keyword">typename</span> OptionsT::list_base_type;</div><div class="line"></div><div class="line">  <span class="keyword">friend</span> <span class="keyword">typename</span> OptionsT::list_base_type;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">struct </span>ilist_detail::NodeAccess;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>ilist_sentinel&lt;OptionsT&gt;;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>ilist_iterator&lt;OptionsT, false, false&gt;;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>ilist_iterator&lt;OptionsT, false, true&gt;;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>ilist_iterator&lt;OptionsT, true, false&gt;;</div><div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>ilist_iterator&lt;OptionsT, true, true&gt;;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">using</span> self_iterator = ilist_iterator&lt;OptionsT, false, false&gt;;</div><div class="line">  <span class="keyword">using</span> const_self_iterator = ilist_iterator&lt;OptionsT, false, true&gt;;</div><div class="line">  <span class="keyword">using</span> reverse_self_iterator = ilist_iterator&lt;OptionsT, true, false&gt;;</div><div class="line">  <span class="keyword">using</span> const_reverse_self_iterator = ilist_iterator&lt;OptionsT, true, true&gt;;</div><div class="line"></div><div class="line">  ilist_node_impl() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">  ilist_node_impl *getPrev() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>ilist_node_impl *<span class="keyword">&gt;</span>(node_base_type::getPrev());</div><div class="line">  }</div><div class="line"></div><div class="line">  ilist_node_impl *getNext() {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>ilist_node_impl *<span class="keyword">&gt;</span>(node_base_type::getNext());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ilist_node_impl *getPrev()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>ilist_node_impl *<span class="keyword">&gt;</span>(node_base_type::getPrev());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">const</span> ilist_node_impl *getNext()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>ilist_node_impl *<span class="keyword">&gt;</span>(node_base_type::getNext());</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> setPrev(ilist_node_impl *<a name="a0"></a><a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>) { node_base_type::setPrev(N); }</div><div class="line">  <span class="keywordtype">void</span> setNext(ilist_node_impl *N) { node_base_type::setNext(N); }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  self_iterator getIterator() { <span class="keywordflow">return</span> self_iterator(*<span class="keyword">this</span>); }</div><div class="line">  const_self_iterator getIterator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_self_iterator(*<span class="keyword">this</span>); }</div><div class="line"></div><div class="line">  reverse_self_iterator getReverseIterator() {</div><div class="line">    <span class="keywordflow">return</span> reverse_self_iterator(*<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  const_reverse_self_iterator getReverseIterator()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> const_reverse_self_iterator(*<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Under-approximation, but always available for assertions.</span></div><div class="line">  <span class="keyword">using</span> node_base_type::isKnownSentinel;</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /// Check whether this is the sentinel node.</span></div><div class="line"><span class="comment">  ///</span></div><div class="line"><span class="comment">  /// This requires sentinel tracking to be explicitly enabled.  Use the</span></div><div class="line"><span class="comment">  /// ilist_sentinel_tracking&lt;true&gt; option to get this API.</span></div><div class="line"><span class="comment"></span>  <span class="keywordtype">bool</span> <a name="a1"></a><a class="code" href="DWARFAcceleratorTable_8cpp.html#a1aed031578039adc6374053233f53d6f">isSentinel</a>()<span class="keyword"> const </span>{</div><div class="line">    static_assert(OptionsT::is_sentinel_tracking_explicit,</div><div class="line">                  <span class="stringliteral">&quot;Use ilist_sentinel_tracking&lt;true&gt; to enable isSentinel()&quot;</span>);</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="DWARFAcceleratorTable_8cpp.html#a1aed031578039adc6374053233f53d6f">node_base_type::isSentinel</a>();</div><div class="line">  }</div><div class="line">};</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/// An intrusive list node.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// A base class to enable membership in intrusive lists, including \a</span></div><div class="line"><span class="comment">/// simple_ilist, \a iplist, and \a ilist.  The first template parameter is the</span></div><div class="line"><span class="comment">/// \a value_type for the list.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// An ilist node can be configured with compile-time options to change</span></div><div class="line"><span class="comment">/// behaviour and/or add API.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// By default, an \a ilist_node knows whether it is the list sentinel (an</span></div><div class="line"><span class="comment">/// instance of \a ilist_sentinel) if and only if</span></div><div class="line"><span class="comment">/// LLVM_ENABLE_ABI_BREAKING_CHECKS.  The function \a isKnownSentinel() always</span></div><div class="line"><span class="comment">/// returns \c false tracking is off.  Sentinel tracking steals a bit from the</span></div><div class="line"><span class="comment">/// &quot;prev&quot; link, which adds a mask operation when decrementing an iterator, but</span></div><div class="line"><span class="comment">/// enables bug-finding assertions in \a ilist_iterator.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// To turn sentinel tracking on all the time, pass in the</span></div><div class="line"><span class="comment">/// ilist_sentinel_tracking&lt;true&gt; template parameter.  This also enables the \a</span></div><div class="line"><span class="comment">/// isSentinel() function.  The same option must be passed to the intrusive</span></div><div class="line"><span class="comment">/// list.  (ilist_sentinel_tracking&lt;false&gt; turns sentinel tracking off all the</span></div><div class="line"><span class="comment">/// time.)</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// A type can inherit from ilist_node multiple times by passing in different</span></div><div class="line"><span class="comment">/// \a ilist_tag options.  This allows a single instance to be inserted into</span></div><div class="line"><span class="comment">/// multiple lists simultaneously, where each list is given the same tag.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// \example</span></div><div class="line"><span class="comment">/// struct A {};</span></div><div class="line"><span class="comment">/// struct B {};</span></div><div class="line"><span class="comment">/// struct N : ilist_node&lt;N, ilist_tag&lt;A&gt;&gt;, ilist_node&lt;N, ilist_tag&lt;B&gt;&gt; {};</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// void foo() {</span></div><div class="line"><span class="comment">///   simple_ilist&lt;N, ilist_tag&lt;A&gt;&gt; ListA;</span></div><div class="line"><span class="comment">///   simple_ilist&lt;N, ilist_tag&lt;B&gt;&gt; ListB;</span></div><div class="line"><span class="comment">///   N N1;</span></div><div class="line"><span class="comment">///   ListA.push_back(N1);</span></div><div class="line"><span class="comment">///   ListB.push_back(N1);</span></div><div class="line"><span class="comment">/// }</span></div><div class="line"><span class="comment">/// \endexample</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// See \a is_valid_option for steps on adding a new option.</span></div><div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">class </span><a name="a2"></a><a class="code" href="namespacellvm.html#aa85ac650785a53f42a7c2be9b789e21aaec7f5618992caf43bed4d97c7ff6f165">T</a>, <span class="keyword">class</span>... Options&gt;</div><div class="line"><span class="keyword">class </span>ilist_node</div><div class="line">    : <span class="keyword">public</span> ilist_node_impl&lt;</div><div class="line">          typename ilist_detail::compute_node_options&lt;T, Options...&gt;::type&gt; {</div><div class="line">  static_assert(ilist_detail::check_options&lt;Options...&gt;::value,</div><div class="line">                <span class="stringliteral">&quot;Unrecognized node option!&quot;</span>);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">namespace </span>ilist_detail {</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/// An access class for ilist_node private API.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// This gives access to the private parts of ilist nodes.  Nodes for an ilist</span></div><div class="line"><span class="comment">/// should friend this class if they inherit privately from ilist_node.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// Using this class outside of the ilist implementation is unsupported.</span></div><div class="line"><span class="comment"></span><span class="keyword">struct </span>NodeAccess {</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt;</div><div class="line">  <span class="keyword">static</span> ilist_node_impl&lt;OptionsT&gt; *getNodePtr(<span class="keyword">typename</span> OptionsT::pointer <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ilist_node_impl&lt;OptionsT&gt; *</div><div class="line">  getNodePtr(<span class="keyword">typename</span> OptionsT::const_pointer N) {</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>;</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">typename</span> OptionsT::pointer getValuePtr(ilist_node_impl&lt;OptionsT&gt; *N) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>typename OptionsT::pointer<span class="keyword">&gt;</span>(<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">typename</span> OptionsT::const_pointer</div><div class="line">  getValuePtr(<span class="keyword">const</span> ilist_node_impl&lt;OptionsT&gt; *N) {</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>typename OptionsT::const_pointer<span class="keyword">&gt;</span>(<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt;</div><div class="line">  <span class="keyword">static</span> ilist_node_impl&lt;OptionsT&gt; *getPrev(ilist_node_impl&lt;OptionsT&gt; &amp;N) {</div><div class="line">    <span class="keywordflow">return</span> N.getPrev();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt;</div><div class="line">  <span class="keyword">static</span> ilist_node_impl&lt;OptionsT&gt; *getNext(ilist_node_impl&lt;OptionsT&gt; &amp;N) {</div><div class="line">    <span class="keywordflow">return</span> N.getNext();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ilist_node_impl&lt;OptionsT&gt; *</div><div class="line">  getPrev(<span class="keyword">const</span> ilist_node_impl&lt;OptionsT&gt; &amp;N) {</div><div class="line">    <span class="keywordflow">return</span> N.getPrev();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> ilist_node_impl&lt;OptionsT&gt; *</div><div class="line">  getNext(<span class="keyword">const</span> ilist_node_impl&lt;OptionsT&gt; &amp;N) {</div><div class="line">    <span class="keywordflow">return</span> N.getNext();</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt; <span class="keyword">struct </span>SpecificNodeAccess : NodeAccess {</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">using</span> pointer = <span class="keyword">typename</span> OptionsT::pointer;</div><div class="line">  <span class="keyword">using</span> const_pointer = <span class="keyword">typename</span> OptionsT::const_pointer;</div><div class="line">  <span class="keyword">using</span> node_type = ilist_node_impl&lt;OptionsT&gt;;</div><div class="line"></div><div class="line">  <span class="keyword">static</span> node_type *getNodePtr(pointer <a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>) {</div><div class="line">    <span class="keywordflow">return</span> NodeAccess::getNodePtr&lt;OptionsT&gt;(<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> node_type *getNodePtr(const_pointer N) {</div><div class="line">    <span class="keywordflow">return</span> NodeAccess::getNodePtr&lt;OptionsT&gt;(<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">static</span> pointer getValuePtr(node_type *N) {</div><div class="line">    <span class="keywordflow">return</span> NodeAccess::getValuePtr&lt;OptionsT&gt;(<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keyword">static</span> const_pointer getValuePtr(<span class="keyword">const</span> node_type *N) {</div><div class="line">    <span class="keywordflow">return</span> NodeAccess::getValuePtr&lt;OptionsT&gt;(<a class="code" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>);</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line">} <span class="comment">// end namespace ilist_detail</span></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> OptionsT&gt;</div><div class="line"><span class="keyword">class </span>ilist_sentinel : <span class="keyword">public</span> ilist_node_impl&lt;OptionsT&gt; {</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ilist_sentinel() {</div><div class="line">    this-&gt;initializeSentinel();</div><div class="line">    reset();</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> reset() {</div><div class="line">    this-&gt;setPrev(<span class="keyword">this</span>);</div><div class="line">    this-&gt;setNext(<span class="keyword">this</span>);</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordtype">bool</span> <a name="a3"></a><a class="code" href="namespacellvm.html#a824f3e0d9eb261d9345fcc96b36852f5">empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">this</span> == this-&gt;getPrev(); }</div><div class="line">};</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/// An ilist node that can access its parent list.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">/// Requires \c NodeTy to have \a getParent() to find the parent node, and the</span></div><div class="line"><span class="comment">/// \c ParentTy to have \a getSublistAccess() to get a reference to the list.</span></div><div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodeTy, <span class="keyword">typename</span> ParentTy, <span class="keyword">class</span>... Options&gt;</div><div class="line"><span class="keyword">class </span>ilist_node_with_parent : <span class="keyword">public</span> ilist_node&lt;NodeTy, Options...&gt; {</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  ilist_node_with_parent() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:<span class="comment"></span></div><div class="line"><span class="comment">  /// Forward to NodeTy::getParent().</span></div><div class="line"><span class="comment">  ///</span></div><div class="line"><span class="comment">  /// Note: do not use the name &quot;getParent()&quot;.  We want a compile error</span></div><div class="line"><span class="comment">  /// (instead of recursion) when the subclass fails to implement \a</span></div><div class="line"><span class="comment">  /// getParent().</span></div><div class="line"><span class="comment"></span>  <span class="keyword">const</span> ParentTy *getNodeParent()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>NodeTy *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;<a name="a4"></a><a class="code" href="BasicAliasAnalysis_8cpp.html#a2675de1d8479c7b00387979714da43f7">getParent</a>();</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">public</span>:<span class="comment"></span></div><div class="line"><span class="comment">  /// @name Adjacent Node Accessors</span></div><div class="line"><span class="comment">  /// @{</span></div><div class="line"><span class="comment">  /// Get the previous node, or \c nullptr for the list head.</span></div><div class="line"><span class="comment"></span>  NodeTy *getPrevNode() {</div><div class="line">    <span class="comment">// Should be separated to a reused function, but then we couldn&#39;t use auto</span></div><div class="line">    <span class="comment">// (and would need the type of the list).</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a name="a5"></a><a class="code" href="RDFGraph_8cpp.html#a361dad1df3e6d9b5610d40dcf49204c5">List</a> =</div><div class="line">        getNodeParent()-&gt;*(ParentTy::getSublistAccess((NodeTy *)<span class="keyword">nullptr</span>));</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="RDFGraph_8cpp.html#a361dad1df3e6d9b5610d40dcf49204c5">List</a>.getPrevNode(*static_cast&lt;NodeTy *&gt;(<span class="keyword">this</span>));</div><div class="line">  }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /// Get the previous node, or \c nullptr for the list head.</span></div><div class="line"><span class="comment"></span>  <span class="keyword">const</span> NodeTy *getPrevNode()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>ilist_node_with_parent *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;getPrevNode();</div><div class="line">  }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /// Get the next node, or \c nullptr for the list tail.</span></div><div class="line"><span class="comment"></span>  NodeTy *getNextNode() {</div><div class="line">    <span class="comment">// Should be separated to a reused function, but then we couldn&#39;t use auto</span></div><div class="line">    <span class="comment">// (and would need the type of the list).</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;<a class="code" href="RDFGraph_8cpp.html#a361dad1df3e6d9b5610d40dcf49204c5">List</a> =</div><div class="line">        getNodeParent()-&gt;*(ParentTy::getSublistAccess((NodeTy *)<span class="keyword">nullptr</span>));</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="RDFGraph_8cpp.html#a361dad1df3e6d9b5610d40dcf49204c5">List</a>.getNextNode(*static_cast&lt;NodeTy *&gt;(<span class="keyword">this</span>));</div><div class="line">  }</div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">  /// Get the next node, or \c nullptr for the list tail.</span></div><div class="line"><span class="comment"></span>  <span class="keyword">const</span> NodeTy *getNextNode()<span class="keyword"> const </span>{</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">const_cast&lt;</span>ilist_node_with_parent *<span class="keyword">&gt;</span>(<span class="keyword">this</span>)-&gt;getNextNode();</div><div class="line">  }<span class="comment"></span></div><div class="line"><span class="comment">  /// @}</span></div><div class="line"><span class="comment"></span>};</div><div class="line"></div><div class="line">} <span class="comment">// end namespace llvm</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif // LLVM_ADT_ILIST_NODE_H</span></div></div><!-- fragment --><p> </b></b></p>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 24 2020 13:07:13 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
