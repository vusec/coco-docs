<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::CallingConv Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="namespacellvm_1_1CallingConv.html">CallingConv</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">llvm::CallingConv Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="namespacellvm_1_1CallingConv.html" title="CallingConv Namespace - This namespace contains an enum with a value for the well-known calling conve...">CallingConv</a> Namespace - This namespace contains an enum with a value for the well-known calling conventions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a188c0836f8c3528401f1c236fd93b977"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacellvm_1_1CallingConv.html#a188c0836f8c3528401f1c236fd93b977">ID</a> = <a class="el" href="classunsigned.html">unsigned</a></td></tr>
<tr class="memdesc:a188c0836f8c3528401f1c236fd93b977"><td class="mdescLeft">&#160;</td><td class="mdescRight">LLVM IR allows to use arbitrary numbers as calling convention identifiers.  <a href="#a188c0836f8c3528401f1c236fd93b977">More...</a><br /></td></tr>
<tr class="separator:a188c0836f8c3528401f1c236fd93b977"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a26805f452dc4cd6aaf1bfdfdf42ae794"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794afd841a49aec1539bc88abc8ff9e170fb">C</a> = 0, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794abc8e2ee40a84687a9e12fd08784b87ba">Fast</a> = 8, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a94ec9273479164e4aec1d5d91b71dc85">Cold</a> = 9, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a8e8dc64aad833bd23d07d3384522575e">GHC</a> = 10, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a20ddc463f96d806f369d56205ea205f5">HiPE</a> = 11, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794ab487fd09daadd147e37c966c5ba6cdb2">WebKit_JS</a> = 12, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a4f42667edde6e9cb80cfae6361e5e76a">AnyReg</a> = 13, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a4eeb29fe27dc20afa4f443765f45f9a5">PreserveMost</a> = 14, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a9f6ac05d37c2fbf197de42295c23fd6e">PreserveAll</a> = 15, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a2740493172a4ce246941c8cff95e0f83">Swift</a> = 16, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a75c7c151466ad7e041e9ed8aa4d5a4bf">CXX_FAST_TLS</a> = 17, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794ad6e9c0ff694f0fca0222e79e772b647e">Tail</a> = 18, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a3f8227288993442d6f4a0bb234c9bc5b">CFGuard_Check</a> = 19, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794aa901d0f0329620dac86bcfc42f5bfa7e">FirstTargetCC</a> = 64, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794aa88ccf4313b5bc700dec76fd9bc5d40e">X86_StdCall</a> = 64, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794afde87569738f9e23963e8735f71c33eb">X86_FastCall</a> = 65, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a39e4f9a6d108588930a09d779d4e812f">ARM_APCS</a> = 66, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a6460922e7050fc0dcff22631e4bc7fdb">ARM_AAPCS</a> = 67, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794af5725080d76d25fff371be12a0bf29f4">ARM_AAPCS_VFP</a> = 68, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794ac6355efbcea63774ceca1dfa7b237d42">MSP430_INTR</a> = 69, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a97109ccd68cac64fb38dbd24fc4589c6">X86_ThisCall</a> = 70, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794ae60325da71f0576e18cc0e5dd7e8afb6">PTX_Kernel</a> = 71, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a9b03ea185599539f24eb1f467627c111">PTX_Device</a> = 72, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794aacadec9c4ef27d184bcbbea409afebb2">SPIR_FUNC</a> = 75, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a9b5e79699935bf721647d44339701860">SPIR_KERNEL</a> = 76, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794ad47327c131a0990283111588b89587cb">Intel_OCL_BI</a> = 77, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a10f11fb587acddab17f3ad85eb698fbe">X86_64_SysV</a> = 78, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794ae41511c1ad4197da36cef403f34bac72">Win64</a> = 79, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794acfa4cc9bcdaefd5e969c258c994052b9">X86_VectorCall</a> = 80, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a677b6c9fba9d8d5be1c68898be10030a">HHVM</a> = 81, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a461464c63965f420d18c3caea46e4ff2">HHVM_C</a> = 82, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a765508a953368531a7d69d1279e6cfb1">X86_INTR</a> = 83, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a44deee0b3babbda0be6f27856afaacf9">AVR_INTR</a> = 84, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a1e000300c2d50f08aa18761448d5860e">AVR_SIGNAL</a> = 85, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a8ddc8eecc1584438b45d1d45fc8b87ae">AVR_BUILTIN</a> = 86, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a1a9f243b16678fc294567b72bbe87223">AMDGPU_VS</a> = 87, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a6f08d1631b96043fe0201973d84e5539">AMDGPU_GS</a> = 88, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a91283117ce67ebdae50cc7730694d8f8">AMDGPU_PS</a> = 89, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a16c3e679fa61136bfeb3c5c9b7542d9f">AMDGPU_CS</a> = 90, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a27a385675142c462571165c839e41aa0">AMDGPU_KERNEL</a> = 91, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794afab01b07b85e043c71ad4e2715d22073">X86_RegCall</a> = 92, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a5c0f66e45afd7c51f4ee51552d8fb606">AMDGPU_HS</a> = 93, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a1be5f33158d1f92c70edc260fdd7fc3c">MSP430_BUILTIN</a> = 94, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794af2c5be679d7769a9f3e5e308f73a9ff8">AMDGPU_LS</a> = 95, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794ad61318e853e529ac703f52a853efa1d1">AMDGPU_ES</a> = 96, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a0e62ecb2c693281fafd77f39b2ddd284">AArch64_VectorCall</a> = 97, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a300efd85d130657d0d06f0469980bd0f">AArch64_SVE_VectorCall</a> = 98, 
<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a7f1f535012fdeda3c9f35f2079b919a7">WASM_EmscriptenInvoke</a> = 99, 
<br />
&#160;&#160;<a class="el" href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794a2f101663d054cffa9c9956f30e7ecf7d">MaxID</a> = 1023
<br />
 }<tr class="memdesc:a26805f452dc4cd6aaf1bfdfdf42ae794"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of enums which specify the assigned numeric values for known llvm calling conventions.  <a href="namespacellvm_1_1CallingConv.html#a26805f452dc4cd6aaf1bfdfdf42ae794">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a26805f452dc4cd6aaf1bfdfdf42ae794"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="namespacellvm_1_1CallingConv.html" title="CallingConv Namespace - This namespace contains an enum with a value for the well-known calling conve...">CallingConv</a> Namespace - This namespace contains an enum with a value for the well-known calling conventions. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a188c0836f8c3528401f1c236fd93b977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188c0836f8c3528401f1c236fd93b977">&#9670;&nbsp;</a></span>ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacellvm_1_1CallingConv.html#a188c0836f8c3528401f1c236fd93b977">llvm::CallingConv::ID</a> = typedef <a class="el" href="classunsigned.html">unsigned</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LLVM IR allows to use arbitrary numbers as calling convention identifiers. </p>

<p class="definition">Definition at line <a class="el" href="CallingConv_8h_source.html#l00024">24</a> of file <a class="el" href="CallingConv_8h_source.html">CallingConv.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a26805f452dc4cd6aaf1bfdfdf42ae794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26805f452dc4cd6aaf1bfdfdf42ae794">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A set of enums which specify the assigned numeric values for known llvm calling conventions. </p>
<p>LLVM Calling Convention Representation </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794afd841a49aec1539bc88abc8ff9e170fb"></a>C&#160;</td><td class="fielddoc"><p>C - The default llvm calling convention, compatible with C. </p>
<p>This convention is the only calling convention that supports varargs calls. As with typical C calling conventions, the callee/caller have to tolerate certain amounts of prototype mismatch. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794abc8e2ee40a84687a9e12fd08784b87ba"></a>Fast&#160;</td><td class="fielddoc"><p>Fast - This calling convention attempts to make calls as fast as possible (e.g. </p>
<p>by passing things in registers). </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a94ec9273479164e4aec1d5d91b71dc85"></a>Cold&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a8e8dc64aad833bd23d07d3384522575e"></a>GHC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a20ddc463f96d806f369d56205ea205f5"></a>HiPE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794ab487fd09daadd147e37c966c5ba6cdb2"></a>WebKit_JS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a4f42667edde6e9cb80cfae6361e5e76a"></a>AnyReg&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a4eeb29fe27dc20afa4f443765f45f9a5"></a>PreserveMost&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a9f6ac05d37c2fbf197de42295c23fd6e"></a>PreserveAll&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a2740493172a4ce246941c8cff95e0f83"></a>Swift&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a75c7c151466ad7e041e9ed8aa4d5a4bf"></a>CXX_FAST_TLS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794ad6e9c0ff694f0fca0222e79e772b647e"></a>Tail&#160;</td><td class="fielddoc"><p>Tail - This calling convention attemps to make calls as fast as possible while guaranteeing that tail call optimization can always be performed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a3f8227288993442d6f4a0bb234c9bc5b"></a>CFGuard_Check&#160;</td><td class="fielddoc"><p>Special calling convention on Windows for calling the Control Guard <a class="el" href="namespacellvm_1_1Check.html">Check</a> ICall funtion. </p>
<p>The function takes exactly one argument (address of the target function) passed in the first argument register, and has no return value. All register values are preserved. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794aa901d0f0329620dac86bcfc42f5bfa7e"></a>FirstTargetCC&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794aa88ccf4313b5bc700dec76fd9bc5d40e"></a>X86_StdCall&#160;</td><td class="fielddoc"><p>X86_StdCall - stdcall is the calling conventions mostly used by the Win32 API. </p>
<p>It is basically the same as the C convention with the difference in that the callee is responsible for popping the arguments from the stack. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794afde87569738f9e23963e8735f71c33eb"></a>X86_FastCall&#160;</td><td class="fielddoc"><p>X86_FastCall - 'fast' analog of X86_StdCall. </p>
<p>Passes first two arguments in ECX:EDX registers, others - via stack. Callee is responsible for stack cleaning. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a39e4f9a6d108588930a09d779d4e812f"></a>ARM_APCS&#160;</td><td class="fielddoc"><p>ARM_APCS - <a class="el" href="namespacellvm_1_1ARM.html" title="Define some predicates that are used for node matching. ">ARM</a> Procedure Calling Standard calling convention (obsolete, but still used on some targets). </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a6460922e7050fc0dcff22631e4bc7fdb"></a>ARM_AAPCS&#160;</td><td class="fielddoc"><p>ARM_AAPCS - <a class="el" href="namespacellvm_1_1ARM.html" title="Define some predicates that are used for node matching. ">ARM</a> Architecture Procedure Calling Standard calling convention (aka EABI). </p>
<p>Soft float variant. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794af5725080d76d25fff371be12a0bf29f4"></a>ARM_AAPCS_VFP&#160;</td><td class="fielddoc"><p>ARM_AAPCS_VFP - Same as ARM_AAPCS, but uses hard floating point ABI. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794ac6355efbcea63774ceca1dfa7b237d42"></a>MSP430_INTR&#160;</td><td class="fielddoc"><p>MSP430_INTR - Calling convention used for <a class="el" href="namespacellvm_1_1MSP430.html">MSP430</a> interrupt routines. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a97109ccd68cac64fb38dbd24fc4589c6"></a>X86_ThisCall&#160;</td><td class="fielddoc"><p>X86_ThisCall - Similar to X86_StdCall. </p>
<p>Passes first argument in ECX, others via stack. Callee is responsible for stack cleaning. MSVC uses this by default for methods in its ABI. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794ae60325da71f0576e18cc0e5dd7e8afb6"></a>PTX_Kernel&#160;</td><td class="fielddoc"><p>PTX_Kernel - Call to a PTX kernel. </p>
<p>Passes all arguments in parameter space. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a9b03ea185599539f24eb1f467627c111"></a>PTX_Device&#160;</td><td class="fielddoc"><p>PTX_Device - Call to a PTX device function. </p>
<p>Passes all arguments in register or parameter space. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794aacadec9c4ef27d184bcbbea409afebb2"></a>SPIR_FUNC&#160;</td><td class="fielddoc"><p>SPIR_FUNC - Calling convention for SPIR non-kernel device functions. </p>
<p>No lowering or expansion of arguments. Structures are passed as a pointer to a struct with the byval attribute. Functions can only call SPIR_FUNC and SPIR_KERNEL functions. Functions can only have zero or one return values. Variable arguments are not allowed, except for printf. How arguments/return values are lowered are not specified. Functions are only visible to the devices. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a9b5e79699935bf721647d44339701860"></a>SPIR_KERNEL&#160;</td><td class="fielddoc"><p>SPIR_KERNEL - Calling convention for SPIR kernel functions. </p>
<p>Inherits the restrictions of SPIR_FUNC, except Cannot have non-void return values. Cannot have variable arguments. Can also be called by the host. Is externally visible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794ad47327c131a0990283111588b89587cb"></a>Intel_OCL_BI&#160;</td><td class="fielddoc"><p>Intel_OCL_BI - Calling conventions for Intel OpenCL built-ins. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a10f11fb587acddab17f3ad85eb698fbe"></a>X86_64_SysV&#160;</td><td class="fielddoc"><p>The C convention as specified in the x86-64 supplement to the System V ABI, used on most non-Windows systems. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794ae41511c1ad4197da36cef403f34bac72"></a>Win64&#160;</td><td class="fielddoc"><p>The C convention as implemented on Windows/x86-64 and <a class="el" href="namespacellvm_1_1AArch64.html">AArch64</a>. </p>
<p>This convention differs from the more common <code>X86_64_SysV</code> convention in a number of ways, most notably in that XMM registers used to pass arguments are shadowed by GPRs, and vice versa. On <a class="el" href="namespacellvm_1_1AArch64.html">AArch64</a>, this is identical to the normal C (AAPCS) calling convention for normal functions, but floats are passed in integer registers to variadic functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794acfa4cc9bcdaefd5e969c258c994052b9"></a>X86_VectorCall&#160;</td><td class="fielddoc"><p>MSVC calling convention that passes vectors and vector aggregates in SSE registers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a677b6c9fba9d8d5be1c68898be10030a"></a>HHVM&#160;</td><td class="fielddoc"><p>Calling convention used by HipHop Virtual Machine (HHVM) to perform calls to and from translation cache, and for calling PHP functions. </p>
<p>HHVM calling convention supports tail/sibling call elimination. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a461464c63965f420d18c3caea46e4ff2"></a>HHVM_C&#160;</td><td class="fielddoc"><p>HHVM calling convention for invoking C/C++ helpers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a765508a953368531a7d69d1279e6cfb1"></a>X86_INTR&#160;</td><td class="fielddoc"><p>X86_INTR - x86 hardware interrupt context. </p>
<p>Callee may take one or two parameters, where the 1st represents a pointer to hardware context frame and the 2nd represents hardware error code, the presence of the later depends on the interrupt vector taken. Valid for both 32- and 64-bit subtargets. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a44deee0b3babbda0be6f27856afaacf9"></a>AVR_INTR&#160;</td><td class="fielddoc"><p>Used for <a class="el" href="namespacellvm_1_1AVR.html" title="Contains the AVR backend. ">AVR</a> interrupt routines. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a1e000300c2d50f08aa18761448d5860e"></a>AVR_SIGNAL&#160;</td><td class="fielddoc"><p>Calling convention used for <a class="el" href="namespacellvm_1_1AVR.html" title="Contains the AVR backend. ">AVR</a> signal routines. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a8ddc8eecc1584438b45d1d45fc8b87ae"></a>AVR_BUILTIN&#160;</td><td class="fielddoc"><p>Calling convention used for special <a class="el" href="namespacellvm_1_1AVR.html" title="Contains the AVR backend. ">AVR</a> rtlib functions which have an "optimized" convention to preserve registers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a1a9f243b16678fc294567b72bbe87223"></a>AMDGPU_VS&#160;</td><td class="fielddoc"><p>Calling convention used for Mesa vertex shaders, or AMDPAL last shader stage before rasterization (vertex shader if tessellation and geometry are not in use, or otherwise copy shader if one is needed). </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a6f08d1631b96043fe0201973d84e5539"></a>AMDGPU_GS&#160;</td><td class="fielddoc"><p>Calling convention used for Mesa/AMDPAL geometry shaders. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a91283117ce67ebdae50cc7730694d8f8"></a>AMDGPU_PS&#160;</td><td class="fielddoc"><p>Calling convention used for Mesa/AMDPAL pixel shaders. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a16c3e679fa61136bfeb3c5c9b7542d9f"></a>AMDGPU_CS&#160;</td><td class="fielddoc"><p>Calling convention used for Mesa/AMDPAL compute shaders. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a27a385675142c462571165c839e41aa0"></a>AMDGPU_KERNEL&#160;</td><td class="fielddoc"><p>Calling convention for <a class="el" href="namespacellvm_1_1AMDGPU.html">AMDGPU</a> code object kernels. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794afab01b07b85e043c71ad4e2715d22073"></a>X86_RegCall&#160;</td><td class="fielddoc"><p><a class="el" href="classllvm_1_1Register.html" title="Wrapper class representing virtual and physical registers. ">Register</a> calling convention used for parameters transfer optimization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a5c0f66e45afd7c51f4ee51552d8fb606"></a>AMDGPU_HS&#160;</td><td class="fielddoc"><p>Calling convention used for Mesa/AMDPAL hull shaders (= tessellation control shaders). </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a1be5f33158d1f92c70edc260fdd7fc3c"></a>MSP430_BUILTIN&#160;</td><td class="fielddoc"><p>Calling convention used for special <a class="el" href="namespacellvm_1_1MSP430.html">MSP430</a> rtlib functions which have an "optimized" convention using additional registers. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794af2c5be679d7769a9f3e5e308f73a9ff8"></a>AMDGPU_LS&#160;</td><td class="fielddoc"><p>Calling convention used for AMDPAL vertex shader if tessellation is in use. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794ad61318e853e529ac703f52a853efa1d1"></a>AMDGPU_ES&#160;</td><td class="fielddoc"><p>Calling convention used for AMDPAL shader stage before geometry shader if geometry is in use. </p>
<p>So either the domain (= tessellation evaluation) shader if tessellation is in use, or otherwise the vertex shader. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a0e62ecb2c693281fafd77f39b2ddd284"></a>AArch64_VectorCall&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a300efd85d130657d0d06f0469980bd0f"></a>AArch64_SVE_VectorCall&#160;</td><td class="fielddoc"><p>Calling convention between <a class="el" href="namespacellvm_1_1AArch64.html">AArch64</a> SVE functions. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a7f1f535012fdeda3c9f35f2079b919a7"></a>WASM_EmscriptenInvoke&#160;</td><td class="fielddoc"><p>Calling convention for emscripten __invoke_* functions. </p>
<p>The first argument is required to be the function ptr being indirectly called. The remainder matches the regular calling convention. </p>
</td></tr>
<tr><td class="fieldname"><a id="a26805f452dc4cd6aaf1bfdfdf42ae794a2f101663d054cffa9c9956f30e7ecf7d"></a>MaxID&#160;</td><td class="fielddoc"><p>The highest possible calling convention ID. Must be some 2^k - 1. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="CallingConv_8h_source.html#l00029">29</a> of file <a class="el" href="CallingConv_8h_source.html">CallingConv.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 24 2020 13:23:46 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
