<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: llvm::LazyCallGraph::RefSCC Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacellvm.html">llvm</a></li><li class="navelem"><a class="el" href="classllvm_1_1LazyCallGraph.html">LazyCallGraph</a></li><li class="navelem"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classllvm_1_1LazyCallGraph_1_1RefSCC-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">llvm::LazyCallGraph::RefSCC Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> of the call graph.  
 <a href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="LazyCallGraph_8h_source.html">llvm/Analysis/LazyCallGraph.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad85b2ad566b56110886f3c39653b88fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a> = <a class="el" href="structllvm_1_1pointee__iterator.html">pointee_iterator</a>&lt; <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">SCC</a> * &gt;::<a class="el" href="classSymbolMapType_1_1const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:ad85b2ad566b56110886f3c39653b88fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b7350ecfd665c8008e5a47c6734c87"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a69b7350ecfd665c8008e5a47c6734c87">range</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a> &gt;</td></tr>
<tr class="separator:a69b7350ecfd665c8008e5a47c6734c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fca2a832bd7ade1d9fd3a611aec681"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a36fca2a832bd7ade1d9fd3a611aec681">parent_iterator</a> = <a class="el" href="structllvm_1_1pointee__iterator.html">pointee_iterator</a>&lt; <a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> * &gt;::<a class="el" href="classSymbolMapType_1_1const__iterator.html">const_iterator</a> &gt;</td></tr>
<tr class="separator:a36fca2a832bd7ade1d9fd3a611aec681"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc4aeec51553504ba50594d9fb8ac4b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#acc4aeec51553504ba50594d9fb8ac4b1">begin</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:acc4aeec51553504ba50594d9fb8ac4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbe8357e4c4fef5f9b7809b41abcdcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#acbbe8357e4c4fef5f9b7809b41abcdcd">end</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:acbbe8357e4c4fef5f9b7809b41abcdcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62cb27d2f0946c9febb1e1d1e377f55"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ac62cb27d2f0946c9febb1e1d1e377f55">size</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:ac62cb27d2f0946c9febb1e1d1e377f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc901e9b7bdc25bc9b5428c7fb0fa9f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">SCC</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#adc901e9b7bdc25bc9b5428c7fb0fa9f0">operator[]</a> (int Idx)</td></tr>
<tr class="separator:adc901e9b7bdc25bc9b5428c7fb0fa9f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f7db86dd464b937f03aab0fbf51506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a51f7db86dd464b937f03aab0fbf51506">find</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">SCC</a> &amp;<a class="el" href="NVVMIntrRange_8cpp.html#a2ae53ee71b2ccbb52b883c0b4f59f8c2">C</a>) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="separator:a51f7db86dd464b937f03aab0fbf51506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af952e1ffaf5cd4bd83b63cf7fb4cb068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#af952e1ffaf5cd4bd83b63cf7fb4cb068">isParentOf</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;RC) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:af952e1ffaf5cd4bd83b63cf7fb4cb068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> is a parent of <em>RC</em>.  <a href="#af952e1ffaf5cd4bd83b63cf7fb4cb068">More...</a><br /></td></tr>
<tr class="separator:af952e1ffaf5cd4bd83b63cf7fb4cb068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a8d25c6df3f1d3bc5faba32de1dd55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a35a8d25c6df3f1d3bc5faba32de1dd55">isAncestorOf</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;RC) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a35a8d25c6df3f1d3bc5faba32de1dd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> is an ancestor of <em>RC</em>.  <a href="#a35a8d25c6df3f1d3bc5faba32de1dd55">More...</a><br /></td></tr>
<tr class="separator:a35a8d25c6df3f1d3bc5faba32de1dd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c04e8da471c500d025dfdf206c24ed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a5c04e8da471c500d025dfdf206c24ed2">isChildOf</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;RC) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a5c04e8da471c500d025dfdf206c24ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> is a child of <em>RC</em>.  <a href="#a5c04e8da471c500d025dfdf206c24ed2">More...</a><br /></td></tr>
<tr class="separator:a5c04e8da471c500d025dfdf206c24ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f6c7fa7f420326cc1f7026e51b0668"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a59f6c7fa7f420326cc1f7026e51b0668">isDescendantOf</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;RC) <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:a59f6c7fa7f420326cc1f7026e51b0668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> is a descendant of <em>RC</em>.  <a href="#a59f6c7fa7f420326cc1f7026e51b0668">More...</a><br /></td></tr>
<tr class="separator:a59f6c7fa7f420326cc1f7026e51b0668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30dc61a31f34e7359336fa637104bfb"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ac30dc61a31f34e7359336fa637104bfb">getName</a> () <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a></td></tr>
<tr class="memdesc:ac30dc61a31f34e7359336fa637104bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a short name by printing this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> to a std::string.  <a href="#ac30dc61a31f34e7359336fa637104bfb">More...</a><br /></td></tr>
<tr class="separator:ac30dc61a31f34e7359336fa637104bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mutation API</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These methods provide the core API for updating the call graph in the presence of (potentially still in-flight) DFS-found RefSCCs and SCCs.</p>
<p>Note that these methods sometimes have complex runtimes, so be careful how you call them. </p>
</div></td></tr>
<tr class="memitem:a14961d8c765d29b4e96a0a676292ef33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a14961d8c765d29b4e96a0a676292ef33">switchInternalEdgeToCall</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN, <a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">SCC</a> *&gt; MergedSCCs)&gt; MergeCB={})</td></tr>
<tr class="memdesc:a14961d8c765d29b4e96a0a676292ef33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an existing internal ref edge into a call edge.  <a href="#a14961d8c765d29b4e96a0a676292ef33">More...</a><br /></td></tr>
<tr class="separator:a14961d8c765d29b4e96a0a676292ef33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f9bc7458beec4389ccf7fb88199d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ae2f9bc7458beec4389ccf7fb88199d4b">switchTrivialInternalEdgeToRef</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN)</td></tr>
<tr class="memdesc:ae2f9bc7458beec4389ccf7fb88199d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an existing internal call edge between separate SCCs into a ref edge.  <a href="#ae2f9bc7458beec4389ccf7fb88199d4b">More...</a><br /></td></tr>
<tr class="separator:ae2f9bc7458beec4389ccf7fb88199d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fe0cb15ded58bd1824fa4e3daec680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a96fe0cb15ded58bd1824fa4e3daec680">switchInternalEdgeToRef</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN)</td></tr>
<tr class="memdesc:a96fe0cb15ded58bd1824fa4e3daec680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an existing internal call edge within a single <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> into a ref edge.  <a href="#a96fe0cb15ded58bd1824fa4e3daec680">More...</a><br /></td></tr>
<tr class="separator:a96fe0cb15ded58bd1824fa4e3daec680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc0541c3ee15c565ac05fe11f5459d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a5cc0541c3ee15c565ac05fe11f5459d2">switchOutgoingEdgeToCall</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN)</td></tr>
<tr class="memdesc:a5cc0541c3ee15c565ac05fe11f5459d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an existing outgoing ref edge into a call edge.  <a href="#a5cc0541c3ee15c565ac05fe11f5459d2">More...</a><br /></td></tr>
<tr class="separator:a5cc0541c3ee15c565ac05fe11f5459d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce8df277d53b4d87581583c8269ac71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#adce8df277d53b4d87581583c8269ac71">switchOutgoingEdgeToRef</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN)</td></tr>
<tr class="memdesc:adce8df277d53b4d87581583c8269ac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an existing outgoing call edge into a ref edge.  <a href="#adce8df277d53b4d87581583c8269ac71">More...</a><br /></td></tr>
<tr class="separator:adce8df277d53b4d87581583c8269ac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57986c798b44affab5e4d5953e37727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#aa57986c798b44affab5e4d5953e37727">insertInternalRefEdge</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN)</td></tr>
<tr class="memdesc:aa57986c798b44affab5e4d5953e37727"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a ref edge from one node in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> to another in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>.  <a href="#aa57986c798b44affab5e4d5953e37727">More...</a><br /></td></tr>
<tr class="separator:aa57986c798b44affab5e4d5953e37727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743c2ac21f2f8a8c6af18e1e09f13229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a743c2ac21f2f8a8c6af18e1e09f13229">insertOutgoingEdge</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Edge.html#a8a5508e6c049172373b05c47c1b6fe13">Edge::Kind</a> EK)</td></tr>
<tr class="memdesc:a743c2ac21f2f8a8c6af18e1e09f13229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an edge whose parent is in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> and child is in some child <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>.  <a href="#a743c2ac21f2f8a8c6af18e1e09f13229">More...</a><br /></td></tr>
<tr class="separator:a743c2ac21f2f8a8c6af18e1e09f13229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b1581633bb40f86d6dc62a1c1a7f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> *, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a01b1581633bb40f86d6dc62a1c1a7f72">insertIncomingRefEdge</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN)</td></tr>
<tr class="memdesc:a01b1581633bb40f86d6dc62a1c1a7f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an edge whose source is in a descendant <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> and target is in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>.  <a href="#a01b1581633bb40f86d6dc62a1c1a7f72">More...</a><br /></td></tr>
<tr class="separator:a01b1581633bb40f86d6dc62a1c1a7f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab130250bcdaefbfd3c583cad7b120b62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ab130250bcdaefbfd3c583cad7b120b62">removeOutgoingEdge</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN)</td></tr>
<tr class="memdesc:ab130250bcdaefbfd3c583cad7b120b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge whose source is in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> and target is <em>not</em>.  <a href="#ab130250bcdaefbfd3c583cad7b120b62">More...</a><br /></td></tr>
<tr class="separator:ab130250bcdaefbfd3c583cad7b120b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2a2749664a36abbb8d7cbb5279afed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> *, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a0f2a2749664a36abbb8d7cbb5279afed">removeInternalRefEdge</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> *&gt; TargetNs)</td></tr>
<tr class="memdesc:a0f2a2749664a36abbb8d7cbb5279afed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a list of ref edges which are entirely within this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>.  <a href="#a0f2a2749664a36abbb8d7cbb5279afed">More...</a><br /></td></tr>
<tr class="separator:a0f2a2749664a36abbb8d7cbb5279afed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3ba7d78f09755223609e4978bebef7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#aaf3ba7d78f09755223609e4978bebef7">insertTrivialCallEdge</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN)</td></tr>
<tr class="memdesc:aaf3ba7d78f09755223609e4978bebef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper around the above to handle trivial cases of inserting a new call edge.  <a href="#aaf3ba7d78f09755223609e4978bebef7">More...</a><br /></td></tr>
<tr class="separator:aaf3ba7d78f09755223609e4978bebef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393b4565f554b9d8382c8f610b7f2ce7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a393b4565f554b9d8382c8f610b7f2ce7">insertTrivialRefEdge</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;SourceN, <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;TargetN)</td></tr>
<tr class="memdesc:a393b4565f554b9d8382c8f610b7f2ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience wrapper around the above to handle trivial cases of inserting a new ref edge.  <a href="#a393b4565f554b9d8382c8f610b7f2ce7">More...</a><br /></td></tr>
<tr class="separator:a393b4565f554b9d8382c8f610b7f2ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f7f0574edbfc0f75424499133d4ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a70f7f0574edbfc0f75424499133d4ba3">replaceNodeFunction</a> (<a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;<a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="classllvm_1_1Function.html">Function</a> &amp;NewF)</td></tr>
<tr class="memdesc:a70f7f0574edbfc0f75424499133d4ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Directly replace a node's function with a new function.  <a href="#a70f7f0574edbfc0f75424499133d4ba3">More...</a><br /></td></tr>
<tr class="separator:a70f7f0574edbfc0f75424499133d4ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a81774ea46253e6427d63a610bd624c08"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a81774ea46253e6427d63a610bd624c08">LazyCallGraph</a></td></tr>
<tr class="separator:a81774ea46253e6427d63a610bd624c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7a57d977301c68294ee8d4c92543ce"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a3a7a57d977301c68294ee8d4c92543ce">LazyCallGraph::Node</a></td></tr>
<tr class="separator:a3a7a57d977301c68294ee8d4c92543ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d79ce3fd993135886c413600302540"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a05d79ce3fd993135886c413600302540">operator&lt;&lt;</a> (<a class="el" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;OS, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;RC)</td></tr>
<tr class="memdesc:a05d79ce3fd993135886c413600302540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a short description useful for debugging or logging.  <a href="#a05d79ce3fd993135886c413600302540">More...</a><br /></td></tr>
<tr class="separator:a05d79ce3fd993135886c413600302540"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> of the call graph. </p>
<p>This models a Strongly Connected Component of function reference edges in the call graph. As opposed to actual SCCs, these can be used to scope subgraphs of the module which are independent from other subgraphs of the module because they do not reference it in any way. This is also the unit where we do mutation of the graph in order to restrict mutations to those which don't violate this independence.</p>
<p>A <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> contains a DAG of actual SCCs. All the nodes within the <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> are necessarily within some actual <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> that nests within it. Since a direct call <em>is</em> a reference, there will always be at least one <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> around any <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a>. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00547">547</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad85b2ad566b56110886f3c39653b88fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85b2ad566b56110886f3c39653b88fa">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">llvm::LazyCallGraph::RefSCC::iterator</a> =  <a class="el" href="structllvm_1_1pointee__iterator.html">pointee_iterator</a>&lt;<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt;<a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">SCC</a> *&gt;::<a class="el" href="classSymbolMapType_1_1const__iterator.html">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00614">614</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

</div>
</div>
<a id="a36fca2a832bd7ade1d9fd3a611aec681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fca2a832bd7ade1d9fd3a611aec681">&#9670;&nbsp;</a></span>parent_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a36fca2a832bd7ade1d9fd3a611aec681">llvm::LazyCallGraph::RefSCC::parent_iterator</a> =  <a class="el" href="structllvm_1_1pointee__iterator.html">pointee_iterator</a>&lt;<a class="el" href="classllvm_1_1SmallPtrSetImpl.html">SmallPtrSetImpl</a>&lt;<a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> *&gt;::<a class="el" href="classSymbolMapType_1_1const__iterator.html">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00617">617</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

</div>
</div>
<a id="a69b7350ecfd665c8008e5a47c6734c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b7350ecfd665c8008e5a47c6734c87">&#9670;&nbsp;</a></span>range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#a69b7350ecfd665c8008e5a47c6734c87">llvm::LazyCallGraph::RefSCC::range</a> =  <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00615">615</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acc4aeec51553504ba50594d9fb8ac4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4aeec51553504ba50594d9fb8ac4b1">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a> llvm::LazyCallGraph::RefSCC::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00619">619</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

<p class="reference">References <a class="el" href="SmallVector_8h_source.html#l00127">llvm::SmallVectorTemplateCommon&lt; T &gt;::begin()</a>.</p>

</div>
</div>
<a id="acbbe8357e4c4fef5f9b7809b41abcdcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbbe8357e4c4fef5f9b7809b41abcdcd">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a> llvm::LazyCallGraph::RefSCC::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00620">620</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

<p class="reference">References <a class="el" href="SmallVector_8h_source.html#l00129">llvm::SmallVectorTemplateCommon&lt; T &gt;::end()</a>.</p>

</div>
</div>
<a id="a51f7db86dd464b937f03aab0fbf51506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f7db86dd464b937f03aab0fbf51506">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">iterator</a> llvm::LazyCallGraph::RefSCC::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">SCC</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00626">626</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

<p class="reference">References <a class="el" href="SmallVector_8h_source.html#l00127">llvm::SmallVectorTemplateCommon&lt; T &gt;::begin()</a>, and <a class="el" href="DenseMap_8h_source.html#l00150">llvm::DenseMapBase&lt; SmallDenseMap&lt; KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT &gt;, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>.</p>

</div>
</div>
<a id="ac30dc61a31f34e7359336fa637104bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30dc61a31f34e7359336fa637104bfb">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string llvm::LazyCallGraph::RefSCC::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a short name by printing this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> to a std::string. </p>
<p>This copes with the fact that we don't have a name per-se for an <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> while still making the use of this in debugging and logging useful. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00662">662</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

<p class="reference">References <a class="el" href="raw__ostream_8h_source.html#l00155">llvm::raw_ostream::flush()</a>, and <a class="el" href="AMDGPULibCalls_8cpp_source.html#l00225">Name</a>.</p>

</div>
</div>
<a id="a01b1581633bb40f86d6dc62a1c1a7f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b1581633bb40f86d6dc62a1c1a7f72">&#9670;&nbsp;</a></span>insertIncomingRefEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">LazyCallGraph::RefSCC</a> *, 1 &gt; LazyCallGraph::RefSCC::insertIncomingRefEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an edge whose source is in a descendant <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> and target is in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>. </p>
<p>There must be an existing path from the target to the source in this case.</p>
<p>NB! This is has the potential to be a very expensive function. It inherently forms a cycle in the prior <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> DAG and we have to merge RefSCCs to resolve that cycle. But finding all of the RefSCCs which participate in the cycle can in the worst case require traversing every <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> in the graph. Every attempt is made to avoid that, but passes must still exercise caution calling this routine repeatedly.</p>
<p>Also note that this can only insert ref edges. In order to insert a call edge, first insert a ref edge and then switch it to a call edge. These are intentionally kept as separate interfaces because each step of the operation invalidates a different set of data structures.</p>
<p>This returns all the RefSCCs which were merged into the this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> (the target's). This allows callers to invalidate any cached information.</p>
<p>FIXME: We could possibly optimize this quite a bit for cases where the caller and callee are very nearby in the graph. See comments in the implementation for details, but that use case might impact users. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00965">965</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SmallVector_8h_source.html#l00387">llvm::SmallVectorImpl&lt; T &gt;::append()</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="iterator__range_8h_source.html#l00045">llvm::iterator_range&lt; IteratorT &gt;::begin()</a>, <a class="el" href="NVVMIntrRange_8cpp_source.html#l00068">C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, <a class="el" href="iterator__range_8h_source.html#l00046">llvm::iterator_range&lt; IteratorT &gt;::end()</a>, <a class="el" href="SmallPtrSet_8h_source.html#l00370">llvm::SmallPtrSetImpl&lt; PtrType &gt;::insert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="iterator__range_8h_source.html#l00054">llvm::make_range()</a>, <a class="el" href="ScopeExit_8h_source.html#l00058">llvm::make_scope_exit()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="SmallVector_8h_source.html#l00374">llvm::SmallVectorImpl&lt; T &gt;::pop_back_val()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T &gt;::push_back()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Ref</a>, <a class="el" href="LazyCallGraph_8cpp_source.html#l00459">updatePostorderSequenceForEdgeInsertion()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="aa57986c798b44affab5e4d5953e37727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57986c798b44affab5e4d5953e37727">&#9670;&nbsp;</a></span>insertInternalRefEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LazyCallGraph::RefSCC::insertInternalRefEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a ref edge from one node in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> to another in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>. </p>
<p>This is always a trivial operation as it doesn't change any part of the graph structure besides connecting the two nodes.</p>
<p>Note that we don't support directly inserting internal <em>call</em> edges because that could change the graph structure and requires returning information about what became invalid. As a consequence, the pattern should be to first insert the necessary ref edge, and then to switch it to a call edge if needed and handle any invalidation that results. See the <code>switchInternalEdgeToCall</code> routine for details. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00931">931</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Ref</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="a743c2ac21f2f8a8c6af18e1e09f13229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743c2ac21f2f8a8c6af18e1e09f13229">&#9670;&nbsp;</a></span>insertOutgoingEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LazyCallGraph::RefSCC::insertOutgoingEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Edge.html#a8a5508e6c049172373b05c47c1b6fe13">Edge::Kind</a>&#160;</td>
          <td class="paramname"><em>EK</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert an edge whose parent is in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> and child is in some child <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>. </p>
<p>There must be an existing path from the <code>SourceN</code> to the <code>TargetN</code>. This operation is inexpensive and does not change the set of SCCs and RefSCCs in the graph. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00944">944</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00654">isDescendantOf()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="aaf3ba7d78f09755223609e4978bebef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf3ba7d78f09755223609e4978bebef7">&#9670;&nbsp;</a></span>insertTrivialCallEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LazyCallGraph::RefSCC::insertTrivialCallEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience wrapper around the above to handle trivial cases of inserting a new call edge. </p>
<p>This is trivial whenever the target is in the same <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> as the source or the edge is an outgoing edge to some descendant <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a>. In these cases there is no change to the cyclic structure of SCCs or RefSCCs.</p>
<p>To further make calling this convenient, it also handles inserting already existing edges. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l01381">1381</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Call</a>, <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="SmallVector_8h_source.html#l00641">llvm::SmallVectorImpl&lt; T &gt;::emplace_back()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l01223">llvm::LazyCallGraph::Edge::isCall()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00970">llvm::LazyCallGraph::lookupSCC()</a>, <a class="el" href="ScopeExit_8h_source.html#l00058">llvm::make_scope_exit()</a>, <a class="el" href="SmallVector_8h_source.html#l00052">llvm::SmallVectorBase::size()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="a393b4565f554b9d8382c8f610b7f2ce7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393b4565f554b9d8382c8f610b7f2ce7">&#9670;&nbsp;</a></span>insertTrivialRefEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LazyCallGraph::RefSCC::insertTrivialRefEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience wrapper around the above to handle trivial cases of inserting a new ref edge. </p>
<p>This is trivial whenever the target is in the same <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> as the source or the edge is an outgoing edge to some descendant <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>. In these cases there is no change to the cyclic structure of the RefSCCs.</p>
<p>To further make calling this convenient, it also handles inserting already existing edges. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l01416">1416</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SmallVector_8h_source.html#l00641">llvm::SmallVectorImpl&lt; T &gt;::emplace_back()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="ScopeExit_8h_source.html#l00058">llvm::make_scope_exit()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Ref</a>, <a class="el" href="SmallVector_8h_source.html#l00052">llvm::SmallVectorBase::size()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="a35a8d25c6df3f1d3bc5faba32de1dd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a8d25c6df3f1d3bc5faba32de1dd55">&#9670;&nbsp;</a></span>isAncestorOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> LazyCallGraph::RefSCC::isAncestorOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;&#160;</td>
          <td class="paramname"><em>RC</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> is an ancestor of <em>RC</em>. </p>
<p>CAUTION: This method walks the directed graph of edges as far as necessary to find a possible path to the argument. In the worst case this may walk the entire graph and can be extremely expensive. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00365">365</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="NVVMIntrRange_8cpp_source.html#l00068">C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, <a class="el" href="SmallPtrSet_8h_source.html#l00370">llvm::SmallPtrSetImpl&lt; PtrType &gt;::insert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="SmallVector_8h_source.html#l00374">llvm::SmallVectorImpl&lt; T &gt;::pop_back_val()</a>, and <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T &gt;::push_back()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LazyCallGraph_8h_source.html#l00654">isDescendantOf()</a>.</p>

</div>
</div>
<a id="a5c04e8da471c500d025dfdf206c24ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c04e8da471c500d025dfdf206c24ed2">&#9670;&nbsp;</a></span>isChildOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::LazyCallGraph::RefSCC::isChildOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;&#160;</td>
          <td class="paramname"><em>RC</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> is a child of <em>RC</em>. </p>
<p>CAUTION: This method walks every edge in the argument <code><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a></code>, it can be very expensive. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00647">647</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

<p class="reference">References <a class="el" href="LazyCallGraph_8cpp_source.html#l00351">isParentOf()</a>.</p>

</div>
</div>
<a id="a59f6c7fa7f420326cc1f7026e51b0668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f6c7fa7f420326cc1f7026e51b0668">&#9670;&nbsp;</a></span>isDescendantOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> llvm::LazyCallGraph::RefSCC::isDescendantOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;&#160;</td>
          <td class="paramname"><em>RC</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> is a descendant of <em>RC</em>. </p>
<p>CAUTION: This method walks the directed graph of edges as far as necessary to find a possible path from the argument. In the worst case this may walk the entire graph and can be extremely expensive. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00654">654</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

<p class="reference">References <a class="el" href="LazyCallGraph_8cpp_source.html#l00365">isAncestorOf()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LazyCallGraph_8cpp_source.html#l00944">insertOutgoingEdge()</a>, <a class="el" href="LazyCallGraph_8cpp_source.html#l00887">switchOutgoingEdgeToCall()</a>, and <a class="el" href="LazyCallGraph_8cpp_source.html#l00909">switchOutgoingEdgeToRef()</a>.</p>

</div>
</div>
<a id="af952e1ffaf5cd4bd83b63cf7fb4cb068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af952e1ffaf5cd4bd83b63cf7fb4cb068">&#9670;&nbsp;</a></span>isParentOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> LazyCallGraph::RefSCC::isParentOf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;&#160;</td>
          <td class="paramname"><em>RC</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> is a parent of <em>RC</em>. </p>
<p>CAUTION: This method walks every edge in the <code><a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a></code>, it can be very expensive. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00351">351</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="NVVMIntrRange_8cpp_source.html#l00068">C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, and <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>.</p>

<p class="reference">Referenced by <a class="el" href="LazyCallGraph_8h_source.html#l00647">isChildOf()</a>.</p>

</div>
</div>
<a id="adc901e9b7bdc25bc9b5428c7fb0fa9f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc901e9b7bdc25bc9b5428c7fb0fa9f0">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">SCC</a>&amp; llvm::LazyCallGraph::RefSCC::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00624">624</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

</div>
</div>
<a id="a0f2a2749664a36abbb8d7cbb5279afed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2a2749664a36abbb8d7cbb5279afed">&#9670;&nbsp;</a></span>removeInternalRefEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">LazyCallGraph::RefSCC</a> *, 1 &gt; LazyCallGraph::RefSCC::removeInternalRefEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> *&gt;&#160;</td>
          <td class="paramname"><em>TargetNs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a list of ref edges which are entirely within this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>. </p>
<p>Both the <em>SourceN</em> and all of the <em>TargetNs</em> must be within this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>. Removing these edges may break cycles that form this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> and thus this operation may change the <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> graph significantly. In particular, this operation will re-form new RefSCCs based on the remaining connectivity of the graph. The following invariants are guaranteed to hold after calling this method:</p>
<p>1) If a ref-cycle remains after removal, it leaves this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> intact and in the graph. No new RefSCCs are built. 2) Otherwise, this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> will be dead after this call and no longer in the graph or the postorder traversal of the call graph. <a class="el" href="classllvm_1_1Any.html">Any</a> iterator pointing at this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> will become invalid. 3) All newly formed RefSCCs will be returned and the order of the RefSCCs returned will be a valid postorder traversal of the new RefSCCs. 4) No <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> other than this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> has its member set changed (this is inherent in the definition of removing such an edge).</p>
<p>These invariants are very important to ensure that we can build optimization pipelines on top of the CGSCC pass manager which intelligently update the <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> graph without invalidating other parts of the <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> graph.</p>
<p>Note that we provide no routine to remove a <em>call</em> edge. Instead, you must first switch it to a ref edge using <code>switchInternalEdgeToRef</code>. This split API is intentional as each of these two steps can invalidate a different aspect of the graph structure and needs to have the invalidation handled independently.</p>
<p>The runtime complexity of this method is, in the worst case, O(V+E) where V is the number of nodes in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> and E is the number of edges leaving the nodes in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>. Note that E includes both edges within this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> and edges from this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> to child RefSCCs. Some effort has been made to minimize the overhead of common cases such as self-edges and edge removals which result in a spanning tree with no more cycles. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l01128">1128</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l01182">llvm::all_of()</a>, <a class="el" href="SmallVector_8h_source.html#l00387">llvm::SmallVectorImpl&lt; T &gt;::append()</a>, <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SmallVector_8h_source.html#l00127">llvm::SmallVectorTemplateCommon&lt; T &gt;::begin()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00258">llvm::LazyCallGraph::EdgeSequence::begin()</a>, <a class="el" href="NVVMIntrRange_8cpp_source.html#l00068">C</a>, <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, <a class="el" href="SmallVector_8h_source.html#l00129">llvm::SmallVectorTemplateCommon&lt; T &gt;::end()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00259">llvm::LazyCallGraph::EdgeSequence::end()</a>, <a class="el" href="SmallVector_8h_source.html#l00434">llvm::SmallVectorImpl&lt; T &gt;::erase()</a>, <a class="el" href="STLExtras_8h_source.html#l01210">llvm::find_if()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00970">llvm::LazyCallGraph::lookupSCC()</a>, <a class="el" href="iterator__range_8h_source.html#l00054">llvm::make_range()</a>, <a class="el" href="ScopeExit_8h_source.html#l00058">llvm::make_scope_exit()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="SmallVector_8h_source.html#l00374">llvm::SmallVectorImpl&lt; T &gt;::pop_back_val()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T &gt;::push_back()</a>, <a class="el" href="STLExtras_8h_source.html#l00265">llvm::reverse()</a>, <a class="el" href="SmallVector_8h_source.html#l00052">llvm::SmallVectorBase::size()</a>, <a class="el" href="STLExtras_8h_source.html#l01163">llvm::size()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="ab130250bcdaefbfd3c583cad7b120b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab130250bcdaefbfd3c583cad7b120b62">&#9670;&nbsp;</a></span>removeOutgoingEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LazyCallGraph::RefSCC::removeOutgoingEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an edge whose source is in this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a> and target is <em>not</em>. </p>
<p>This removes an inter-RefSCC edge. All inter-RefSCC edges originating from this <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> have been fully explored by any in-flight DFS graph formation, so this is always safe to call once you have the source <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>.</p>
<p>This operation does not change the cyclic structure of the graph and so is very inexpensive. It may change the connectivity graph of the SCCs though, so be careful calling this while iterating over them. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l01108">1108</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="ScopeExit_8h_source.html#l00058">llvm::make_scope_exit()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="a70f7f0574edbfc0f75424499133d4ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f7f0574edbfc0f75424499133d4ba3">&#9670;&nbsp;</a></span>replaceNodeFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LazyCallGraph::RefSCC::replaceNodeFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Function.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>NewF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Directly replace a node's function with a new function. </p>
<p>This should be used when moving the body and users of a function to a new formal function object but not otherwise changing the call graph structure in any way.</p>
<p>It requires that the old function in the provided node have zero uses and the new function must have calls and references to it establishing an equivalent graph. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l01445">1445</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00334">llvm::LazyCallGraph::Node::getFunction()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="ScopeExit_8h_source.html#l00058">llvm::make_scope_exit()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="Value_8h_source.html#l00343">llvm::Value::use_empty()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="ac62cb27d2f0946c9febb1e1d1e377f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62cb27d2f0946c9febb1e1d1e377f55">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t llvm::LazyCallGraph::RefSCC::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00622">622</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

<p class="reference">References <a class="el" href="SmallVector_8h_source.html#l00052">llvm::SmallVectorBase::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LazyCallGraph_8cpp_source.html#l01761">printRefSCC()</a>, and <a class="el" href="LazyCallGraph_8cpp_source.html#l01492">llvm::LazyCallGraph::removeDeadFunction()</a>.</p>

</div>
</div>
<a id="a14961d8c765d29b4e96a0a676292ef33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14961d8c765d29b4e96a0a676292ef33">&#9670;&nbsp;</a></span>switchInternalEdgeToCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> LazyCallGraph::RefSCC::switchInternalEdgeToCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">function_ref</a>&lt; void(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html">SCC</a> *&gt; MergedSCCs)&gt;&#160;</td>
          <td class="paramname"><em>MergeCB</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an existing internal ref edge into a call edge. </p>
<p>This may form a larger cycle and thus collapse SCCs into TargetN's <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a>. If that happens, the optional callback <code>MergedCB</code> will be invoked (if provided) on the SCCs being merged away prior to actually performing the merge. Note that this will never include the target <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> as that will be the <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> functions are merged into to resolve the cycle. Once this function returns, these merged SCCs are not in a valid state but the pointers will remain valid until destruction of the parent graph instance for the purpose of clearing cached information. This function also returns 'true' if a cycle was formed and some SCCs merged away as a convenience.</p>
<p>After this operation, both SourceN's <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> and TargetN's <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> may move position within this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>'s postorder list. <a class="el" href="classllvm_1_1Any.html">Any</a> SCCs merged are merged into the TargetN's <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> in order to preserve reachability analyses which took place on that <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a>. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00529">529</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="NVVMIntrRange_8cpp_source.html#l00068">C</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Call</a>, <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00493">llvm::LazyCallGraph::SCC::getOuterRefSCC()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00970">llvm::LazyCallGraph::lookupSCC()</a>, <a class="el" href="iterator__range_8h_source.html#l00054">llvm::make_range()</a>, <a class="el" href="ScopeExit_8h_source.html#l00058">llvm::make_scope_exit()</a>, <a class="el" href="ArrayRef_8h_source.html#l00460">llvm::makeArrayRef()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="SmallVector_8h_source.html#l00374">llvm::SmallVectorImpl&lt; T &gt;::pop_back_val()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T &gt;::push_back()</a>, <a class="el" href="LazyCallGraph_8cpp_source.html#l00459">updatePostorderSequenceForEdgeInsertion()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="a96fe0cb15ded58bd1824fa4e3daec680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fe0cb15ded58bd1824fa4e3daec680">&#9670;&nbsp;</a></span>switchInternalEdgeToRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html#ad85b2ad566b56110886f3c39653b88fa">LazyCallGraph::RefSCC::iterator</a> &gt; LazyCallGraph::RefSCC::switchInternalEdgeToRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an existing internal call edge within a single <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> into a ref edge. </p>
<p>Since SourceN and TargetN are part of a single <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a>, this <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> may be split up due to breaking a cycle in the call edges that formed it. If that happens, then this routine will insert new SCCs into the postorder list <em>before</em> the <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> of TargetN (previously the <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> of both). This preserves postorder as the TargetN can reach all of the other nodes by definition of previously being in a single <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> formed by the cycle from SourceN to TargetN.</p>
<p>The newly added SCCs are added <em>immediately</em> and contiguously prior to the TargetN <a class="el" href="classllvm_1_1LazyCallGraph_1_1SCC.html" title="An SCC of the call graph. ">SCC</a> and return the range covering the new SCCs in the <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>'s postorder sequence. You can directly iterate the returned range to observe all of the new SCCs in postorder.</p>
<p>Note that if SourceN and TargetN are in separate SCCs, the simpler routine <code>switchTrivialInternalEdgeToRef</code> should be used instead. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00701">701</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SmallVector_8h_source.html#l00166">llvm::SmallVectorTemplateCommon&lt; T &gt;::back()</a>, <a class="el" href="SmallVector_8h_source.html#l00127">llvm::SmallVectorTemplateCommon&lt; T &gt;::begin()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00488">llvm::LazyCallGraph::SCC::begin()</a>, <a class="el" href="SmallVector_8h_source.html#l00339">llvm::SmallVectorImpl&lt; T &gt;::clear()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, <a class="el" href="SmallVector_8h_source.html#l00129">llvm::SmallVectorTemplateCommon&lt; T &gt;::end()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00489">llvm::LazyCallGraph::SCC::end()</a>, <a class="el" href="SmallVector_8h_source.html#l00434">llvm::SmallVectorImpl&lt; T &gt;::erase()</a>, <a class="el" href="STLExtras_8h_source.html#l01210">llvm::find_if()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00970">llvm::LazyCallGraph::lookupSCC()</a>, <a class="el" href="iterator__range_8h_source.html#l00054">llvm::make_range()</a>, <a class="el" href="ScopeExit_8h_source.html#l00058">llvm::make_scope_exit()</a>, <a class="el" href="regcomp_8c.html#a0240ac851181b84ac374872dc5434ee4">N</a>, <a class="el" href="SmallVector_8h_source.html#l00374">llvm::SmallVectorImpl&lt; T &gt;::pop_back_val()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T &gt;::push_back()</a>, <a class="el" href="SmallVector_8h_source.html#l00133">llvm::SmallVectorTemplateCommon&lt; T &gt;::rbegin()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Ref</a>, <a class="el" href="STLExtras_8h_source.html#l00265">llvm::reverse()</a>, <a class="el" href="Profile_8cpp_source.html#l00046">Size</a>, <a class="el" href="SmallVector_8h_source.html#l00052">llvm::SmallVectorBase::size()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00491">llvm::LazyCallGraph::SCC::size()</a>, <a class="el" href="SmallVector_8h_source.html#l00668">llvm::SmallVectorImpl&lt; T &gt;::swap()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="a5cc0541c3ee15c565ac05fe11f5459d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc0541c3ee15c565ac05fe11f5459d2">&#9670;&nbsp;</a></span>switchOutgoingEdgeToCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LazyCallGraph::RefSCC::switchOutgoingEdgeToCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an existing outgoing ref edge into a call edge. </p>
<p>Note that this is trivial as there are no cyclic impacts and there remains a reference edge. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00887">887</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Call</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00654">isDescendantOf()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="adce8df277d53b4d87581583c8269ac71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce8df277d53b4d87581583c8269ac71">&#9670;&nbsp;</a></span>switchOutgoingEdgeToRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LazyCallGraph::RefSCC::switchOutgoingEdgeToRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an existing outgoing call edge into a ref edge. </p>
<p>This is trivial as there are no cyclic impacts and there remains a reference edge. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00909">909</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00654">isDescendantOf()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Ref</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<a id="ae2f9bc7458beec4389ccf7fb88199d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f9bc7458beec4389ccf7fb88199d4b">&#9670;&nbsp;</a></span>switchTrivialInternalEdgeToRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LazyCallGraph::RefSCC::switchTrivialInternalEdgeToRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>SourceN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>TargetN</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an existing internal call edge between separate SCCs into a ref edge. </p>
<p>If SourceN and TargetN in separate SCCs within this <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html" title="A RefSCC of the call graph. ">RefSCC</a>, changing the call edge between them to a ref edge is a trivial operation that does not require any structural changes to the call graph. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8cpp_source.html#l00678">678</a> of file <a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00976">llvm::LazyCallGraph::lookupRefSCC()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00970">llvm::LazyCallGraph::lookupSCC()</a>, <a class="el" href="ScopeExit_8h_source.html#l00058">llvm::make_scope_exit()</a>, <a class="el" href="LazyCallGraph_8h_source.html#l00138">llvm::LazyCallGraph::Edge::Ref</a>, and <a class="el" href="namespacellvm.html#a89dacc902076da63a90aefcb2f5dbbe3">llvm::verify()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a81774ea46253e6427d63a610bd624c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81774ea46253e6427d63a610bd624c08">&#9670;&nbsp;</a></span>LazyCallGraph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classllvm_1_1LazyCallGraph.html">LazyCallGraph</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00548">548</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

</div>
</div>
<a id="a3a7a57d977301c68294ee8d4c92543ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7a57d977301c68294ee8d4c92543ce">&#9670;&nbsp;</a></span>LazyCallGraph::Node</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classllvm_1_1LazyCallGraph_1_1Node.html">LazyCallGraph::Node</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00549">549</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

</div>
</div>
<a id="a05d79ce3fd993135886c413600302540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d79ce3fd993135886c413600302540">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1raw__ostream.html">raw_ostream</a>&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1raw__ostream.html">raw_ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>OS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1LazyCallGraph_1_1RefSCC.html">RefSCC</a> &amp;&#160;</td>
          <td class="paramname"><em>RC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a short description useful for debugging or logging. </p>
<p>We print the SCCs wrapped in '[]'s and skipping the middle SCCs if there are a large number. </p>

<p class="definition">Definition at line <a class="el" href="LazyCallGraph_8h_source.html#l00575">575</a> of file <a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/llvm/Analysis/<a class="el" href="LazyCallGraph_8h_source.html">LazyCallGraph.h</a></li>
<li>lib/Analysis/<a class="el" href="LazyCallGraph_8cpp_source.html">LazyCallGraph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 24 2020 13:20:32 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
