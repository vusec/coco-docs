<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LLVM: lib/Transforms/Scalar/SROA.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LLVM
   &#160;<span id="projectnumber">10.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li><li class="navelem"><a class="el" href="dir_a72932e0778af28115095468f6286ff8.html">Transforms</a></li><li class="navelem"><a class="el" href="dir_e6e1f1f37d351595fa984b942927b205.html">Scalar</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">SROA.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This transformation implements the well known scalar replacement of aggregates transformation.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="SROA_8h_source.html">llvm/Transforms/Scalar/SROA.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="APInt_8h_source.html">llvm/ADT/APInt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ArrayRef_8h_source.html">llvm/ADT/ArrayRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DenseMap_8h_source.html">llvm/ADT/DenseMap.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PointerIntPair_8h_source.html">llvm/ADT/PointerIntPair.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="STLExtras_8h_source.html">llvm/ADT/STLExtras.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SetVector_8h_source.html">llvm/ADT/SetVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallBitVector_8h_source.html">llvm/ADT/SmallBitVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallPtrSet_8h_source.html">llvm/ADT/SmallPtrSet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="SmallVector_8h_source.html">llvm/ADT/SmallVector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Statistic_8h_source.html">llvm/ADT/Statistic.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="StringRef_8h_source.html">llvm/ADT/StringRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Twine_8h_source.html">llvm/ADT/Twine.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator_8h_source.html">llvm/ADT/iterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="iterator__range_8h_source.html">llvm/ADT/iterator_range.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="AssumptionCache_8h_source.html">llvm/Analysis/AssumptionCache.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GlobalsModRef_8h_source.html">llvm/Analysis/GlobalsModRef.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Loads_8h_source.html">llvm/Analysis/Loads.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PtrUseVisitor_8h_source.html">llvm/Analysis/PtrUseVisitor.h</a>&quot;</code><br />
<code>#include &quot;llvm/Config/llvm-config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="BasicBlock_8h_source.html">llvm/IR/BasicBlock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Constant_8h_source.html">llvm/IR/Constant.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ConstantFolder_8h_source.html">llvm/IR/ConstantFolder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Constants_8h_source.html">llvm/IR/Constants.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DIBuilder_8h_source.html">llvm/IR/DIBuilder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DataLayout_8h_source.html">llvm/IR/DataLayout.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DebugInfoMetadata_8h_source.html">llvm/IR/DebugInfoMetadata.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="DerivedTypes_8h_source.html">llvm/IR/DerivedTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Dominators_8h_source.html">llvm/IR/Dominators.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Function_8h_source.html">llvm/IR/Function.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GetElementPtrTypeIterator_8h_source.html">llvm/IR/GetElementPtrTypeIterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="GlobalAlias_8h_source.html">llvm/IR/GlobalAlias.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IRBuilder_8h_source.html">llvm/IR/IRBuilder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstVisitor_8h_source.html">llvm/IR/InstVisitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InstrTypes_8h_source.html">llvm/IR/InstrTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IR_2Instruction_8h_source.html">llvm/IR/Instruction.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Instructions_8h_source.html">llvm/IR/Instructions.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IntrinsicInst_8h_source.html">llvm/IR/IntrinsicInst.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Intrinsics_8h_source.html">llvm/IR/Intrinsics.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LLVMContext_8h_source.html">llvm/IR/LLVMContext.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Metadata_8h_source.html">llvm/IR/Metadata.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Module_8h_source.html">llvm/IR/Module.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Operator_8h_source.html">llvm/IR/Operator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PassManager_8h_source.html">llvm/IR/PassManager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Type_8h_source.html">llvm/IR/Type.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Use_8h_source.html">llvm/IR/Use.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="User_8h_source.html">llvm/IR/User.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Value_8h_source.html">llvm/IR/Value.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="InitializePasses_8h_source.html">llvm/InitializePasses.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Pass_8h_source.html">llvm/Pass.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Casting_8h_source.html">llvm/Support/Casting.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="CommandLine_8h_source.html">llvm/Support/CommandLine.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Compiler_8h_source.html">llvm/Support/Compiler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Debug_8h_source.html">llvm/Support/Debug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Support_2ErrorHandling_8h_source.html">llvm/Support/ErrorHandling.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="MathExtras_8h_source.html">llvm/Support/MathExtras.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="raw__ostream_8h_source.html">llvm/Support/raw_ostream.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Transforms_2Scalar_8h_source.html">llvm/Transforms/Scalar.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Transforms_2Utils_2Local_8h_source.html">llvm/Transforms/Utils/Local.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="PromoteMemToReg_8h_source.html">llvm/Transforms/Utils/PromoteMemToReg.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;chrono&gt;</code><br />
<code>#include &lt;cstddef&gt;</code><br />
<code>#include &lt;cstdint&gt;</code><br />
<code>#include &lt;cstring&gt;</code><br />
<code>#include &lt;iterator&gt;</code><br />
<code>#include &lt;string&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &lt;random&gt;</code><br />
</div>
<p><a href="SROA_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1sroa_1_1AllocaSlices.html">llvm::sroa::AllocaSlices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of the alloca slices.  <a href="classllvm_1_1sroa_1_1AllocaSlices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1sroa_1_1Partition.html">llvm::sroa::Partition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A partition of the slices.  <a href="classllvm_1_1sroa_1_1Partition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAllocaSlices_1_1partition__iterator.html">AllocaSlices::partition_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over partitions of the alloca's slices.  <a href="classAllocaSlices_1_1partition__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAllocaSlices_1_1SliceBuilder.html">AllocaSlices::SliceBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder for the alloca slices.  <a href="classAllocaSlices_1_1SliceBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1sroa_1_1AllocaSliceRewriter.html">llvm::sroa::AllocaSliceRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visitor to rewrite instructions using p particular slice of an alloca to use a new alloca.  <a href="classllvm_1_1sroa_1_1AllocaSliceRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classllvm_1_1sroa_1_1SROALegacyPass.html">llvm::sroa::SROALegacyPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A legacy pass for the legacy pass manager that wraps the <code><a class="el" href="classllvm_1_1SROA.html" title="An optimization pass providing Scalar Replacement of Aggregates. ">SROA</a></code> pass.  <a href="classllvm_1_1sroa_1_1SROALegacyPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ad78e062f62e0d6e453941fb4ca843e4d">DEBUG_TYPE</a>&#160;&#160;&#160;&quot;sroa&quot;</td></tr>
<tr class="separator:ad78e062f62e0d6e453941fb4ca843e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a618041bb2c6e95361ead0e45493039ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a618041bb2c6e95361ead0e45493039ef">STATISTIC</a> (NumAllocasAnalyzed, &quot;Number of allocas analyzed <a class="el" href="MipsDelaySlotFiller_8cpp.html#ab83893112065dd5c28fe90cca10ebba4">for</a> <a class="el" href="CoroElide_8cpp.html#a292041ae3f27ed6664cde3fc074c932e">replacement</a>&quot;)</td></tr>
<tr class="separator:a618041bb2c6e95361ead0e45493039ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e323f27ddb83247b75a5b2d375d9216"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a4e323f27ddb83247b75a5b2d375d9216">STATISTIC</a> (NumAllocaPartitions, &quot;Number of alloca partitions formed&quot;)</td></tr>
<tr class="separator:a4e323f27ddb83247b75a5b2d375d9216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0cc1a6f5d1eb652844d9752b238390"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ace0cc1a6f5d1eb652844d9752b238390">STATISTIC</a> (MaxPartitionsPerAlloca, &quot;Maximum number of partitions per alloca&quot;)</td></tr>
<tr class="separator:ace0cc1a6f5d1eb652844d9752b238390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8043ffc0bf25bc77b88596ec2555d25f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a8043ffc0bf25bc77b88596ec2555d25f">STATISTIC</a> (NumAllocaPartitionUses, &quot;Number of alloca partition uses rewritten&quot;)</td></tr>
<tr class="separator:a8043ffc0bf25bc77b88596ec2555d25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96dad8afe38ad77a313ecac3d1f151a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ab96dad8afe38ad77a313ecac3d1f151a">STATISTIC</a> (MaxUsesPerAllocaPartition, &quot;Maximum number of uses of a partition&quot;)</td></tr>
<tr class="separator:ab96dad8afe38ad77a313ecac3d1f151a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd84289002379062d3d99430eb946df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#adcd84289002379062d3d99430eb946df">STATISTIC</a> (NumNewAllocas, &quot;Number of new, smaller allocas introduced&quot;)</td></tr>
<tr class="separator:adcd84289002379062d3d99430eb946df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd53eb32a458943eee0e59c868868419"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#afd53eb32a458943eee0e59c868868419">STATISTIC</a> (NumPromoted, &quot;Number of allocas promoted to <a class="el" href="MemorySSA_8cpp.html#a20a60bdac22b099d87d8cb0c1d554120">SSA</a> values&quot;)</td></tr>
<tr class="separator:afd53eb32a458943eee0e59c868868419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f1e2ef32da6004704b9dfd4d80482e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ae1f1e2ef32da6004704b9dfd4d80482e">STATISTIC</a> (NumLoadsSpeculated, &quot;Number of loads speculated to allow promotion&quot;)</td></tr>
<tr class="separator:ae1f1e2ef32da6004704b9dfd4d80482e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af559aec98fbf691ccd4c3233556cc618"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#af559aec98fbf691ccd4c3233556cc618">STATISTIC</a> (NumDeleted, &quot;Number of <a class="el" href="LoadStoreVectorizer_8cpp.html#acc0655e462f1e67d046cd818e473c46e">instructions</a> deleted&quot;)</td></tr>
<tr class="separator:af559aec98fbf691ccd4c3233556cc618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f794c154e83c0c1f7953596198faa8f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a3f794c154e83c0c1f7953596198faa8f">STATISTIC</a> (NumVectorized, &quot;Number of vectorized aggregates&quot;)</td></tr>
<tr class="separator:a3f794c154e83c0c1f7953596198faa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849bc9de354f140d265e3ff56999ce19"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a849bc9de354f140d265e3ff56999ce19">foldSelectInst</a> (<a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;<a class="el" href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a>)</td></tr>
<tr class="separator:a849bc9de354f140d265e3ff56999ce19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d87925bf94456691d6030c7d6070c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a23d87925bf94456691d6030c7d6070c4">foldPHINodeOrSelectInst</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>)</td></tr>
<tr class="memdesc:a23d87925bf94456691d6030c7d6070c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper that folds a PHI node or a select.  <a href="#a23d87925bf94456691d6030c7d6070c4">More...</a><br /></td></tr>
<tr class="separator:a23d87925bf94456691d6030c7d6070c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf4af896107038c5fc876bf11ba5f24"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#abdf4af896107038c5fc876bf11ba5f24">findCommonType</a> (AllocaSlices::const_iterator <a class="el" href="BuiltinGCs_8cpp.html#a7abf5fb4071cb25dbce06dfb5ee3c937">B</a>, AllocaSlices::const_iterator <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, uint64_t EndOffset)</td></tr>
<tr class="memdesc:abdf4af896107038c5fc876bf11ba5f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk the range of a partitioning looking for a common type to cover this sequence of slices.  <a href="#abdf4af896107038c5fc876bf11ba5f24">More...</a><br /></td></tr>
<tr class="separator:abdf4af896107038c5fc876bf11ba5f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab37469c4748a495736ad163ac54e776"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#aab37469c4748a495736ad163ac54e776">isSafePHIToSpeculate</a> (<a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN)</td></tr>
<tr class="memdesc:aab37469c4748a495736ad163ac54e776"><td class="mdescLeft">&#160;</td><td class="mdescRight">PHI instructions that use an alloca and are subsequently loaded can be rewritten to load both input pointers in the pred blocks and then PHI the results, allowing the load of the alloca to be promoted.  <a href="#aab37469c4748a495736ad163ac54e776">More...</a><br /></td></tr>
<tr class="separator:aab37469c4748a495736ad163ac54e776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab38ec9ebc3b5d96a4b7ddcb11cfcd58"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#aab38ec9ebc3b5d96a4b7ddcb11cfcd58">speculatePHINodeLoads</a> (<a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;PN)</td></tr>
<tr class="separator:aab38ec9ebc3b5d96a4b7ddcb11cfcd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e373cfa6ef51df8f9c43dc8b8539c0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a93e373cfa6ef51df8f9c43dc8b8539c0">isSafeSelectToSpeculate</a> (<a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;<a class="el" href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a>)</td></tr>
<tr class="memdesc:a93e373cfa6ef51df8f9c43dc8b8539c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select instructions that use an alloca and are subsequently loaded can be rewritten to load both input pointers and then select between the result, allowing the load of the alloca to be promoted.  <a href="#a93e373cfa6ef51df8f9c43dc8b8539c0">More...</a><br /></td></tr>
<tr class="separator:a93e373cfa6ef51df8f9c43dc8b8539c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7493b7d3b84612687869f2c3afed924b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a7493b7d3b84612687869f2c3afed924b">speculateSelectInstLoads</a> (<a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;<a class="el" href="SIInstrInfo_8cpp.html#a0dfd55eaf0bcb495f09ecf8c55b256b2a6cbe5ff42f143903e1c67abf94613791">SI</a>)</td></tr>
<tr class="separator:a7493b7d3b84612687869f2c3afed924b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a620f882d8f1578375a2963955f2c5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ab4a620f882d8f1578375a2963955f2c5">buildGEP</a> (IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *BasePtr, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *&gt; &amp;Indices, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:ab4a620f882d8f1578375a2963955f2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a GEP out of a base pointer and indices.  <a href="#ab4a620f882d8f1578375a2963955f2c5">More...</a><br /></td></tr>
<tr class="separator:ab4a620f882d8f1578375a2963955f2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20222f2e0fce0e91374ec5ce5b1d9c7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a20222f2e0fce0e91374ec5ce5b1d9c7f">getNaturalGEPWithType</a> (IRBuilderTy &amp;IRB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Value.html">Value</a> *BasePtr, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1Type.html">Type</a> *TargetTy, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *&gt; &amp;Indices, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:a20222f2e0fce0e91374ec5ce5b1d9c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a natural GEP off of the BasePtr walking through Ty toward TargetTy without changing the offset of the pointer.  <a href="#a20222f2e0fce0e91374ec5ce5b1d9c7f">More...</a><br /></td></tr>
<tr class="separator:a20222f2e0fce0e91374ec5ce5b1d9c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e5b00daea0267fcbbae32737b41fa1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a43e5b00daea0267fcbbae32737b41fa1">getNaturalGEPRecursively</a> (IRBuilderTy &amp;IRB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, <a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;Offset, <a class="el" href="classllvm_1_1Type.html">Type</a> *TargetTy, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *&gt; &amp;Indices, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:a43e5b00daea0267fcbbae32737b41fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively compute indices for a natural GEP.  <a href="#a43e5b00daea0267fcbbae32737b41fa1">More...</a><br /></td></tr>
<tr class="separator:a43e5b00daea0267fcbbae32737b41fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191588e676f2305ed87eec15ae5a4d6e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a191588e676f2305ed87eec15ae5a4d6e">getNaturalGEPWithOffset</a> (IRBuilderTy &amp;IRB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="el" href="classllvm_1_1APInt.html">APInt</a> Offset, <a class="el" href="classllvm_1_1Type.html">Type</a> *TargetTy, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *&gt; &amp;Indices, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:a191588e676f2305ed87eec15ae5a4d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a natural GEP from a base pointer to a particular offset and resulting in a particular type.  <a href="#a191588e676f2305ed87eec15ae5a4d6e">More...</a><br /></td></tr>
<tr class="separator:a191588e676f2305ed87eec15ae5a4d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf248f865af8d7de55740b7123bde294"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#adf248f865af8d7de55740b7123bde294">getAdjustedPtr</a> (IRBuilderTy &amp;IRB, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Value.html">Value</a> *Ptr, <a class="el" href="classllvm_1_1APInt.html">APInt</a> Offset, <a class="el" href="classllvm_1_1Type.html">Type</a> *<a class="el" href="namespacellvm.html#a2d5a7634b0ed15979c2cd15c62d6d4b5">PointerTy</a>, <a class="el" href="classllvm_1_1Twine.html">Twine</a> NamePrefix)</td></tr>
<tr class="memdesc:adf248f865af8d7de55740b7123bde294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute an adjusted pointer from Ptr by Offset bytes where the resulting pointer has PointerTy.  <a href="#adf248f865af8d7de55740b7123bde294">More...</a><br /></td></tr>
<tr class="separator:adf248f865af8d7de55740b7123bde294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5501b612c6e697686ccff55d1d5d8b98"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structllvm_1_1Align.html">Align</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a5501b612c6e697686ccff55d1d5d8b98">getAdjustedAlignment</a> (<a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *<a class="el" href="MD5_8cpp.html#ac0eafdc9ee161b71e7af98af736952fd">I</a>, uint64_t Offset, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:a5501b612c6e697686ccff55d1d5d8b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the adjusted alignment for a load or store from an offset.  <a href="#a5501b612c6e697686ccff55d1d5d8b98">More...</a><br /></td></tr>
<tr class="separator:a5501b612c6e697686ccff55d1d5d8b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb1c078833c17e4c9529b0cf924385c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a2fb1c078833c17e4c9529b0cf924385c">canConvertValue</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Type.html">Type</a> *OldTy, <a class="el" href="classllvm_1_1Type.html">Type</a> *NewTy)</td></tr>
<tr class="memdesc:a2fb1c078833c17e4c9529b0cf924385c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether we can convert a value from the old to the new type.  <a href="#a2fb1c078833c17e4c9529b0cf924385c">More...</a><br /></td></tr>
<tr class="separator:a2fb1c078833c17e4c9529b0cf924385c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6146d9a22768498097b2c53cd2234f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a7d6146d9a22768498097b2c53cd2234f">convertValue</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1Type.html">Type</a> *NewTy)</td></tr>
<tr class="memdesc:a7d6146d9a22768498097b2c53cd2234f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic routine to convert an SSA value to a value of a different type.  <a href="#a7d6146d9a22768498097b2c53cd2234f">More...</a><br /></td></tr>
<tr class="separator:a7d6146d9a22768498097b2c53cd2234f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c31035e44c7bda618eb2eb81dcf314"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ab4c31035e44c7bda618eb2eb81dcf314">isVectorPromotionViableForSlice</a> (<a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;<a class="el" href="Mips16ISelLowering_8cpp.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Slice &amp;S, <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *Ty, uint64_t ElementSize, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:ab4c31035e44c7bda618eb2eb81dcf314"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the given slice use can be promoted to a vector.  <a href="#ab4c31035e44c7bda618eb2eb81dcf314">More...</a><br /></td></tr>
<tr class="separator:ab4c31035e44c7bda618eb2eb81dcf314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458f8b1b5c1beb71a2f7b1e1c151741d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a458f8b1b5c1beb71a2f7b1e1c151741d">isVectorPromotionViable</a> (<a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;<a class="el" href="Mips16ISelLowering_8cpp.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a>, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:a458f8b1b5c1beb71a2f7b1e1c151741d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the given alloca partitioning and range of slices can be promoted to a vector.  <a href="#a458f8b1b5c1beb71a2f7b1e1c151741d">More...</a><br /></td></tr>
<tr class="separator:a458f8b1b5c1beb71a2f7b1e1c151741d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593afa69fb7cfbb4506f605bd785f923"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a593afa69fb7cfbb4506f605bd785f923">isIntegerWideningViableForSlice</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Slice &amp;S, uint64_t AllocBeginOffset, <a class="el" href="classllvm_1_1Type.html">Type</a> *AllocaTy, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classbool.html">bool</a> &amp;WholeAllocaOp)</td></tr>
<tr class="memdesc:a593afa69fb7cfbb4506f605bd785f923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether a slice of an alloca is valid for integer widening.  <a href="#a593afa69fb7cfbb4506f605bd785f923">More...</a><br /></td></tr>
<tr class="separator:a593afa69fb7cfbb4506f605bd785f923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9ee96f281dd94ed4119c2e45836bf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a7fd9ee96f281dd94ed4119c2e45836bf">isIntegerWideningViable</a> (<a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;<a class="el" href="Mips16ISelLowering_8cpp.html#a2748566f4c443ee77aa831e63dbb5ebe">P</a>, <a class="el" href="classllvm_1_1Type.html">Type</a> *AllocaTy, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL)</td></tr>
<tr class="memdesc:a7fd9ee96f281dd94ed4119c2e45836bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the given alloca partition's integer operations can be widened to promotable ones.  <a href="#a7fd9ee96f281dd94ed4119c2e45836bf">More...</a><br /></td></tr>
<tr class="separator:a7fd9ee96f281dd94ed4119c2e45836bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e7aca18fb08798727209385f164f7c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a94e7aca18fb08798727209385f164f7c">extractInteger</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classllvm_1_1IntegerType.html">IntegerType</a> *Ty, uint64_t Offset, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#ac19c5d82adec186ac56e94115530daa8">Name</a>)</td></tr>
<tr class="separator:a94e7aca18fb08798727209385f164f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7febebe786555d6e0d07ca0f86e294c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a7febebe786555d6e0d07ca0f86e294c1">insertInteger</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *Old, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, uint64_t Offset, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#ac19c5d82adec186ac56e94115530daa8">Name</a>)</td></tr>
<tr class="separator:a7febebe786555d6e0d07ca0f86e294c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a9071efa992145e210f0b41a52e501"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a06a9071efa992145e210f0b41a52e501">extractVector</a> (IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classunsigned.html">unsigned</a> BeginIndex, <a class="el" href="classunsigned.html">unsigned</a> EndIndex, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#ac19c5d82adec186ac56e94115530daa8">Name</a>)</td></tr>
<tr class="separator:a06a9071efa992145e210f0b41a52e501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c6a2faff923f431932c6d33cf4092b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a42c6a2faff923f431932c6d33cf4092b">insertVector</a> (IRBuilderTy &amp;IRB, <a class="el" href="classllvm_1_1Value.html">Value</a> *Old, <a class="el" href="classllvm_1_1Value.html">Value</a> *V, <a class="el" href="classunsigned.html">unsigned</a> BeginIndex, <a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;<a class="el" href="AMDGPULibCalls_8cpp.html#ac19c5d82adec186ac56e94115530daa8">Name</a>)</td></tr>
<tr class="separator:a42c6a2faff923f431932c6d33cf4092b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac102ff32dace1cf8e8e6f9c9ec4d159c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ac102ff32dace1cf8e8e6f9c9ec4d159c">stripAggregateTypeWrapping</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty)</td></tr>
<tr class="memdesc:ac102ff32dace1cf8e8e6f9c9ec4d159c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip aggregate type wrapping.  <a href="#ac102ff32dace1cf8e8e6f9c9ec4d159c">More...</a><br /></td></tr>
<tr class="separator:ac102ff32dace1cf8e8e6f9c9ec4d159c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe75ff888b6a7ee2836aa6c8f33984c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#abe75ff888b6a7ee2836aa6c8f33984c1">getTypePartition</a> (<a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;DL, <a class="el" href="classllvm_1_1Type.html">Type</a> *Ty, uint64_t Offset, uint64_t <a class="el" href="Profile_8cpp.html#a1f5ab05b3305a959d954b796c63807c4">Size</a>)</td></tr>
<tr class="memdesc:abe75ff888b6a7ee2836aa6c8f33984c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a partition of the aggregate type passed in for a given offset and size.  <a href="#abe75ff888b6a7ee2836aa6c8f33984c1">More...</a><br /></td></tr>
<tr class="separator:abe75ff888b6a7ee2836aa6c8f33984c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786d5a99befacdb30b3d3b5c3b07bd30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a786d5a99befacdb30b3d3b5c3b07bd30">INITIALIZE_PASS_BEGIN</a> (<a class="el" href="classllvm_1_1sroa_1_1SROALegacyPass.html">SROALegacyPass</a>, &quot;sroa&quot;, &quot;Scalar Replacement Of <a class="el" href="SROA_8cpp.html#a5b3f8e5f6c512fe6a5059dd0c51aec95">Aggregates</a>&quot;, false, <a class="el" href="LoadStoreVectorizer_8cpp.html#a1321ae04c732793cd2d0ee2db36636ca">false</a>) <a class="el" href="RegBankSelect_8cpp.html#a0eee13989797c0d4612066f84ff7a7b8">INITIALIZE_PASS_END</a>(<a class="el" href="classllvm_1_1sroa_1_1SROALegacyPass.html">SROALegacyPass</a></td></tr>
<tr class="separator:a786d5a99befacdb30b3d3b5c3b07bd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a577be81e94407739665be7332b4f9ac0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a577be81e94407739665be7332b4f9ac0">SROARandomShuffleSlices</a> (&quot;sroa-random-shuffle-slices&quot;, cl::init(<a class="el" href="LoadStoreVectorizer_8cpp.html#a1321ae04c732793cd2d0ee2db36636ca">false</a>), cl::Hidden)</td></tr>
<tr class="memdesc:a577be81e94407739665be7332b4f9ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hidden option to enable randomly shuffling the slices to help uncover instability in their order.  <a href="#a577be81e94407739665be7332b4f9ac0">More...</a><br /></td></tr>
<tr class="separator:a577be81e94407739665be7332b4f9ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6da6bff872f9db9f549ab7dd6086a61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#ac6da6bff872f9db9f549ab7dd6086a61">SROAStrictInbounds</a> (&quot;sroa-strict-inbounds&quot;, cl::init(<a class="el" href="LoadStoreVectorizer_8cpp.html#a1321ae04c732793cd2d0ee2db36636ca">false</a>), cl::Hidden)</td></tr>
<tr class="memdesc:ac6da6bff872f9db9f549ab7dd6086a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hidden option to experiment with completely strict handling of inbounds GEPs.  <a href="#ac6da6bff872f9db9f549ab7dd6086a61">More...</a><br /></td></tr>
<tr class="separator:ac6da6bff872f9db9f549ab7dd6086a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6990f15b9f29df6e8497b3e53875ccab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a6990f15b9f29df6e8497b3e53875ccab">sroa</a></td></tr>
<tr class="separator:a6990f15b9f29df6e8497b3e53875ccab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3f8e5f6c512fe6a5059dd0c51aec95"><td class="memItemLeft" align="right" valign="top">Scalar Replacement Of&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#a5b3f8e5f6c512fe6a5059dd0c51aec95">Aggregates</a></td></tr>
<tr class="separator:a5b3f8e5f6c512fe6a5059dd0c51aec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7a95cb9fb444faf77cd626f1b8128b"><td class="memItemLeft" align="right" valign="top">Scalar Replacement Of&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="SROA_8cpp.html#acc7a95cb9fb444faf77cd626f1b8128b">false</a></td></tr>
<tr class="separator:acc7a95cb9fb444faf77cd626f1b8128b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This transformation implements the well known scalar replacement of aggregates transformation. </p>
<p>It tries to identify promotable elements of an aggregate alloca, and promote them to registers. It will also try to convert uses of an element (or set of elements) of an alloca into a vector or bitfield-style integer scalar if appropriate.</p>
<p>It works to do this with minimal slicing of the alloca so that regions which are merely transferred in and out of external memory remain unchanged and are not decomposed to scalar code.</p>
<p>Because this also performs alloca promotion, it can be thought of as also serving the purpose of SSA formation. The algorithm iterates on the function until all opportunities for promotion have been realized. </p>

<p class="definition">Definition in file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad78e062f62e0d6e453941fb4ca843e4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78e062f62e0d6e453941fb4ca843e4d">&#9670;&nbsp;</a></span>DEBUG_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEBUG_TYPE&#160;&#160;&#160;&quot;sroa&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l00105">105</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab4a620f882d8f1578375a2963955f2c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a620f882d8f1578375a2963955f2c5">&#9670;&nbsp;</a></span>buildGEP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* buildGEP </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>BasePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build a GEP out of a base pointer and indices. </p>
<p>This will return the BasePtr if that is valid, or build a new GEP instruction using the IRBuilder if GEP-ing is needed. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01398">1398</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SmallVector_8h_source.html#l00166">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::back()</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, <a class="el" href="Type_8h_source.html#l00381">llvm::Type::getPointerElementType()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Lint_8cpp_source.html#l00550">isZero()</a>, and <a class="el" href="SmallVector_8h_source.html#l00052">llvm::SmallVectorBase::size()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Operations_8cpp_source.html#l00170">llvm::fuzzerop::gepDescriptor()</a>, and <a class="el" href="SROA_8cpp_source.html#l01421">getNaturalGEPWithType()</a>.</p>

</div>
</div>
<a id="a2fb1c078833c17e4c9529b0cf924385c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb1c078833c17e4c9529b0cf924385c">&#9670;&nbsp;</a></span>canConvertValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> canConvertValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>OldTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>NewTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether we can convert a value from the old to the new type. </p>
<p>This predicate should be used to guard calls to convertValue in order to ensure that we only try to convert viable values. The strategy is that we will peel off single element struct and array wrappings to get to an underlying value, and convert that value. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01706">1706</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="ValueTracking_8cpp_source.html#l00089">getBitWidth()</a>, <a class="el" href="Type_8h_source.html#l00307">llvm::Type::getScalarType()</a>, <a class="el" href="DataLayout_8h_source.html#l00624">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="Type_8h_source.html#l00197">llvm::Type::isIntegerTy()</a>, <a class="el" href="DataLayout_8h_source.html#l00380">llvm::DataLayout::isNonIntegralPointerType()</a>, <a class="el" href="Type_8h_source.html#l00224">llvm::Type::isPointerTy()</a>, and <a class="el" href="Type_8h_source.html#l00250">llvm::Type::isSingleValueType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01757">convertValue()</a>, <a class="el" href="SROA_8cpp_source.html#l02085">isIntegerWideningViable()</a>, <a class="el" href="SROA_8cpp_source.html#l01998">isIntegerWideningViableForSlice()</a>, <a class="el" href="SROA_8cpp_source.html#l01807">isVectorPromotionViableForSlice()</a>, and <a class="el" href="SROA_8cpp_source.html#l02346">llvm::sroa::AllocaSliceRewriter::visit()</a>.</p>

</div>
</div>
<a id="a7d6146d9a22768498097b2c53cd2234f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6146d9a22768498097b2c53cd2234f">&#9670;&nbsp;</a></span>convertValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* convertValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>NewTy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generic routine to convert an SSA value to a value of a different type. </p>
<p>This will try various different casting techniques, such as bitcasts, inttoptr, and ptrtoint casts. Use the <code>canConvertValue</code> predicate to test two types for viability with this routine. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01757">1757</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SROA_8cpp_source.html#l01706">canConvertValue()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00769">llvm::DataLayout::getIntPtrType()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Type_8h_source.html#l00203">llvm::Type::isIntOrIntVectorTy()</a>, <a class="el" href="Type_8h_source.html#l00227">llvm::Type::isPtrOrPtrVectorTy()</a>, and <a class="el" href="Type_8h_source.html#l00230">llvm::Type::isVectorTy()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l02346">llvm::sroa::AllocaSliceRewriter::visit()</a>.</p>

</div>
</div>
<a id="a94e7aca18fb08798727209385f164f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e7aca18fb08798727209385f164f7c">&#9670;&nbsp;</a></span>extractInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* extractInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1IntegerType.html">IntegerType</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02127">2127</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00071">llvm::IntegerType::getBitWidth()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00454">llvm::DataLayout::getTypeStoreSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00233">llvm::DataLayout::isBigEndian()</a>, and <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l02346">llvm::sroa::AllocaSliceRewriter::visit()</a>.</p>

</div>
</div>
<a id="a06a9071efa992145e210f0b41a52e501"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a9071efa992145e210f0b41a52e501">&#9670;&nbsp;</a></span>extractVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* extractVector </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>BeginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>EndIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02181">2181</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="Constants_8cpp_source.html#l01161">llvm::ConstantVector::get()</a>, <a class="el" href="Constants_8cpp_source.html#l01514">llvm::UndefValue::get()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00398">llvm::SequentialType::getNumElements()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="BitmaskEnum_8h_source.html#l00080">llvm::BitmaskEnumDetail::Mask()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T &gt;::push_back()</a>, and <a class="el" href="SmallVector_8h_source.html#l00369">llvm::SmallVectorImpl&lt; T &gt;::reserve()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HexagonISelLowering_8h_source.html#l00330">llvm::HexagonTargetLowering::shouldExpandAtomicRMWInIR()</a>, and <a class="el" href="SROA_8cpp_source.html#l02346">llvm::sroa::AllocaSliceRewriter::visit()</a>.</p>

</div>
</div>
<a id="abdf4af896107038c5fc876bf11ba5f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf4af896107038c5fc876bf11ba5f24">&#9670;&nbsp;</a></span>findCommonType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Type.html">Type</a>* findCommonType </td>
          <td>(</td>
          <td class="paramtype">AllocaSlices::const_iterator&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AllocaSlices::const_iterator&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>EndOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk the range of a partitioning looking for a common type to cover this sequence of slices. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01128">1128</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="DerivedTypes_8h_source.html#l00071">llvm::IntegerType::getBitWidth()</a>, and <a class="el" href="MD5_8cpp_source.html#l00058">I</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03506">getTypePartition()</a>.</p>

</div>
</div>
<a id="a23d87925bf94456691d6030c7d6070c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23d87925bf94456691d6030c7d6070c4">&#9670;&nbsp;</a></span>foldPHINodeOrSelectInst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* foldPHINodeOrSelectInst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> &amp;&#160;</td>
          <td class="paramname"><em>I</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper that folds a PHI node or a select. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l00636">636</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l00623">foldSelectInst()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l00664">AllocaSlices::SliceBuilder::SliceBuilder()</a>.</p>

</div>
</div>
<a id="a849bc9de354f140d265e3ff56999ce19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849bc9de354f140d265e3ff56999ce19">&#9670;&nbsp;</a></span>foldSelectInst()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* foldSelectInst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;&#160;</td>
          <td class="paramname"><em>SI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l00623">623</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8h_source.html#l01768">llvm::SelectInst::getCondition()</a>, and <a class="el" href="User_8h_source.html#l00169">llvm::User::getOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l00636">foldPHINodeOrSelectInst()</a>.</p>

</div>
</div>
<a id="a5501b612c6e697686ccff55d1d5d8b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5501b612c6e697686ccff55d1d5d8b98">&#9670;&nbsp;</a></span>getAdjustedAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structllvm_1_1Align.html">Align</a> getAdjustedAlignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Instruction.html">Instruction</a> *&#160;</td>
          <td class="paramname"><em>I</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the adjusted alignment for a load or store from an offset. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01684">1684</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="Alignment_8h_source.html#l00215">llvm::commonAlignment()</a>, <a class="el" href="DataLayout_8h_source.html#l00508">llvm::DataLayout::getValueOrABITypeAlignment()</a>, and <a class="el" href="Support_2ErrorHandling_8h_source.html#l00135">llvm_unreachable</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03506">getTypePartition()</a>, and <a class="el" href="SROA_8cpp_source.html#l02346">llvm::sroa::AllocaSliceRewriter::visit()</a>.</p>

</div>
</div>
<a id="adf248f865af8d7de55740b7123bde294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf248f865af8d7de55740b7123bde294">&#9670;&nbsp;</a></span>getAdjustedPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* getAdjustedPtr </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a>&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>PointerTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute an adjusted pointer from Ptr by Offset bytes where the resulting pointer has PointerTy. </p>
<p>This tries very hard to compute a "natural" GEP which arrives at the offset and produces the pointer type desired. Where it cannot, it will try to use the natural GEP to arrive at the offset and bitcast to the type. Where that fails, it will try to use an existing i8* and GEP to the byte offset and bitcast to the type.</p>
<p>The strategy for finding the more natural GEPs is to peel off layers of the pointer, walking back through bit casts and GEPs, searching for a base pointer from which we can compute a natural GEP with the desired properties. The algorithm tries to fold as many constant indices into a single GEP as possible, thus making each GEP more independent of the surrounding code. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01579">1579</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SmallVector_8h_source.html#l00339">llvm::SmallVectorImpl&lt; T &gt;::clear()</a>, <a class="el" href="HexagonCommonGEP_8cpp_source.html#l00171">GEP</a>, <a class="el" href="APInt_8h_source.html#l01566">llvm::APInt::getBitWidth()</a>, <a class="el" href="SROA_8cpp_source.html#l01539">getNaturalGEPWithOffset()</a>, <a class="el" href="Operator_8h_source.html#l00040">llvm::Operator::getOpcode()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00635">llvm::Type::getPointerAddressSpace()</a>, <a class="el" href="Type_8cpp_source.html#l00659">llvm::Type::getPointerTo()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="SmallPtrSet_8h_source.html#l00370">llvm::SmallPtrSetImpl&lt; PtrType &gt;::insert()</a>, <a class="el" href="Type_8h_source.html#l00197">llvm::Type::isIntegerTy()</a>, <a class="el" href="Type_8h_source.html#l00224">llvm::Type::isPointerTy()</a>, and <a class="el" href="Option_8cpp.html#a04665169063c8ca1f2ea96c27fc7c2b2">P</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03506">getTypePartition()</a>, and <a class="el" href="SROA_8cpp_source.html#l02346">llvm::sroa::AllocaSliceRewriter::visit()</a>.</p>

</div>
</div>
<a id="a43e5b00daea0267fcbbae32737b41fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e5b00daea0267fcbbae32737b41fa1">&#9670;&nbsp;</a></span>getNaturalGEPRecursively()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* getNaturalGEPRecursively </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a> &amp;&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>TargetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively compute indices for a natural GEP. </p>
<p>This is the recursive step for getNaturalGEPWithOffset that walks down the element types adding appropriate indices for the GEP. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01465">1465</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00332">llvm::dyn_cast()</a>, <a class="el" href="APInt_8h_source.html#l01566">llvm::APInt::getBitWidth()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00080">llvm::StructLayout::getElementContainingOffset()</a>, <a class="el" href="DataLayout_8h_source.html#l00607">llvm::StructLayout::getElementOffset()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00351">llvm::StructType::getElementType()</a>, <a class="el" href="SROA_8cpp_source.html#l01421">getNaturalGEPWithType()</a>, <a class="el" href="DataLayout_8h_source.html#l00593">llvm::StructLayout::getSizeInBytes()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00613">llvm::DataLayout::getStructLayout()</a>, <a class="el" href="DataLayout_8h_source.html#l00486">llvm::DataLayout::getTypeAllocSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00624">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="APInt_8h_source.html#l01620">llvm::APInt::getZExtValue()</a>, <a class="el" href="Type_8h_source.html#l00224">llvm::Type::isPointerTy()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, <a class="el" href="APInt_8cpp_source.html#l01672">llvm::APInt::sdiv()</a>, and <a class="el" href="APInt_8h_source.html#l01313">llvm::APInt::uge()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01539">getNaturalGEPWithOffset()</a>.</p>

</div>
</div>
<a id="a191588e676f2305ed87eec15ae5a4d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191588e676f2305ed87eec15ae5a4d6e">&#9670;&nbsp;</a></span>getNaturalGEPWithOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* getNaturalGEPWithOffset </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1APInt.html">APInt</a>&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>TargetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a natural GEP from a base pointer to a particular offset and resulting in a particular type. </p>
<p>The goal is to produce a "natural" looking GEP that works with the existing composite types to arrive at the appropriate offset and element type for a pointer. TargetTy is the element type the returned GEP should point-to if possible. We recurse by decreasing Offset, adding the appropriate index to Indices, and setting Ty to the result subtype.</p>
<p>If no natural GEP can be constructed, this function returns null. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01539">1539</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="DerivedTypes_8h_source.html#l00607">llvm::PointerType::getAddressSpace()</a>, <a class="el" href="APInt_8h_source.html#l01566">llvm::APInt::getBitWidth()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00598">llvm::PointerType::getElementType()</a>, <a class="el" href="Type_8cpp_source.html#l00224">llvm::Type::getInt8PtrTy()</a>, <a class="el" href="SROA_8cpp_source.html#l01465">getNaturalGEPRecursively()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00486">llvm::DataLayout::getTypeAllocSize()</a>, <a class="el" href="Type_8h_source.html#l00197">llvm::Type::isIntegerTy()</a>, <a class="el" href="Type_8h_source.html#l00265">llvm::Type::isSized()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>, and <a class="el" href="APInt_8cpp_source.html#l01672">llvm::APInt::sdiv()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01579">getAdjustedPtr()</a>.</p>

</div>
</div>
<a id="a20222f2e0fce0e91374ec5ce5b1d9c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20222f2e0fce0e91374ec5ce5b1d9c7f">&#9670;&nbsp;</a></span>getNaturalGEPWithType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* getNaturalGEPWithType </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>BasePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>TargetTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classllvm_1_1Value.html">Value</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>Indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Twine.html">Twine</a>&#160;</td>
          <td class="paramname"><em>NamePrefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a natural GEP off of the BasePtr walking through Ty toward TargetTy without changing the offset of the pointer. </p>
<p>This routine assumes we've already established a properly offset GEP with Indices, and arrived at the Ty type. The goal is to continue to GEP with zero-indices down through type layers until we find one the same as TargetTy. If we can't find one with the same type, we at least try to use one with the same size. If none of that works, we just produce the GEP as indicated by Indices to have the correct offset. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01421">1421</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l01398">buildGEP()</a>, <a class="el" href="SmallVector_8h_source.html#l00129">llvm::SmallVectorTemplateCommon&lt; T, typename &gt;::end()</a>, <a class="el" href="SmallVector_8h_source.html#l00434">llvm::SmallVectorImpl&lt; T &gt;::erase()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00687">llvm::DataLayout::getIndexTypeSizeInBits()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Type_8h_source.html#l00224">llvm::Type::isPointerTy()</a>, and <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T, bool &gt;::push_back()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01465">getNaturalGEPRecursively()</a>.</p>

</div>
</div>
<a id="abe75ff888b6a7ee2836aa6c8f33984c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe75ff888b6a7ee2836aa6c8f33984c1">&#9670;&nbsp;</a></span>getTypePartition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Type.html">Type</a>* getTypePartition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to find a partition of the aggregate type passed in for a given offset and size. </p>
<p>This recurses through the aggregate type and tries to compute a subtype based on the offset and size. When the offset and size span a sub-section of an array, it will even compute a new array type for that sub-section, and the same for structs.</p>
<p>Note that this routine is very strict and tries to find a partition of the type which produces the <em>exact</em> right offset and size. It is not forgiving when the size or offset cause either end of type-based partition to be off. Also, this is a best-effort routine. It is reasonable to give up and not return a type if necessary. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l03506">3506</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SmallVector_8h_source.html#l00166">llvm::SmallVectorTemplateCommon&lt; T &gt;::back()</a>, <a class="el" href="SROA_8cpp_source.html#l00248">llvm::sroa::AllocaSlices::begin()</a>, <a class="el" href="SROA_8cpp_source.html#l00409">llvm::sroa::Partition::begin()</a>, <a class="el" href="SROA_8cpp_source.html#l00381">llvm::sroa::Partition::beginOffset()</a>, <a class="el" href="NVVMIntrRange_8cpp_source.html#l00068">C</a>, <a class="el" href="SetVector_8h_source.html#l00215">llvm::SetVector&lt; T, SmallVector&lt; T, N &gt;, SmallDenseSet&lt; T, N &gt; &gt;::clear()</a>, <a class="el" href="Alignment_8h_source.html#l00215">llvm::commonAlignment()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00709">llvm::Instruction::copyMetadata()</a>, <a class="el" href="DenseMap_8h_source.html#l00145">llvm::DenseMapBase&lt; SmallDenseMap&lt; KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT &gt;, KeyT, ValueT, KeyInfoT, BucketT &gt;::count()</a>, <a class="el" href="SmallPtrSet_8h_source.html#l00381">llvm::SmallPtrSetImpl&lt; PtrType &gt;::count()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="Casting_8h_source.html#l00332">llvm::dyn_cast()</a>, <a class="el" href="BuiltinGCs_8cpp.html#a6742d2e0a668baf1196ec69e158d5f15">E</a>, <a class="el" href="DerivedTypes_8h_source.html#l00340">llvm::StructType::element_begin()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00341">llvm::StructType::element_end()</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, <a class="el" href="TinyPtrVector_8h_source.html#l00163">llvm::TinyPtrVector&lt; EltTy &gt;::empty()</a>, <a class="el" href="DenseMap_8h_source.html#l00082">llvm::DenseMapBase&lt; SmallDenseMap&lt; KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT &gt;, KeyT, ValueT, KeyInfoT, BucketT &gt;::end()</a>, <a class="el" href="SmallVector_8h_source.html#l00129">llvm::SmallVectorTemplateCommon&lt; T &gt;::end()</a>, <a class="el" href="SROA_8cpp_source.html#l00249">llvm::sroa::AllocaSlices::end()</a>, <a class="el" href="SROA_8cpp_source.html#l00410">llvm::sroa::Partition::end()</a>, <a class="el" href="SROA_8cpp_source.html#l00386">llvm::sroa::Partition::endOffset()</a>, <a class="el" href="SROA_8cpp_source.html#l00259">llvm::sroa::AllocaSlices::erase()</a>, <a class="el" href="SmallVector_8h_source.html#l00434">llvm::SmallVectorImpl&lt; T &gt;::erase()</a>, <a class="el" href="DenseMap_8h_source.html#l00150">llvm::DenseMapBase&lt; SmallDenseMap&lt; KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT &gt;, KeyT, ValueT, KeyInfoT, BucketT &gt;::find()</a>, <a class="el" href="SROA_8cpp_source.html#l01128">findCommonType()</a>, <a class="el" href="Local_8cpp_source.html#l01502">llvm::FindDbgAddrUses()</a>, <a class="el" href="TinyPtrVector_8h_source.html#l00230">llvm::TinyPtrVector&lt; EltTy &gt;::front()</a>, <a class="el" href="Type_8cpp_source.html#l00346">llvm::StructType::get()</a>, <a class="el" href="Type_8cpp_source.html#l00587">llvm::ArrayType::get()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00755">llvm::DataLayout::getABITypeAlignment()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00607">llvm::PointerType::getAddressSpace()</a>, <a class="el" href="SROA_8cpp_source.html#l01684">getAdjustedAlignment()</a>, <a class="el" href="SROA_8cpp_source.html#l01579">getAdjustedPtr()</a>, <a class="el" href="Instructions_8h_source.html#l00112">llvm::AllocaInst::getAlignment()</a>, <a class="el" href="Instructions_8h_source.html#l00105">llvm::AllocaInst::getAllocatedType()</a>, <a class="el" href="Type_8h_source.html#l00368">llvm::Type::getArrayElementType()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00071">llvm::IntegerType::getBitWidth()</a>, <a class="el" href="Type_8h_source.html#l00130">llvm::Type::getContext()</a>, <a class="el" href="Module_8cpp_source.html#l00369">llvm::Module::getDataLayout()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00331">llvm::Instruction::getDebugLoc()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00080">llvm::StructLayout::getElementContainingOffset()</a>, <a class="el" href="DataLayout_8h_source.html#l00607">llvm::StructLayout::getElementOffset()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00351">llvm::StructType::getElementType()</a>, <a class="el" href="IntrinsicInst_8h_source.html#l00105">llvm::DbgVariableIntrinsic::getExpression()</a>, <a class="el" href="DataLayout_8h_source.html#l00402">llvm::DataLayout::getIndexSizeInBits()</a>, <a class="el" href="Type_8cpp_source.html#l00178">llvm::Type::getInt8Ty()</a>, <a class="el" href="Type_8cpp_source.html#l00184">llvm::Type::getIntNTy()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00055">llvm::Instruction::getModule()</a>, <a class="el" href="Value_8cpp_source.html#l00215">llvm::Value::getName()</a>, <a class="el" href="User_8h_source.html#l00182">llvm::User::getOperandUse()</a>, <a class="el" href="Instructions_8h_source.html#l00301">llvm::LoadInst::getPointerAddressSpace()</a>, <a class="el" href="Instructions_8h_source.html#l00435">llvm::StoreInst::getPointerAddressSpace()</a>, <a class="el" href="Instructions_8h_source.html#l00295">llvm::LoadInst::getPointerOperand()</a>, <a class="el" href="Instructions_8h_source.html#l00429">llvm::StoreInst::getPointerOperand()</a>, <a class="el" href="Instructions_8h_source.html#l00297">llvm::LoadInst::getPointerOperandIndex()</a>, <a class="el" href="Instructions_8h_source.html#l00431">llvm::StoreInst::getPointerOperandIndex()</a>, <a class="el" href="Type_8cpp_source.html#l00659">llvm::Type::getPointerTo()</a>, <a class="el" href="DataLayout_8h_source.html#l00593">llvm::StructLayout::getSizeInBytes()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00613">llvm::DataLayout::getStructLayout()</a>, <a class="el" href="Instructions_8h_source.html#l00096">llvm::AllocaInst::getType()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00486">llvm::DataLayout::getTypeAllocSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00624">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="Instructions_8h_source.html#l00426">llvm::StoreInst::getValueOperand()</a>, <a class="el" href="DataLayout_8h_source.html#l00508">llvm::DataLayout::getValueOrABITypeAlignment()</a>, <a class="el" href="IntrinsicInst_8h_source.html#l00101">llvm::DbgVariableIntrinsic::getVariable()</a>, <a class="el" href="Value_8h_source.html#l00433">llvm::Value::hasOneUse()</a>, <a class="el" href="MD5_8cpp_source.html#l00058">I</a>, <a class="el" href="DenseMap_8h_source.html#l00195">llvm::DenseMapBase&lt; SmallDenseMap&lt; KeyT, ValueT, InlineBuckets, KeyInfoT, BucketT &gt;, KeyT, ValueT, KeyInfoT, BucketT &gt;::insert()</a>, <a class="el" href="SROA_8cpp_source.html#l00266">llvm::sroa::AllocaSlices::insert()</a>, <a class="el" href="SmallPtrSet_8h_source.html#l00370">llvm::SmallPtrSetImpl&lt; PtrType &gt;::insert()</a>, <a class="el" href="Type_8h_source.html#l00221">llvm::Type::isArrayTy()</a>, <a class="el" href="Type_8h_source.html#l00197">llvm::Type::isIntegerTy()</a>, <a class="el" href="SROA_8cpp_source.html#l02085">isIntegerWideningViable()</a>, <a class="el" href="DataLayout_8h_source.html#l00254">llvm::DataLayout::isLegalInteger()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00298">llvm::StructType::isPacked()</a>, <a class="el" href="SROA_8cpp_source.html#l01195">isSafePHIToSpeculate()</a>, <a class="el" href="SROA_8cpp_source.html#l01331">isSafeSelectToSpeculate()</a>, <a class="el" href="SROA_8cpp_source.html#l01882">isVectorPromotionViable()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="ArrayRef_8h_source.html#l00460">llvm::makeArrayRef()</a>, <a class="el" href="RISCVBaseInfo_8h_source.html#l00093">llvm::RISCVFenceField::O</a>, <a class="el" href="classllvm_1_1sroa_1_1AllocaSlices.html#ab0fa7fd7c0ff766d70d16fcd6cf8d44b">llvm::sroa::AllocaSlices::partitions()</a>, <a class="el" href="classllvm_1_1sroa_1_1AllocaSlices.html#aea43ee5732092522ecfa6bdf2e26088e">llvm::sroa::AllocaSlices::print()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T &gt;::push_back()</a>, <a class="el" href="STLExtras_8h_source.html#l01222">llvm::remove_if()</a>, <a class="el" href="SmallBitVector_8h_source.html#l00398">llvm::SmallBitVector::reset()</a>, <a class="el" href="VirtRegMap_8cpp_source.html#l00220">Rewriter</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00328">llvm::Instruction::setDebugLoc()</a>, <a class="el" href="SIInstrInfo_8cpp_source.html#l06317">SI</a>, <a class="el" href="Profile_8cpp_source.html#l00046">Size</a>, <a class="el" href="SROA_8cpp_source.html#l00391">llvm::sroa::Partition::size()</a>, <a class="el" href="STLExtras_8h_source.html#l01114">llvm::sort()</a>, <a class="el" href="SROA_8cpp_source.html#l00418">llvm::sroa::Partition::splitSliceTails()</a>, <a class="el" href="SROA_8cpp_source.html#l03468">stripAggregateTypeWrapping()</a>, <a class="el" href="Value_8cpp_source.html#l00605">llvm::Value::stripInBoundsOffsets()</a>, <a class="el" href="Value_8h_source.html#l00396">llvm::Value::user_begin()</a>, <a class="el" href="Value_8h_source.html#l00420">llvm::Value::users()</a>, and <a class="el" href="Alignment_8h_source.html#l00086">llvm::Align::value()</a>.</p>

</div>
</div>
<a id="a786d5a99befacdb30b3d3b5c3b07bd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786d5a99befacdb30b3d3b5c3b07bd30">&#9670;&nbsp;</a></span>INITIALIZE_PASS_BEGIN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INITIALIZE_PASS_BEGIN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1sroa_1_1SROALegacyPass.html">SROALegacyPass</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;sroa&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Scalar Replacement Of <a class="el" href="SROA_8cpp.html#a5b3f8e5f6c512fe6a5059dd0c51aec95">Aggregates</a>&quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="LoadStoreVectorizer_8cpp.html#a1321ae04c732793cd2d0ee2db36636ca">false</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="LoadStoreVectorizer_8cpp.html#a1321ae04c732793cd2d0ee2db36636ca">false</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l04653">llvm::createSROAPass()</a>.</p>

</div>
</div>
<a id="a7febebe786555d6e0d07ca0f86e294c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7febebe786555d6e0d07ca0f86e294c1">&#9670;&nbsp;</a></span>insertInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* insertInteger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>Offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02150">2150</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00071">llvm::IntegerType::getBitWidth()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00454">llvm::DataLayout::getTypeStoreSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00233">llvm::DataLayout::isBigEndian()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, and <a class="el" href="BitmaskEnum_8h_source.html#l00080">llvm::BitmaskEnumDetail::Mask()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l02346">llvm::sroa::AllocaSliceRewriter::visit()</a>.</p>

</div>
</div>
<a id="a42c6a2faff923f431932c6d33cf4092b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c6a2faff923f431932c6d33cf4092b">&#9670;&nbsp;</a></span>insertVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Value.html">Value</a>* insertVector </td>
          <td>(</td>
          <td class="paramtype">IRBuilderTy &amp;&#160;</td>
          <td class="paramname"><em>IRB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>Old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Value.html">Value</a> *&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classunsigned.html">unsigned</a>&#160;</td>
          <td class="paramname"><em>BeginIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1Twine.html">Twine</a> &amp;&#160;</td>
          <td class="paramname"><em>Name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02207">2207</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SmallVector_8h_source.html#l00339">llvm::SmallVectorImpl&lt; T &gt;::clear()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="Casting_8h_source.html#l00332">llvm::dyn_cast()</a>, <a class="el" href="Constants_8cpp_source.html#l01161">llvm::ConstantVector::get()</a>, <a class="el" href="Constants_8cpp_source.html#l01514">llvm::UndefValue::get()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00398">llvm::SequentialType::getNumElements()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="BitmaskEnum_8h_source.html#l00080">llvm::BitmaskEnumDetail::Mask()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T &gt;::push_back()</a>, and <a class="el" href="SmallVector_8h_source.html#l00369">llvm::SmallVectorImpl&lt; T &gt;::reserve()</a>.</p>

<p class="reference">Referenced by <a class="el" href="HexagonISelLowering_8h_source.html#l00330">llvm::HexagonTargetLowering::shouldExpandAtomicRMWInIR()</a>, and <a class="el" href="SROA_8cpp_source.html#l02346">llvm::sroa::AllocaSliceRewriter::visit()</a>.</p>

</div>
</div>
<a id="a7fd9ee96f281dd94ed4119c2e45836bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd9ee96f281dd94ed4119c2e45836bf">&#9670;&nbsp;</a></span>isIntegerWideningViable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isIntegerWideningViable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>AllocaTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the given alloca partition's integer operations can be widened to promotable ones. </p>
<p>This is a quick test to check whether we can rewrite the integer loads and stores to a particular alloca into wider loads and stores and be able to promote the resulting alloca. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l02085">2085</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l00409">llvm::sroa::Partition::begin()</a>, <a class="el" href="SROA_8cpp_source.html#l01706">canConvertValue()</a>, <a class="el" href="SROA_8cpp_source.html#l00410">llvm::sroa::Partition::end()</a>, <a class="el" href="SROA_8cpp_source.html#l04659">false</a>, <a class="el" href="Type_8h_source.html#l00130">llvm::Type::getContext()</a>, <a class="el" href="Type_8cpp_source.html#l00184">llvm::Type::getIntNTy()</a>, <a class="el" href="DataLayout_8h_source.html#l00624">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="DataLayout_8h_source.html#l00466">llvm::DataLayout::getTypeStoreSizeInBits()</a>, <a class="el" href="SROA_8cpp_source.html#l01998">isIntegerWideningViableForSlice()</a>, <a class="el" href="DataLayout_8h_source.html#l00254">llvm::DataLayout::isLegalInteger()</a>, and <a class="el" href="DerivedTypes_8h_source.html#l00052">llvm::IntegerType::MAX_INT_BITS</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03506">getTypePartition()</a>.</p>

</div>
</div>
<a id="a593afa69fb7cfbb4506f605bd785f923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593afa69fb7cfbb4506f605bd785f923">&#9670;&nbsp;</a></span>isIntegerWideningViableForSlice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isIntegerWideningViableForSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Slice &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>AllocBeginOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>AllocaTy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>WholeAllocaOp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether a slice of an alloca is valid for integer widening. </p>
<p>This implements the necessary checking for the <code>isIntegerWideningViable</code> test below on a single slice of the alloca. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01998">1998</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SROA_8cpp_source.html#l01706">canConvertValue()</a>, <a class="el" href="DataLayout_8h_source.html#l00454">llvm::DataLayout::getTypeStoreSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00466">llvm::DataLayout::getTypeStoreSizeInBits()</a>, <a class="el" href="IRTranslator_8cpp_source.html#l00093">MI</a>, and <a class="el" href="Profile_8cpp_source.html#l00046">Size</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l02085">isIntegerWideningViable()</a>.</p>

</div>
</div>
<a id="aab37469c4748a495736ad163ac54e776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab37469c4748a495736ad163ac54e776">&#9670;&nbsp;</a></span>isSafePHIToSpeculate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isSafePHIToSpeculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;&#160;</td>
          <td class="paramname"><em>PN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>PHI instructions that use an alloca and are subsequently loaded can be rewritten to load both input pointers in the pred blocks and then PHI the results, allowing the load of the alloca to be promoted. </p>
<p>From this: P2 = phi [i32* Alloca, i32* Other] V = load i32* P2 to: V1 = load i32* Alloca -&gt; will be mem2reg'd ... V2 = load i32* Other ... V = phi [i32 V1, i32 V2]</p>
<p>We can do this to a select if its only uses are loads and if the operands to the select can be loaded unconditionally.</p>
<p>FIXME: This should be hoisted into a generic utility, likely in Transforms/Util/Local.h </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01195">1195</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00332">llvm::dyn_cast()</a>, <a class="el" href="Instructions_8h_source.html#l00244">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Module_8cpp_source.html#l00369">llvm::Module::getDataLayout()</a>, <a class="el" href="Instructions_8h_source.html#l02670">llvm::PHINode::getIncomingBlock()</a>, <a class="el" href="Instructions_8h_source.html#l02650">llvm::PHINode::getIncomingValue()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00687">llvm::DataLayout::getIndexTypeSizeInBits()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00055">llvm::Instruction::getModule()</a>, <a class="el" href="Instructions_8h_source.html#l02646">llvm::PHINode::getNumIncomingValues()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00645">llvm::Instruction::getNumSuccessors()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00066">llvm::Instruction::getParent()</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00144">llvm::BasicBlock::getTerminator()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="DataLayout_8h_source.html#l00454">llvm::DataLayout::getTypeStoreSize()</a>, <a class="el" href="Loads_8cpp_source.html#l00262">llvm::isSafeToLoadUnconditionally()</a>, <a class="el" href="Instructions_8h_source.html#l00287">llvm::LoadInst::isSimple()</a>, <a class="el" href="Alignment_8h_source.html#l00390">llvm::max()</a>, <a class="el" href="IR_2Instruction_8h_source.html#l00582">llvm::Instruction::mayHaveSideEffects()</a>, <a class="el" href="Profile_8cpp_source.html#l00046">Size</a>, <a class="el" href="APInt_8h_source.html#l01205">llvm::APInt::ult()</a>, and <a class="el" href="Value_8h_source.html#l00420">llvm::Value::users()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03506">getTypePartition()</a>.</p>

</div>
</div>
<a id="a93e373cfa6ef51df8f9c43dc8b8539c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e373cfa6ef51df8f9c43dc8b8539c0">&#9670;&nbsp;</a></span>isSafeSelectToSpeculate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isSafeSelectToSpeculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;&#160;</td>
          <td class="paramname"><em>SI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select instructions that use an alloca and are subsequently loaded can be rewritten to load both input pointers and then select between the result, allowing the load of the alloca to be promoted. </p>
<p>From this: P2 = select i1 cond, i32* Alloca, i32* Other V = load i32* P2 to: V1 = load i32* Alloca -&gt; will be mem2reg'd V2 = load i32* Other V = select i1 cond, i32 V1, i32 V2</p>
<p>We can do this to a select if its only uses are loads and if the operand to the select can be loaded unconditionally. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01331">1331</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="Casting_8h_source.html#l00332">llvm::dyn_cast()</a>, <a class="el" href="Instructions_8h_source.html#l00244">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Module_8cpp_source.html#l00369">llvm::Module::getDataLayout()</a>, <a class="el" href="Instructions_8h_source.html#l01770">llvm::SelectInst::getFalseValue()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00055">llvm::Instruction::getModule()</a>, <a class="el" href="Instructions_8h_source.html#l01769">llvm::SelectInst::getTrueValue()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Loads_8cpp_source.html#l00262">llvm::isSafeToLoadUnconditionally()</a>, <a class="el" href="Instructions_8h_source.html#l00287">llvm::LoadInst::isSimple()</a>, and <a class="el" href="Value_8h_source.html#l00420">llvm::Value::users()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03506">getTypePartition()</a>.</p>

</div>
</div>
<a id="a458f8b1b5c1beb71a2f7b1e1c151741d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458f8b1b5c1beb71a2f7b1e1c151741d">&#9670;&nbsp;</a></span>isVectorPromotionViable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1VectorType.html">VectorType</a>* isVectorPromotionViable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the given alloca partitioning and range of slices can be promoted to a vector. </p>
<p>This is a quick test to check whether we can rewrite a particular alloca partition (and its newly formed alloca) into a vector alloca with only whole-vector loads and stores such that it could be promoted to a vector SSA value. We only can ensure this for a limited set of operations, and we don't want to do the rewrites unless we are confident that the result will be promotable, so we have an early test here. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01882">1882</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SmallVector_8h_source.html#l00127">llvm::SmallVectorTemplateCommon&lt; T &gt;::begin()</a>, <a class="el" href="SmallVector_8h_source.html#l00339">llvm::SmallVectorImpl&lt; T &gt;::clear()</a>, <a class="el" href="SmallVector_8h_source.html#l00055">llvm::SmallVectorBase::empty()</a>, <a class="el" href="SmallVector_8h_source.html#l00129">llvm::SmallVectorTemplateCommon&lt; T &gt;::end()</a>, <a class="el" href="SmallVector_8h_source.html#l00434">llvm::SmallVectorImpl&lt; T &gt;::erase()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00399">llvm::SequentialType::getElementType()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00398">llvm::SequentialType::getNumElements()</a>, <a class="el" href="DataLayout_8h_source.html#l00624">llvm::DataLayout::getTypeSizeInBits()</a>, <a class="el" href="Type_8h_source.html#l00197">llvm::Type::isIntegerTy()</a>, <a class="el" href="SROA_8cpp_source.html#l01807">isVectorPromotionViableForSlice()</a>, <a class="el" href="SmallVector_8h_source.html#l00211">llvm::SmallVectorTemplateBase&lt; T &gt;::push_back()</a>, <a class="el" href="STLExtras_8h_source.html#l01222">llvm::remove_if()</a>, and <a class="el" href="STLExtras_8h_source.html#l01114">llvm::sort()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03506">getTypePartition()</a>.</p>

</div>
</div>
<a id="ab4c31035e44c7bda618eb2eb81dcf314"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c31035e44c7bda618eb2eb81dcf314">&#9670;&nbsp;</a></span>isVectorPromotionViableForSlice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> isVectorPromotionViableForSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1sroa_1_1Partition.html">Partition</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> Slice &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1VectorType.html">VectorType</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ElementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether the given slice use can be promoted to a vector. </p>
<p>This function is called to test each entry in a partition which is slated for a single slice. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01807">1807</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="SROA_8cpp_source.html#l00381">llvm::sroa::Partition::beginOffset()</a>, <a class="el" href="SROA_8cpp_source.html#l01706">canConvertValue()</a>, <a class="el" href="SROA_8cpp_source.html#l00386">llvm::sroa::Partition::endOffset()</a>, <a class="el" href="Type_8cpp_source.html#l00614">llvm::VectorType::get()</a>, <a class="el" href="Type_8h_source.html#l00130">llvm::Type::getContext()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00399">llvm::SequentialType::getElementType()</a>, <a class="el" href="Type_8cpp_source.html#l00184">llvm::Type::getIntNTy()</a>, <a class="el" href="DerivedTypes_8h_source.html#l00398">llvm::SequentialType::getNumElements()</a>, <a class="el" href="Type_8h_source.html#l00197">llvm::Type::isIntegerTy()</a>, <a class="el" href="Alignment_8h_source.html#l00390">llvm::max()</a>, and <a class="el" href="IRTranslator_8cpp_source.html#l00093">MI</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l01882">isVectorPromotionViable()</a>.</p>

</div>
</div>
<a id="aab38ec9ebc3b5d96a4b7ddcb11cfcd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab38ec9ebc3b5d96a4b7ddcb11cfcd58">&#9670;&nbsp;</a></span>speculatePHINodeLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void speculatePHINodeLoads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1PHINode.html">PHINode</a> &amp;&#160;</td>
          <td class="paramname"><em>PN</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01263">1263</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="Instructions_8h_source.html#l02704">llvm::PHINode::addIncoming()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00067">llvm::Instruction::eraseFromParent()</a>, <a class="el" href="TypeBasedAliasAnalysis_8cpp_source.html#l00523">llvm::Instruction::getAAMetadata()</a>, <a class="el" href="Instructions_8h_source.html#l00244">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Instructions_8h_source.html#l02670">llvm::PHINode::getIncomingBlock()</a>, <a class="el" href="Instructions_8h_source.html#l02650">llvm::PHINode::getIncomingValue()</a>, <a class="el" href="Value_8cpp_source.html#l00215">llvm::Value::getName()</a>, <a class="el" href="Instructions_8h_source.html#l02646">llvm::PHINode::getNumIncomingValues()</a>, <a class="el" href="BasicBlock_8cpp_source.html#l00144">llvm::BasicBlock::getTerminator()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="SparcInstrInfo_8h_source.html#l00032">llvm::SPII::Load</a>, <a class="el" href="DenseMap_8h_source.html#l00185">llvm::DenseMapBase&lt; DenseMap&lt; KeyT, ValueT, KeyInfoT, BucketT &gt;, KeyT, ValueT, KeyInfoT, BucketT &gt;::lookup()</a>, <a class="el" href="Value_8cpp_source.html#l00430">llvm::Value::replaceAllUsesWith()</a>, <a class="el" href="Metadata_8cpp_source.html#l01263">llvm::Instruction::setAAMetadata()</a>, <a class="el" href="Instructions_8cpp_source.html#l01340">llvm::LoadInst::setAlignment()</a>, <a class="el" href="Value_8h_source.html#l00343">llvm::Value::use_empty()</a>, and <a class="el" href="IR_2Instruction_8h_source.html#l00063">llvm::Instruction::user_back()</a>.</p>

</div>
</div>
<a id="a7493b7d3b84612687869f2c3afed924b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7493b7d3b84612687869f2c3afed924b">&#9670;&nbsp;</a></span>speculateSelectInstLoads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void speculateSelectInstLoads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SelectInst.html">SelectInst</a> &amp;&#160;</td>
          <td class="paramname"><em>SI</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l01355">1355</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="SILowerControlFlow_8cpp.html#a4868c5d81c5ccc98c47aeab6244346a0">assert()</a>, <a class="el" href="Debug_8cpp_source.html#l00132">llvm::dbgs()</a>, <a class="el" href="IR_2Instruction_8cpp_source.html#l00067">llvm::Instruction::eraseFromParent()</a>, <a class="el" href="TypeBasedAliasAnalysis_8cpp_source.html#l00523">llvm::Instruction::getAAMetadata()</a>, <a class="el" href="Instructions_8h_source.html#l00244">llvm::LoadInst::getAlignment()</a>, <a class="el" href="Instructions_8h_source.html#l01768">llvm::SelectInst::getCondition()</a>, <a class="el" href="Instructions_8h_source.html#l01770">llvm::SelectInst::getFalseValue()</a>, <a class="el" href="Value_8cpp_source.html#l00215">llvm::Value::getName()</a>, <a class="el" href="Instructions_8h_source.html#l01769">llvm::SelectInst::getTrueValue()</a>, <a class="el" href="Value_8h_source.html#l00246">llvm::Value::getType()</a>, <a class="el" href="Instructions_8h_source.html#l00287">llvm::LoadInst::isSimple()</a>, <a class="el" href="Debug_8h_source.html#l00122">LLVM_DEBUG</a>, <a class="el" href="Value_8cpp_source.html#l00430">llvm::Value::replaceAllUsesWith()</a>, <a class="el" href="Metadata_8cpp_source.html#l01263">llvm::Instruction::setAAMetadata()</a>, <a class="el" href="Instructions_8cpp_source.html#l01340">llvm::LoadInst::setAlignment()</a>, <a class="el" href="Value_8h_source.html#l00343">llvm::Value::use_empty()</a>, and <a class="el" href="IR_2Instruction_8h_source.html#l00063">llvm::Instruction::user_back()</a>.</p>

</div>
</div>
<a id="a618041bb2c6e95361ead0e45493039ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618041bb2c6e95361ead0e45493039ef">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumAllocasAnalyzed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of allocas analyzed <a class="el" href="MipsDelaySlotFiller_8cpp.html#ab83893112065dd5c28fe90cca10ebba4">for</a> <a class="el" href="CoroElide_8cpp.html#a292041ae3f27ed6664cde3fc074c932e">replacement</a>&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e323f27ddb83247b75a5b2d375d9216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e323f27ddb83247b75a5b2d375d9216">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumAllocaPartitions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of alloca partitions formed&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace0cc1a6f5d1eb652844d9752b238390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0cc1a6f5d1eb652844d9752b238390">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">MaxPartitionsPerAlloca&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Maximum number of partitions per alloca&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8043ffc0bf25bc77b88596ec2555d25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8043ffc0bf25bc77b88596ec2555d25f">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumAllocaPartitionUses&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of alloca partition uses rewritten&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab96dad8afe38ad77a313ecac3d1f151a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96dad8afe38ad77a313ecac3d1f151a">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">MaxUsesPerAllocaPartition&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Maximum number of uses of a partition&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcd84289002379062d3d99430eb946df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd84289002379062d3d99430eb946df">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumNewAllocas&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of&#160;</td>
          <td class="paramname"><em>new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">smaller allocas introduced&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd53eb32a458943eee0e59c868868419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd53eb32a458943eee0e59c868868419">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumPromoted&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of allocas promoted to <a class="el" href="MemorySSA_8cpp.html#a20a60bdac22b099d87d8cb0c1d554120">SSA</a> values&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1f1e2ef32da6004704b9dfd4d80482e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1f1e2ef32da6004704b9dfd4d80482e">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumLoadsSpeculated&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of loads speculated to allow promotion&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af559aec98fbf691ccd4c3233556cc618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af559aec98fbf691ccd4c3233556cc618">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumDeleted&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of <a class="el" href="LoadStoreVectorizer_8cpp.html#acc0655e462f1e67d046cd818e473c46e">instructions</a> deleted&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f794c154e83c0c1f7953596198faa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f794c154e83c0c1f7953596198faa8f">&#9670;&nbsp;</a></span>STATISTIC() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">STATISTIC </td>
          <td>(</td>
          <td class="paramtype">NumVectorized&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Number of vectorized aggregates&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac102ff32dace1cf8e8e6f9c9ec4d159c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac102ff32dace1cf8e8e6f9c9ec4d159c">&#9670;&nbsp;</a></span>stripAggregateTypeWrapping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1Type.html">Type</a>* stripAggregateTypeWrapping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AArch64PromoteConstant_8cpp.html#a90f8350fecae261c25be85d38b451bff">const</a> <a class="el" href="classllvm_1_1DataLayout.html">DataLayout</a> &amp;&#160;</td>
          <td class="paramname"><em>DL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Type.html">Type</a> *&#160;</td>
          <td class="paramname"><em>Ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strip aggregate type wrapping. </p>
<p>This removes no-op aggregate types wrapping an underlying type. It will strip as many layers of types as it can without changing either the type size or the allocated size. </p>

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l03468">3468</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">References <a class="el" href="DataLayout_8cpp_source.html#l00080">llvm::StructLayout::getElementContainingOffset()</a>, <a class="el" href="DataLayout_8cpp_source.html#l00613">llvm::DataLayout::getStructLayout()</a>, <a class="el" href="DataLayout_8h_source.html#l00486">llvm::DataLayout::getTypeAllocSize()</a>, <a class="el" href="DataLayout_8h_source.html#l00624">llvm::DataLayout::getTypeSizeInBits()</a>, and <a class="el" href="Type_8h_source.html#l00250">llvm::Type::isSingleValueType()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l03506">getTypePartition()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a5b3f8e5f6c512fe6a5059dd0c51aec95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b3f8e5f6c512fe6a5059dd0c51aec95">&#9670;&nbsp;</a></span>Aggregates</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar Replacement Of Aggregates</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l04659">4659</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

</div>
</div>
<a id="acc7a95cb9fb444faf77cd626f1b8128b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc7a95cb9fb444faf77cd626f1b8128b">&#9670;&nbsp;</a></span>false</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Scalar Replacement Of false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l04659">4659</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l02085">isIntegerWideningViable()</a>.</p>

</div>
</div>
<a id="a6990f15b9f29df6e8497b3e53875ccab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6990f15b9f29df6e8497b3e53875ccab">&#9670;&nbsp;</a></span>sroa</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sroa</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SROA_8cpp_source.html#l04659">4659</a> of file <a class="el" href="SROA_8cpp_source.html">SROA.cpp</a>.</p>

</div>
</div>
<a id="a577be81e94407739665be7332b4f9ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577be81e94407739665be7332b4f9ac0">&#9670;&nbsp;</a></span>SROARandomShuffleSlices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt;<a class="el" href="classbool.html">bool</a>&gt; SROARandomShuffleSlices(&quot;sroa-random-shuffle-slices&quot;, cl::init(<a class="el" href="LoadStoreVectorizer_8cpp.html#a1321ae04c732793cd2d0ee2db36636ca">false</a>), cl::Hidden)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hidden option to enable randomly shuffling the slices to help uncover instability in their order. </p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l00664">AllocaSlices::SliceBuilder::SliceBuilder()</a>.</p>

</div>
</div>
<a id="ac6da6bff872f9db9f549ab7dd6086a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6da6bff872f9db9f549ab7dd6086a61">&#9670;&nbsp;</a></span>SROAStrictInbounds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1cl_1_1opt.html">cl::opt</a>&lt;<a class="el" href="classbool.html">bool</a>&gt; SROAStrictInbounds(&quot;sroa-strict-inbounds&quot;, cl::init(<a class="el" href="LoadStoreVectorizer_8cpp.html#a1321ae04c732793cd2d0ee2db36636ca">false</a>), cl::Hidden)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hidden option to experiment with completely strict handling of inbounds GEPs. </p>

<p class="reference">Referenced by <a class="el" href="SROA_8cpp_source.html#l00664">AllocaSlices::SliceBuilder::SliceBuilder()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 24 2020 13:16:04 for LLVM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
