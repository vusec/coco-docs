<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class DevirtSCCRepeatedPass: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="page4005EAF9682199BA"><span>class DevirtSCCRepeatedPass</span></a></li></ul></nav><main class="content"><h1>class DevirtSCCRepeatedPass</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">template &lt;typename PassT&gt;
class DevirtSCCRepeatedPass { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>A helper that repeats an SCC pass each time an indirect call is refined to a direct call by that pass. While the CGSCC pass manager works to re-visit SCCs and RefSCCs as they change shape, we may also want to repeat an SCC pass if it simply refines an indirect call to a direct call, even if doing so does not alter the shape of the graph. Note that this only pertains to direct calls to functions where IPO across the SCC may be able to compute more precise results. For intrinsics, we assume scalar optimizations already can fully reason about them. This repetition has the potential to be very large however, as each one might refine a single call site. As a consequence, in practice we use an upper bound on the number of repetitions to limit things.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/CGSCCPassManager.h#L553">llvm/include/llvm/Analysis/CGSCCPassManager.h:553</a></p><h2>Templates</h2><dl><dt class="is-family-code"><b> PassT</b></dt></dl><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#13C7B3916CAB6705"><b>DevirtSCCRepeatedPass&lt;PassT&gt;</b></a>(PassT Pass, int MaxIterations)</li><li class="is-family-code">public llvm::PreservedAnalyses  <a href="#56D6E1B5F8632476"><b>run</b></a>(LazyCallGraph::SCC &amp; InitialC, llvm::CGSCCAnalysisManager &amp; AM, llvm::LazyCallGraph &amp; CG, llvm::CGSCCUpdateResult &amp; UR)</li></ul><h2>Methods</h2><h3 id="13C7B3916CAB6705"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#13C7B3916CAB6705">¶</a><code class="hdoc-function-code language-cpp">DevirtSCCRepeatedPass&lt;PassT&gt;(PassT Pass,
                             int MaxIterations)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/CGSCCPassManager.h#L556">llvm/include/llvm/Analysis/CGSCCPassManager.h:556</a></p><h4>Parameters</h4><dl><dt class="is-family-code">PassT<b> Pass</b></dt><dt class="is-family-code">int<b> MaxIterations</b></dt></dl><h3 id="56D6E1B5F8632476"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#56D6E1B5F8632476">¶</a><code class="hdoc-function-code language-cpp"><a href="r9EDCE8A1E6A8CDD6.html">llvm::PreservedAnalyses</a> run(
    <a href="rF98C323CFA756C9F.html">LazyCallGraph::SCC</a>&amp; InitialC,
    <a href="rB9A0ED74935D969B.html">llvm::CGSCCAnalysisManager</a>&amp; AM,
    <a href="r032268D0BE579A12.html">llvm::LazyCallGraph</a>&amp; CG,
    <a href="rC726AF9F91248CF7.html">llvm::CGSCCUpdateResult</a>&amp; UR)</code></pre></h3><h4>Description</h4><p>Runs the wrapped pass up to \c MaxIterations on the SCC, iterating whenever an indirect call is refined.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/CGSCCPassManager.h#L561">llvm/include/llvm/Analysis/CGSCCPassManager.h:561</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rF98C323CFA756C9F.html">LazyCallGraph::SCC</a>&amp;<b> InitialC</b></dt><dt class="is-family-code"><a href="rB9A0ED74935D969B.html">llvm::CGSCCAnalysisManager</a>&amp;<b> AM</b></dt><dt class="is-family-code"><a href="r032268D0BE579A12.html">llvm::LazyCallGraph</a>&amp;<b> CG</b></dt><dt class="is-family-code"><a href="rC726AF9F91248CF7.html">llvm::CGSCCUpdateResult</a>&amp;<b> UR</b></dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>