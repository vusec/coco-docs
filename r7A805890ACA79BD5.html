<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class LazyCallGraph::RefSCC: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li><a href="r032268D0BE579A12.html"><span>class LazyCallGraph</span></a></li><li class="is-active"><a aria-current="page7A805890ACA79BD5"><span>class LazyCallGraph::RefSCC</span></a></li></ul></nav><main class="content"><h1>class LazyCallGraph::RefSCC</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class LazyCallGraph::RefSCC { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>A RefSCC of the call graph. This models a Strongly Connected Component of function reference edges in the call graph. As opposed to actual SCCs, these can be used to scope subgraphs of the module which are independent from other subgraphs of the module because they do not reference it in any way. This is also the unit where we do mutation of the graph in order to restrict mutations to those which don&apos;t violate this independence. A RefSCC contains a DAG of actual SCCs. All the nodes within the RefSCC are necessarily within some actual SCC that nests within it. Since a direct call *is* a reference, there will always be at least one RefSCC around any SCC.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L547">llvm/include/llvm/Analysis/LazyCallGraph.h:547</a></p><h2>Method Overview</h2><ul><li class="is-family-code">public llvm::LazyCallGraph::RefSCC::iterator  <a href="#E8222B00F17E2E43"><b>begin</b></a>() const</li><li class="is-family-code">public llvm::LazyCallGraph::RefSCC::iterator  <a href="#0AEBD17391B5FAF4"><b>end</b></a>() const</li><li class="is-family-code">public llvm::LazyCallGraph::RefSCC::iterator  <a href="#8F11D585F1F12593"><b>find</b></a>(llvm::LazyCallGraph::SCC &amp; C) const</li><li class="is-family-code">public std::string  <a href="#B1EF0CB807EE180B"><b>getName</b></a>() const</li><li class="is-family-code">public SmallVector&lt;llvm::LazyCallGraph::RefSCC *, 1&gt;  <a href="#FAF43CD78B35D48B"><b>insertIncomingRefEdge</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li><li class="is-family-code">public void  <a href="#0FD411E6DDF9EA70"><b>insertInternalRefEdge</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li><li class="is-family-code">public void  <a href="#E5723FF8D88FA13F"><b>insertOutgoingEdge</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN, Edge::Kind EK)</li><li class="is-family-code">public void  <a href="#5A45D85996030114"><b>insertTrivialCallEdge</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li><li class="is-family-code">public void  <a href="#8A7063126344B3AA"><b>insertTrivialRefEdge</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li><li class="is-family-code">public bool  <a href="#CC8D70D22C56FABD"><b>isAncestorOf</b></a>(const llvm::LazyCallGraph::RefSCC &amp; RC) const</li><li class="is-family-code">public bool  <a href="#98A1E326983B69B0"><b>isChildOf</b></a>(const llvm::LazyCallGraph::RefSCC &amp; RC) const</li><li class="is-family-code">public bool  <a href="#F3801BD137FBB371"><b>isDescendantOf</b></a>(const llvm::LazyCallGraph::RefSCC &amp; RC) const</li><li class="is-family-code">public bool  <a href="#E79F1E2A42C163C7"><b>isParentOf</b></a>(const llvm::LazyCallGraph::RefSCC &amp; RC) const</li><li class="is-family-code">public SmallVector&lt;llvm::LazyCallGraph::RefSCC *, 1&gt;  <a href="#26A3A19A3E5B8CEB"><b>removeInternalRefEdge</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, ArrayRef&lt;llvm::LazyCallGraph::Node *&gt; TargetNs)</li><li class="is-family-code">public void  <a href="#115C9037A8966C22"><b>removeOutgoingEdge</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li><li class="is-family-code">public void  <a href="#BECCB1FF9C67EEA7"><b>replaceNodeFunction</b></a>(llvm::LazyCallGraph::Node &amp; N, llvm::Function &amp; NewF)</li><li class="is-family-code">public ssize_t  <a href="#9B58415581D4F954"><b>size</b></a>() const</li><li class="is-family-code">public bool  <a href="#C544621E0A12738A"><b>switchInternalEdgeToCall</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN, function_ref&lt;void (ArrayRef&lt;llvm::LazyCallGraph::SCC *&gt;)&gt; MergeCB = {})</li><li class="is-family-code">public iterator_range&lt;llvm::LazyCallGraph::RefSCC::iterator&gt;  <a href="#01093DBE851FFFF6"><b>switchInternalEdgeToRef</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li><li class="is-family-code">public void  <a href="#0BA2C17DAF1C8F55"><b>switchOutgoingEdgeToCall</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li><li class="is-family-code">public void  <a href="#D4F9C68086E6515D"><b>switchOutgoingEdgeToRef</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li><li class="is-family-code">public void  <a href="#2031EA5FBD0CCE26"><b>switchTrivialInternalEdgeToRef</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li></ul><h2>Methods</h2><h3 id="E8222B00F17E2E43"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E8222B00F17E2E43">¶</a><code class="hdoc-function-code language-cpp"><a href="r7385B6F0EAD8BA6D.html">llvm::LazyCallGraph::RefSCC::iterator</a> begin()
    const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L619">llvm/include/llvm/Analysis/LazyCallGraph.h:619</a></p><h3 id="0AEBD17391B5FAF4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0AEBD17391B5FAF4">¶</a><code class="hdoc-function-code language-cpp"><a href="r7385B6F0EAD8BA6D.html">llvm::LazyCallGraph::RefSCC::iterator</a> end() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L620">llvm/include/llvm/Analysis/LazyCallGraph.h:620</a></p><h3 id="8F11D585F1F12593"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8F11D585F1F12593">¶</a><code class="hdoc-function-code language-cpp"><a href="r7385B6F0EAD8BA6D.html">llvm::LazyCallGraph::RefSCC::iterator</a> find(
    <a href="rF98C323CFA756C9F.html">llvm::LazyCallGraph::SCC</a>&amp; C) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L626">llvm/include/llvm/Analysis/LazyCallGraph.h:626</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rF98C323CFA756C9F.html">llvm::LazyCallGraph::SCC</a>&amp;<b> C</b></dt></dl><h3 id="B1EF0CB807EE180B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B1EF0CB807EE180B">¶</a><code class="hdoc-function-code language-cpp"><a href="https://en.cppreference.com/w/cpp/string/basic_string">std::string</a> getName() const</code></pre></h3><h4>Description</h4><p>Provide a short name by printing this RefSCC to a std::string. This copes with the fact that we don&apos;t have a name per-se for an RefSCC while still making the use of this in debugging and logging useful.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L662">llvm/include/llvm/Analysis/LazyCallGraph.h:662</a></p><h3 id="FAF43CD78B35D48B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FAF43CD78B35D48B">¶</a><code class="hdoc-function-code language-cpp"><a href="r62CD0592E97953B6.html">SmallVector</a>&lt;llvm::LazyCallGraph::RefSCC*, 1&gt;
insertIncomingRefEdge(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>Insert an edge whose source is in a descendant RefSCC and target is in this RefSCC. There must be an existing path from the target to the source in this case. NB! This is has the potential to be a very expensive function. It inherently forms a cycle in the prior RefSCC DAG and we have to merge RefSCCs to resolve that cycle. But finding all of the RefSCCs which participate in the cycle can in the worst case require traversing every RefSCC in the graph. Every attempt is made to avoid that, but passes must still exercise caution calling this routine repeatedly. Also note that this can only insert ref edges. In order to insert a call edge, first insert a ref edge and then switch it to a call edge. These are intentionally kept as separate interfaces because each step of the operation invalidates a different set of data structures. This returns all the RefSCCs which were merged into the this RefSCC (the target&apos;s). This allows callers to invalidate any cached information. FIXME: We could possibly optimize this quite a bit for cases where the caller and callee are very nearby in the graph. See comments in the implementation for details, but that use case might impact users.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L788">llvm/include/llvm/Analysis/LazyCallGraph.h:788</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl><h3 id="0FD411E6DDF9EA70"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0FD411E6DDF9EA70">¶</a><code class="hdoc-function-code language-cpp">void insertInternalRefEdge(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>Insert a ref edge from one node in this RefSCC to another in this RefSCC. This is always a trivial operation as it doesn&apos;t change any part of the graph structure besides connecting the two nodes. Note that we don&apos;t support directly inserting internal *call* edges because that could change the graph structure and requires returning information about what became invalid. As a consequence, the pattern should be to first insert the necessary ref edge, and then to switch it to a call edge if needed and handle any invalidation that results. See the \c switchInternalEdgeToCall routine for details.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L753">llvm/include/llvm/Analysis/LazyCallGraph.h:753</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl><h3 id="E5723FF8D88FA13F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E5723FF8D88FA13F">¶</a><code class="hdoc-function-code language-cpp">void insertOutgoingEdge(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN,
    Edge::Kind EK)</code></pre></h3><h4>Description</h4><p>Insert an edge whose parent is in this RefSCC and child is in some child RefSCC. There must be an existing path from the \p SourceN to the \p TargetN. This operation is inexpensive and does not change the set of SCCs and RefSCCs in the graph.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L761">llvm/include/llvm/Analysis/LazyCallGraph.h:761</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt><dt class="is-family-code">Edge::Kind<b> EK</b></dt></dl><h3 id="5A45D85996030114"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5A45D85996030114">¶</a><code class="hdoc-function-code language-cpp">void insertTrivialCallEdge(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>A convenience wrapper around the above to handle trivial cases of inserting a new call edge. This is trivial whenever the target is in the same SCC as the source or the edge is an outgoing edge to some descendant SCC. In these cases there is no change to the cyclic structure of SCCs or RefSCCs. To further make calling this convenient, it also handles inserting already existing edges.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L853">llvm/include/llvm/Analysis/LazyCallGraph.h:853</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl><h3 id="8A7063126344B3AA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8A7063126344B3AA">¶</a><code class="hdoc-function-code language-cpp">void insertTrivialRefEdge(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>A convenience wrapper around the above to handle trivial cases of inserting a new ref edge. This is trivial whenever the target is in the same RefSCC as the source or the edge is an outgoing edge to some descendant RefSCC. In these cases there is no change to the cyclic structure of the RefSCCs. To further make calling this convenient, it also handles inserting already existing edges.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L864">llvm/include/llvm/Analysis/LazyCallGraph.h:864</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl><h3 id="CC8D70D22C56FABD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CC8D70D22C56FABD">¶</a><code class="hdoc-function-code language-cpp">bool isAncestorOf(
    const <a href="r7A805890ACA79BD5.html">llvm::LazyCallGraph::RefSCC</a>&amp; RC) const</code></pre></h3><h4>Description</h4><p>Test if this RefSCC is an ancestor of \a RC. CAUTION: This method walks the directed graph of edges as far as necessary to find a possible path to the argument. In the worst case this may walk the entire graph and can be extremely expensive.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L641">llvm/include/llvm/Analysis/LazyCallGraph.h:641</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r7A805890ACA79BD5.html">llvm::LazyCallGraph::RefSCC</a>&amp;<b> RC</b></dt></dl><h3 id="98A1E326983B69B0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#98A1E326983B69B0">¶</a><code class="hdoc-function-code language-cpp">bool isChildOf(
    const <a href="r7A805890ACA79BD5.html">llvm::LazyCallGraph::RefSCC</a>&amp; RC) const</code></pre></h3><h4>Description</h4><p>Test if this RefSCC is a child of \a RC. CAUTION: This method walks every edge in the argument \c RefSCC, it can be very expensive.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L647">llvm/include/llvm/Analysis/LazyCallGraph.h:647</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r7A805890ACA79BD5.html">llvm::LazyCallGraph::RefSCC</a>&amp;<b> RC</b></dt></dl><h3 id="F3801BD137FBB371"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F3801BD137FBB371">¶</a><code class="hdoc-function-code language-cpp">bool isDescendantOf(
    const <a href="r7A805890ACA79BD5.html">llvm::LazyCallGraph::RefSCC</a>&amp; RC) const</code></pre></h3><h4>Description</h4><p>Test if this RefSCC is a descendant of \a RC. CAUTION: This method walks the directed graph of edges as far as necessary to find a possible path from the argument. In the worst case this may walk the entire graph and can be extremely expensive.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L654">llvm/include/llvm/Analysis/LazyCallGraph.h:654</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r7A805890ACA79BD5.html">llvm::LazyCallGraph::RefSCC</a>&amp;<b> RC</b></dt></dl><h3 id="E79F1E2A42C163C7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E79F1E2A42C163C7">¶</a><code class="hdoc-function-code language-cpp">bool isParentOf(
    const <a href="r7A805890ACA79BD5.html">llvm::LazyCallGraph::RefSCC</a>&amp; RC) const</code></pre></h3><h4>Description</h4><p>Test if this RefSCC is a parent of \a RC. CAUTION: This method walks every edge in the \c RefSCC, it can be very expensive.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L634">llvm/include/llvm/Analysis/LazyCallGraph.h:634</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r7A805890ACA79BD5.html">llvm::LazyCallGraph::RefSCC</a>&amp;<b> RC</b></dt></dl><h3 id="26A3A19A3E5B8CEB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#26A3A19A3E5B8CEB">¶</a><code class="hdoc-function-code language-cpp"><a href="r62CD0592E97953B6.html">SmallVector</a>&lt;llvm::LazyCallGraph::RefSCC*, 1&gt;
removeInternalRefEdge(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::LazyCallGraph::Node*&gt; TargetNs)</code></pre></h3><h4>Description</h4><p>Remove a list of ref edges which are entirely within this RefSCC. Both the \a SourceN and all of the \a TargetNs must be within this RefSCC. Removing these edges may break cycles that form this RefSCC and thus this operation may change the RefSCC graph significantly. In particular, this operation will re-form new RefSCCs based on the remaining connectivity of the graph. The following invariants are guaranteed to hold after calling this method: 1) If a ref-cycle remains after removal, it leaves this RefSCC intact and in the graph. No new RefSCCs are built. 2) Otherwise, this RefSCC will be dead after this call and no longer in the graph or the postorder traversal of the call graph. Any iterator pointing at this RefSCC will become invalid. 3) All newly formed RefSCCs will be returned and the order of the RefSCCs returned will be a valid postorder traversal of the new RefSCCs. 4) No RefSCC other than this RefSCC has its member set changed (this is inherent in the definition of removing such an edge). These invariants are very important to ensure that we can build optimization pipelines on top of the CGSCC pass manager which intelligently update the RefSCC graph without invalidating other parts of the RefSCC graph. Note that we provide no routine to remove a *call* edge. Instead, you must first switch it to a ref edge using \c switchInternalEdgeToRef. This split API is intentional as each of these two steps can invalidate a different aspect of the graph structure and needs to have the invalidation handled independently. The runtime complexity of this method is, in the worst case, O(V+E) where V is the number of nodes in this RefSCC and E is the number of edges leaving the nodes in this RefSCC. Note that E includes both edges within this RefSCC and edges from this RefSCC to child RefSCCs. Some effort has been made to minimize the overhead of common cases such as self-edges and edge removals which result in a spanning tree with no more cycles.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L841">llvm/include/llvm/Analysis/LazyCallGraph.h:841</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::LazyCallGraph::Node*&gt;<b> TargetNs</b></dt></dl><h3 id="115C9037A8966C22"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#115C9037A8966C22">¶</a><code class="hdoc-function-code language-cpp">void removeOutgoingEdge(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>Remove an edge whose source is in this RefSCC and target is *not*. This removes an inter-RefSCC edge. All inter-RefSCC edges originating from this SCC have been fully explored by any in-flight DFS graph formation, so this is always safe to call once you have the source RefSCC. This operation does not change the cyclic structure of the graph and so is very inexpensive. It may change the connectivity graph of the SCCs though, so be careful calling this while iterating over them.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L801">llvm/include/llvm/Analysis/LazyCallGraph.h:801</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl><h3 id="BECCB1FF9C67EEA7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BECCB1FF9C67EEA7">¶</a><code class="hdoc-function-code language-cpp">void replaceNodeFunction(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; N,
    <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; NewF)</code></pre></h3><h4>Description</h4><p>Directly replace a node&apos;s function with a new function. This should be used when moving the body and users of a function to a new formal function object but not otherwise changing the call graph structure in any way. It requires that the old function in the provided node have zero uses and the new function must have calls and references to it establishing an equivalent graph.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L875">llvm/include/llvm/Analysis/LazyCallGraph.h:875</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> N</b></dt><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> NewF</b></dt></dl><h3 id="9B58415581D4F954"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9B58415581D4F954">¶</a><code class="hdoc-function-code language-cpp">ssize_t size() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L622">llvm/include/llvm/Analysis/LazyCallGraph.h:622</a></p><h3 id="C544621E0A12738A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C544621E0A12738A">¶</a><code class="hdoc-function-code language-cpp">bool switchInternalEdgeToCall(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN,
    function_ref&lt;
        void(ArrayRef&lt;llvm::LazyCallGraph::SCC*&gt;)&gt;
        MergeCB = {})</code></pre></h3><h4>Description</h4><p>Make an existing internal ref edge into a call edge. This may form a larger cycle and thus collapse SCCs into TargetN&apos;s SCC. If that happens, the optional callback \p MergedCB will be invoked (if provided) on the SCCs being merged away prior to actually performing the merge. Note that this will never include the target SCC as that will be the SCC functions are merged into to resolve the cycle. Once this function returns, these merged SCCs are not in a valid state but the pointers will remain valid until destruction of the parent graph instance for the purpose of clearing cached information. This function also returns &apos;true&apos; if a cycle was formed and some SCCs merged away as a convenience. After this operation, both SourceN&apos;s SCC and TargetN&apos;s SCC may move position within this RefSCC&apos;s postorder list. Any SCCs merged are merged into the TargetN&apos;s SCC in order to preserve reachability analyses which took place on that SCC.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L696">llvm/include/llvm/Analysis/LazyCallGraph.h:696</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt><dt class="is-family-code">function_ref&lt;void(
    ArrayRef&lt;llvm::LazyCallGraph::SCC*&gt;)&gt;<b> MergeCB</b> = {}</dt></dl><h3 id="01093DBE851FFFF6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#01093DBE851FFFF6">¶</a><code class="hdoc-function-code language-cpp"><a href="rB51FEED19D352440.html">iterator_range</a>&lt;
    llvm::LazyCallGraph::RefSCC::iterator&gt;
switchInternalEdgeToRef(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>Make an existing internal call edge within a single SCC into a ref edge. Since SourceN and TargetN are part of a single SCC, this SCC may be split up due to breaking a cycle in the call edges that formed it. If that happens, then this routine will insert new SCCs into the postorder list *before* the SCC of TargetN (previously the SCC of both). This preserves postorder as the TargetN can reach all of the other nodes by definition of previously being in a single SCC formed by the cycle from SourceN to TargetN. The newly added SCCs are added *immediately* and contiguously prior to the TargetN SCC and return the range covering the new SCCs in the RefSCC&apos;s postorder sequence. You can directly iterate the returned range to observe all of the new SCCs in postorder. Note that if SourceN and TargetN are in separate SCCs, the simpler routine `switchTrivialInternalEdgeToRef` should be used instead.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L726">llvm/include/llvm/Analysis/LazyCallGraph.h:726</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl><h3 id="0BA2C17DAF1C8F55"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0BA2C17DAF1C8F55">¶</a><code class="hdoc-function-code language-cpp">void switchOutgoingEdgeToCall(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>Make an existing outgoing ref edge into a call edge. Note that this is trivial as there are no cyclic impacts and there remains a reference edge.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L733">llvm/include/llvm/Analysis/LazyCallGraph.h:733</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl><h3 id="D4F9C68086E6515D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D4F9C68086E6515D">¶</a><code class="hdoc-function-code language-cpp">void switchOutgoingEdgeToRef(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>Make an existing outgoing call edge into a ref edge. This is trivial as there are no cyclic impacts and there remains a reference edge.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L739">llvm/include/llvm/Analysis/LazyCallGraph.h:739</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl><h3 id="2031EA5FBD0CCE26"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2031EA5FBD0CCE26">¶</a><code class="hdoc-function-code language-cpp">void switchTrivialInternalEdgeToRef(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>Make an existing internal call edge between separate SCCs into a ref edge. If SourceN and TargetN in separate SCCs within this RefSCC, changing the call edge between them to a ref edge is a trivial operation that does not require any structural changes to the call graph.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L706">llvm/include/llvm/Analysis/LazyCallGraph.h:706</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>