<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>enum MemDepResult::DepType: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li><a href="r5DC8991A61113DA8.html"><span>class MemDepResult</span></a></li><li class="is-active"><a aria-current="page4C7F627AE0F6483B"><span>enum MemDepResult::DepType</span></a></li></ul></nav><main class="content"><h1>enum MemDepResult::DepType</h1><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h#L50">llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:50</a></p><h2>Enumerators</h2><table class="table is-narrow is-hoverable"><tr><th>Name</th><th>Value</th><th>Comment</th></tr><tr><td class="is-family-code">Invalid</td><td class="is-family-code">0</td><td>Clients of MemDep never see this.Entries with this marker occur in a LocalDeps map or NonLocalDeps map when the instruction they previously referenced was removed from MemDep.  In either case, the entry may include an instruction pointer. If so, the pointer is an instruction in the block where scanning can start from, saving some work.In a default-constructed MemDepResult object, the type will be Invalid and the instruction pointer will be null.</td></tr><tr><td class="is-family-code">Clobber</td><td class="is-family-code">1</td><td>This is a dependence on the specified instruction which clobbers the desired value.  The pointer member of the MemDepResult pair holds the instruction that clobbers the memory.  For example, this occurs when we see a may-aliased store to the memory location we care about.There are several cases that may be interesting here: 1. Loads are clobbered by may-alias stores. 2. Loads are considered clobbered by partially-aliased loads.  The client may choose to analyze deeper into these cases.</td></tr><tr><td class="is-family-code">Def</td><td class="is-family-code">2</td><td>This is a dependence on the specified instruction which defines or produces the desired memory location.  The pointer member of the MemDepResult pair holds the instruction that defines the memory.Cases of interest: 1. This could be a load or store for dependence queries on load/store.  The value loaded or stored is the produced value. Note that the pointer operand may be different than that of the queried pointer due to must aliases and phi translation. Note that the def may not be the same type as the query, the pointers may just be must aliases. 2. For loads and stores, this could be an allocation instruction. In this case, the load is loading an undef value or a store is the first store to (that part of) the allocation. 3. Dependence queries on calls return Def only when they are readonly calls or memory use intrinsics with identical callees and no intervening clobbers.  No validation is done that the operands to the calls are the same.</td></tr><tr><td class="is-family-code">Other</td><td class="is-family-code">3</td><td>This marker indicates that the query has no known dependency in the specified block.More detailed state info is encoded in the upper part of the pair (i.e. the Instruction*)</td></tr></table></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>