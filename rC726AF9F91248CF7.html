<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>struct CGSCCUpdateResult: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="pageC726AF9F91248CF7"><span>struct CGSCCUpdateResult</span></a></li></ul></nav><main class="content"><h1>struct CGSCCUpdateResult</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">struct CGSCCUpdateResult { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>Support structure for SCC passes to communicate updates the call graph back to the CGSCC pass manager infrsatructure. The CGSCC pass manager runs SCC passes which are allowed to update the call graph and SCC structures. This means the structure the pass manager works on is mutating underneath it. In order to support that, there needs to be careful communication about the precise nature and ramifications of these updates to the pass management infrastructure. All SCC passes will have to accept a reference to the management layer&apos;s update result struct and use it to reflect the results of any CG updates performed. Passes which do not change the call graph structure in any way can just ignore this argument to their run method.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/CGSCCPassManager.h#L232">llvm/include/llvm/Analysis/CGSCCPassManager.h:232</a></p><h2>Member Variables</h2><dl><dt class="is-family-code" id="var_RCWorklist">public  <a href="r32D46B09A2BD6603.html">SmallPriorityWorklist</a>&lt;LazyCallGraph::RefSCC*, 1&gt;&amp; <b>RCWorklist</b></dt><dd>This worklist is in reverse post-order, as we pop off the back in order to observe RefSCCs in post-order. When adding RefSCCs, clients should add them in reverse post-order.</dd><dt class="is-family-code" id="var_CWorklist">public  <a href="r32D46B09A2BD6603.html">SmallPriorityWorklist</a>&lt;LazyCallGraph::SCC*, 1&gt;&amp; <b>CWorklist</b></dt><dd>This worklist is in reverse post-order, as we pop off the back in order to observe SCCs in post-order. When adding SCCs, clients should add them in reverse post-order.</dd><dt class="is-family-code" id="var_InvalidatedRefSCCs">public  <a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;LazyCallGraph::RefSCC*&gt;&amp; <b>InvalidatedRefSCCs</b></dt><dd>This is used to quickly prune out RefSCCs when they get deleted and happen to already be on the worklist. We use this primarily to avoid scanning the list and removing entries from it.</dd><dt class="is-family-code" id="var_InvalidatedSCCs">public  <a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;LazyCallGraph::SCC*&gt;&amp; <b>InvalidatedSCCs</b></dt><dd>This is used to quickly prune out SCCs when they get deleted and happen to already be on the worklist. We use this primarily to avoid scanning the list and removing entries from it.</dd><dt class="is-family-code" id="var_UpdatedRC">public  <a href="r7A805890ACA79BD5.html">LazyCallGraph::RefSCC</a>* <b>UpdatedRC</b></dt><dd>This is set when a graph refinement takes place an the &quot;current&quot; point in the graph moves &quot;down&quot; or earlier in the post-order walk. This will often cause the &quot;current&quot; RefSCC to be a newly created RefSCC object and the old one to be added to the above worklist. When that happens, this pointer is non-null and can be used to continue processing the &quot;top&quot; of the post-order walk.</dd><dt class="is-family-code" id="var_UpdatedC">public  <a href="rF98C323CFA756C9F.html">LazyCallGraph::SCC</a>* <b>UpdatedC</b></dt><dd>This is set when a graph refinement takes place an the &quot;current&quot; point in the graph moves &quot;down&quot; or earlier in the post-order walk. This will often cause the &quot;current&quot; SCC to be a newly created SCC object and the old one to be added to the above worklist. When that happens, this pointer is non-null and can be used to continue processing the &quot;top&quot; of the post-order walk.</dd><dt class="is-family-code" id="var_CrossSCCPA">public  <a href="r9EDCE8A1E6A8CDD6.html">llvm::PreservedAnalyses</a> <b>CrossSCCPA</b></dt><dd>We specifically want to allow CGSCC passes to mutate ancestor IR (changing both the CG structure and the function IR itself). However, this means we need to take special care to correctly mark what analyses are preserved *across* SCCs. We have to track this out-of-band here because within the main `PassManeger` infrastructure we need to mark everything within an SCC as preserved in order to avoid repeatedly invalidating the same analyses as we unnest pass managers and adaptors. So we track the cross-SCC version of the preserved analyses here from any code that does direct invalidation of SCC analyses, and then use it whenever we move forward in the post-order walk of SCCs before running passes over the new SCC.</dd><dt class="is-family-code" id="var_InlinedInternalEdges">public  <a href="r1ECED809762A9632.html">SmallDenseSet</a>&lt;std::pair&lt;LazyCallGraph::Node*,
                        LazyCallGraph::SCC*&gt;,
              4&gt;&amp; <b>InlinedInternalEdges</b></dt><dd>FIXME: Keeping this here seems like a big layering issue, we should look for a better technique.</dd></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>