<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class ShuffleVectorInst: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="pageE85B047C9948BA28"><span>class ShuffleVectorInst</span></a></li></ul></nav><main class="content"><h1>class ShuffleVectorInst</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class ShuffleVectorInst : public Instruction { /* full declaration omitted */ };</code></pre><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L1983">llvm/include/llvm/IR/Instructions.h:1983</a></p><p>Inherits from: <a href="rE266D8602316BABC.html">Instruction</a></p><h2>Member Variables</h2><p>Inherited from <a href="r4EC65655F3BC4E59.html">Value</a>:</p><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html#var_SubclassOptionalData">protected <b>SubclassOptionalData</b></a></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html#var_NumUserOperands">protected <b>NumUserOperands</b></a></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html#var_IsUsedByMD">protected <b>IsUsedByMD</b></a></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html#var_HasName">protected <b>HasName</b></a></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html#var_HasHungOffUses">protected <b>HasHungOffUses</b></a></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html#var_HasDescriptor">protected <b>HasDescriptor</b></a></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html#var_MaxAlignmentExponent">public static <b>MaxAlignmentExponent</b></a> = 29</dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html#var_MaximumAlignment">public static <b>MaximumAlignment</b></a> = 1U &lt;&lt; MaxAlignmentExponent</dt></dl><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#6A4ADF1CE6664A57"><b>ShuffleVectorInst</b></a>(llvm::Value * V1, llvm::Value * V2, llvm::Value * Mask, const llvm::Twine &amp; NameStr = &quot;&quot;, llvm::Instruction * InsertBefor = nullptr)</li><li class="is-family-code">public  <a href="#0DD35A0F2B216B92"><b>ShuffleVectorInst</b></a>(llvm::Value * V1, llvm::Value * V2, llvm::Value * Mask, const llvm::Twine &amp; NameStr, llvm::BasicBlock * InsertAtEnd)</li><li class="is-family-code">public bool  <a href="#69A1C15B6E208B2E"><b>changesLength</b></a>() const</li><li class="is-family-code">public static bool  <a href="#647DAF21FD8EE4D0"><b>classof</b></a>(const llvm::Value * V)</li><li class="is-family-code">public static bool  <a href="#05A77D0A25438555"><b>classof</b></a>(const llvm::Instruction * I)</li><li class="is-family-code">protected llvm::ShuffleVectorInst *  <a href="#3B634621762B99E3"><b>cloneImpl</b></a>() const</li><li class="is-family-code">public void  <a href="#31BC5B444682A8C8"><b>commute</b></a>()</li><li class="is-family-code">public static void  <a href="#DA3E6472A4B81551"><b>commuteShuffleMask</b></a>(MutableArrayRef&lt;int&gt; Mask, unsigned int InVecNumElts)</li><li class="is-family-code">public llvm::Constant *  <a href="#7C6A0B0BD22AACB6"><b>getMask</b></a>() const</li><li class="is-family-code">public static int  <a href="#9D648B273726AA1A"><b>getMaskValue</b></a>(const llvm::Constant * Mask, unsigned int Elt)</li><li class="is-family-code">public int  <a href="#F15BF0B1A166D75F"><b>getMaskValue</b></a>(unsigned int Elt) const</li><li class="is-family-code">public void  <a href="#7374AE550963E082"><b>getShuffleMask</b></a>(SmallVectorImpl&lt;int&gt; &amp; Result) const</li><li class="is-family-code">public SmallVector&lt;int, 16&gt;  <a href="#16B029B26C97857C"><b>getShuffleMask</b></a>() const</li><li class="is-family-code">public static void  <a href="#F0F8FAEC62907033"><b>getShuffleMask</b></a>(const llvm::Constant * Mask, SmallVectorImpl&lt;int&gt; &amp; Result)</li><li class="is-family-code">public llvm::VectorType *  <a href="#1E812A605B127B96"><b>getType</b></a>() const</li><li class="is-family-code">public bool  <a href="#7F79ADB1DB37DD63"><b>increasesLength</b></a>() const</li><li class="is-family-code">public bool  <a href="#5E3B5A2C1658AB77"><b>isConcat</b></a>() const</li><li class="is-family-code">public static bool  <a href="#336844EF32973BA4"><b>isExtractSubvectorMask</b></a>(ArrayRef&lt;int&gt; Mask, int NumSrcElts, int &amp; Index)</li><li class="is-family-code">public static bool  <a href="#6CACE9814BB607B5"><b>isExtractSubvectorMask</b></a>(const llvm::Constant * Mask, int NumSrcElts, int &amp; Index)</li><li class="is-family-code">public bool  <a href="#548854718DC86DA0"><b>isExtractSubvectorMask</b></a>(int &amp; Index) const</li><li class="is-family-code">public bool  <a href="#97685001D7F02275"><b>isIdentity</b></a>() const</li><li class="is-family-code">public static bool  <a href="#56243E805ECA3801"><b>isIdentityMask</b></a>(const llvm::Constant * Mask)</li><li class="is-family-code">public static bool  <a href="#34099E3204EA5E03"><b>isIdentityMask</b></a>(ArrayRef&lt;int&gt; Mask)</li><li class="is-family-code">public bool  <a href="#3B419E4EB8E0A00E"><b>isIdentityWithExtract</b></a>() const</li><li class="is-family-code">public bool  <a href="#C42211386208F9AD"><b>isIdentityWithPadding</b></a>() const</li><li class="is-family-code">public bool  <a href="#BA67BC19934C3130"><b>isReverse</b></a>() const</li><li class="is-family-code">public static bool  <a href="#CED172888E00452A"><b>isReverseMask</b></a>(ArrayRef&lt;int&gt; Mask)</li><li class="is-family-code">public static bool  <a href="#DF1E57492DED437C"><b>isReverseMask</b></a>(const llvm::Constant * Mask)</li><li class="is-family-code">public bool  <a href="#95F11D539CEAB81B"><b>isSelect</b></a>() const</li><li class="is-family-code">public static bool  <a href="#A45BF403900F35C1"><b>isSelectMask</b></a>(ArrayRef&lt;int&gt; Mask)</li><li class="is-family-code">public static bool  <a href="#1ED83105658CCA0A"><b>isSelectMask</b></a>(const llvm::Constant * Mask)</li><li class="is-family-code">public bool  <a href="#8BCD2D198476AA0B"><b>isSingleSource</b></a>() const</li><li class="is-family-code">public static bool  <a href="#8909002C606B33BA"><b>isSingleSourceMask</b></a>(ArrayRef&lt;int&gt; Mask)</li><li class="is-family-code">public static bool  <a href="#67713AF4AAC3FEBD"><b>isSingleSourceMask</b></a>(const llvm::Constant * Mask)</li><li class="is-family-code">public bool  <a href="#3C9CFC5865FE3893"><b>isTranspose</b></a>() const</li><li class="is-family-code">public static bool  <a href="#C580942140582CAA"><b>isTransposeMask</b></a>(ArrayRef&lt;int&gt; Mask)</li><li class="is-family-code">public static bool  <a href="#3C4541ABDDFE2AEA"><b>isTransposeMask</b></a>(const llvm::Constant * Mask)</li><li class="is-family-code">public static bool  <a href="#8E2CE66675A20F59"><b>isValidOperands</b></a>(const llvm::Value * V1, const llvm::Value * V2, const llvm::Value * Mask)</li><li class="is-family-code">public bool  <a href="#F5CBD4D0FE226804"><b>isZeroEltSplat</b></a>() const</li><li class="is-family-code">public static bool  <a href="#E972180AB4B25021"><b>isZeroEltSplatMask</b></a>(const llvm::Constant * Mask)</li><li class="is-family-code">public static bool  <a href="#1AF0AFA7938443E2"><b>isZeroEltSplatMask</b></a>(ArrayRef&lt;int&gt; Mask)</li></ul><p>Inherited from <a href="rE266D8602316BABC.html">Instruction</a>:</p><ul><li class="is-family-code"><a href="rE266D8602316BABC.html#8A23A13DA882A8A2">public <b>andIRFlags</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#4FF6454E5ACA461F">public <b>applyMergedLocation</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#0278B7C3F6439020">public <b>classof</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#99E2AC097A493744">public <b>clone</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#D7A62A21D7A8BB6E">public <b>copyFastMathFlags</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#C03B9E8E1AF50AC0">public <b>copyFastMathFlags</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#5E6F6E605E0E7C97">public <b>copyIRFlags</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#160924B5DC386E80">public <b>copyMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#5B3DFF43FFE37251">public <b>dropPoisonGeneratingFlags</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#EBDA8708D6C96C00">public <b>dropUnknownNonDebugMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#5F80BBF110468902">public <b>dropUnknownNonDebugMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#24F4687B06B97CF3">public <b>dropUnknownNonDebugMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#30976DE6A709DF01">public <b>dropUnknownNonDebugMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#15BFD28BCD877421">public <b>eraseFromParent</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#5650152C5B277BAF">public <b>extractProfMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#751BFC5F21AC8CE8">public <b>extractProfTotalWeight</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#361ACB802A96432C">public <b>getAAMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#E8BE7A77AF4851C3">public <b>getAllMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#87ECB905011846B0">public <b>getAllMetadataOtherThanDebugLoc</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#CD58DAE4B9BE3F97">public <b>getDebugLoc</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#AAB3BC4797B476C6">public <b>getFastMathFlags</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#AA47F52088C1CF7B">public <b>getFunction</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#F74097B6CA2F1116">public <b>getFunction</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#CC972B812E60C698">public <b>getMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#B1EA184D83C48FFE">public <b>getMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#8696CB0D733A8E67">public <b>getModule</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#D92917FC36BB27F1">public <b>getModule</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#690FE6F703A0B2E1">public <b>getNextNonDebugInstruction</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#772544868FBDDC2B">public <b>getNextNonDebugInstruction</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#73493924D5782167">public <b>getNumSuccessors</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#C398CBA22834C531">public <b>getOpcode</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#A0EAC9DC08AC11C9">public <b>getOpcodeName</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#16095AAADF3766E7">public <b>getOpcodeName</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#B221972DC71B6739">public <b>getParent</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#DB22CCF24B292DBA">public <b>getParent</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#9F7E14673595D7A3">public <b>getPrevNonDebugInstruction</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#D71178A69E8C92F2">public <b>getPrevNonDebugInstruction</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#A282D1790076986A">protected <b>getSubclassDataFromInstruction</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#4F867A44C704B0FD">public <b>getSuccessor</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#000321469C6127C1">public <b>hasAllowContract</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#12FC2C005A58E20A">public <b>hasAllowReassoc</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#6A9CF2332CEE2685">public <b>hasAllowReciprocal</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#3D70D5F52A7A0BCB">public <b>hasApproxFunc</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#94F597CDA0F16BA3">public <b>hasAtomicLoad</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#8E7B22A915858B3C">public <b>hasAtomicStore</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#F913C739304F2E9E">public <b>hasMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#6E52764567333E36">public <b>hasMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#094922E2BB3E0811">public <b>hasMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#85C1536CC342BA18">public <b>hasMetadataOtherThanDebugLoc</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#2B9CE24CDF4E6FA5">public <b>hasNoInfs</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#B16E37A1BA87CC20">public <b>hasNoNaNs</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#2BADC3FB89DFF0EB">public <b>hasNoSignedWrap</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#AE69BDD1227F6964">public <b>hasNoSignedZeros</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#3BB53B82AEA0AE79">public <b>hasNoUnsignedWrap</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#F2CC2F31FF076AFC">public <b>insertAfter</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#DCD6B796D2FD9C7E">public <b>insertBefore</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#8DAD2D9A85DBDC04">public <b>isArithmeticShift</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#D6792AC666087C5F">public <b>isAssociative</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#28B776AF9A156662">public <b>isAssociative</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#A30785A045BB1E18">public <b>isAtomic</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#6A87729C5797A1B4">public <b>isBinaryOp</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#12D5E1D9B6E09A6F">public <b>isBinaryOp</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#587A7098B389152D">public <b>isBitwiseLogicOp</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#5EE9EAF6D8493C79">public <b>isBitwiseLogicOp</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#7E807E3F1D79A1BC">public <b>isCast</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#AA83E67329F21BC6">public <b>isCast</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#A2666A5F459357E4">public <b>isCommutative</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#E1D537FF200403FE">public <b>isCommutative</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#4BF4B3E3E1A87B71">public <b>isEHPad</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#AD7334BCA3FE4A39">public <b>isExact</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#E1A3EA1534CA6350">public <b>isExceptionalTerminator</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#C998D0722D571E20">public <b>isExceptionalTerminator</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#E2A9075DEFA7CBBA">public <b>isFast</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#38DB2807293D687C">public <b>isFenceLike</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#2D11F0AC60D44353">public <b>isFuncletPad</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#86C74E103FDE4A4D">public <b>isFuncletPad</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#7EE4FB47E3F4D6AF">public <b>isIdempotent</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#B28AAB80A40B03F3">public <b>isIdempotent</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#02916CC5C02C4AE6">public <b>isIdenticalTo</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#25B100E41E315B0D">public <b>isIdenticalToWhenDefined</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#A0DEE9F0C04DC50D">public <b>isIndirectTerminator</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#BFC523939BAA8D0F">public <b>isIndirectTerminator</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#1DEB201114F8D7DD">public <b>isIntDivRem</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#B0C94235EFD0CAFD">public <b>isIntDivRem</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#21D9B6E5EDD048ED">public <b>isLifetimeStartOrEnd</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#BCC0B93CCE8274FF">public <b>isLogicalShift</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#5BAFF3D525B3C3E9">public <b>isNilpotent</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#CB96D7DF5A118B24">public <b>isNilpotent</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#9AF65CE21618FF51">public <b>isSafeToRemove</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#EA688700A442FB41">public <b>isSameOperationAs</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#F0039F924D7FA5B8">public <b>isShift</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#507F44D4A9C2F7FA">public <b>isShift</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#21DF41030C5E7558">public <b>isTerminator</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#48004DE4E964033E">public <b>isTerminator</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#8681B04A9E2CD624">public <b>isUnaryOp</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#EC96F2B2FCC29EC5">public <b>isUnaryOp</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#71497E05A5A23436">public <b>isUsedOutsideOfBlock</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#FB998DC8A2CD2090">public <b>mayHaveSideEffects</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#3C8F5C50FAD43592">public <b>mayReadFromMemory</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#6DC225FA96B1861A">public <b>mayReadOrWriteMemory</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#F10EB153433519F9">public <b>mayThrow</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#D85F30AE74FC88FC">public <b>mayWriteToMemory</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#F5A91FBE4DACE28C">public <b>moveAfter</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#4F524750CAE9B75F">public <b>moveBefore</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#B112FE7C3A1622AB">public <b>moveBefore</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#6DDEB3B0B9B74322">public <b>removeFromParent</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#BE6DBEF843693E1D">public <b>replaceSuccessorWith</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#FBD0A4EF830A9E9D">public <b>setAAMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#BF82B5FDD30C084E">public <b>setDebugLoc</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#C9A3FCF88A760818">public <b>setFast</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#973F6BA0D985D74F">public <b>setFastMathFlags</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#0460966CD69CEC76">public <b>setHasAllowReassoc</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#62307F248659FB1D">public <b>setHasAllowReciprocal</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#65A47F933CB3F444">public <b>setHasApproxFunc</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#56C9E0B49DB06B7C">public <b>setHasNoInfs</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#02E5846B984BFB64">public <b>setHasNoNaNs</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#0590B0D03C0A344D">public <b>setHasNoSignedWrap</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#5F503849B8E35C31">public <b>setHasNoSignedZeros</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#1365E6D4A18D1013">public <b>setHasNoUnsignedWrap</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#EF0E758F63F404A6">protected <b>setInstructionSubclassData</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#9857518E2DE4C816">public <b>setIsExact</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#6D38ECFC2CF26F0A">public <b>setMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#77BC8E3C4AC95B2F">public <b>setMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#99C0FE0C99402D34">public <b>setProfWeight</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#881465AD078B125C">public <b>setSuccessor</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#0F5A948DE34C0F6A">public <b>swapProfMetadata</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#24E59B2A00C4F006">public <b>user_back</b></a></li><li class="is-family-code"><a href="rE266D8602316BABC.html#A59CBB8D65516496">public <b>user_back</b></a></li></ul><p>Inherited from <a href="r837F022AC7CDEC6A.html">User</a>:</p><ul><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#072E4C1A678F6944">protected <b>Op</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#D50CCEF955E3BE36">protected <b>Op</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#981D999D134D7980">protected <b>OpFrom</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#1B49D34A5E6408C7">protected <b>allocHungoffUses</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#F30614137D57B5FA">public <b>classof</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#8D6AC5322B077070">public <b>dropAllReferences</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#79F39F83D2373812">public <b>getDescriptor</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#E5CAA66397CC51A3">public <b>getDescriptor</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#8B7ED9D662BB21D9">public <b>getNumOperands</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#57EC7A35AB0EE0F1">public <b>getOperand</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#1A457040915A0E62">public <b>getOperandList</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#F6BA846B168B0050">public <b>getOperandList</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#AF7072D370300406">public <b>getOperandUse</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#E34B12384453FC8D">public <b>getOperandUse</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#F545858BD6ACE472">protected <b>growHungoffUses</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#5CC3CAFE28D72FB0">public <b>op_begin</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#58DBEEB90F425F2A">public <b>op_begin</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#5160F533CCC84F0E">public <b>op_end</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#A762ADB0EC6E70D3">public <b>op_end</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#EF3417D91A86AF0E">public <b>operand_values</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#70490527347A4B22">public <b>operand_values</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#EA2317C1F1FCBB6E">public <b>operands</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#7247AE2A8A53B5ED">public <b>operands</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#6779DC9403057B60">public <b>replaceUsesOfWith</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#21DF44C055EB407C">public <b>setGlobalVariableNumOperands</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#CC7E372736F539B3">public <b>setNumHungOffUseOperands</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#8FCD830828E322F5">public <b>setOperand</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#B8B1F55D34FF457D">public <b>value_op_begin</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#7425D13AE01E46FF">public <b>value_op_begin</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#054F3E96C40C9208">public <b>value_op_end</b></a></li><li class="is-family-code"><a href="r837F022AC7CDEC6A.html#643254C78E8D21E3">public <b>value_op_end</b></a></li></ul><p>Inherited from <a href="r4EC65655F3BC4E59.html">Value</a>:</p><ul><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#1177DBBDB440420B">public <b>DoPHITranslation</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#3F4786A23BDAEABF">public <b>DoPHITranslation</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#9BCFDB6C0CDF7FC6">public <b>addUse</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#AE040E9F8F178DC1">public <b>assertModuleIsMaterialized</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#0D1151D47B8FB611">public <b>assertModuleIsMaterializedImpl</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#BA8A2F8112DAEA1B">public <b>clearSubclassOptionalData</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#26263D08581F6D7E">public <b>deleteValue</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#44009929AF45D077">public <b>dump</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#D004F2329F74F439">public <b>getContext</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#68E6E96B5FE99B22">public <b>getName</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#B9761AC3E2A7BA94">public <b>getNumUses</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#65E28D6CEEABDD8C">public <b>getPointerAlignment</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#64596211B7E795C8">public <b>getPointerDereferenceableBytes</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#55687012817DC4AD">public <b>getRawSubclassOptionalData</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#BAAFA6C8E7D23F09">protected <b>getSubclassDataFromValue</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#0675F96D344B01E1">public <b>getType</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#CE8125D5086E10D0">public <b>getValueID</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#C4C0D5F05D7A4BEF">public <b>getValueName</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#C1F0DB7A1D4AABCF">public <b>hasNUses</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#DFBF8CE2D5831305">public <b>hasNUsesOrMore</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#B98470818936A58C">public <b>hasName</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#AC50A13C9FE53403">public <b>hasOneUse</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#4918FF34EAF5E2EF">public <b>hasSameSubclassOptionalData</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#793F72A82FE1BC6C">public <b>hasValueHandle</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#092A14E077CE3962">public <b>isSwiftError</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#8E15C06AF3B96CEF">public <b>isUsedByMetadata</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#BDB10C88152DA10C">public <b>isUsedInBasicBlock</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#3A4BCF1E3460FE33">public <b>materialized_use_begin</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#3B58EA4D7E8CE29B">public <b>materialized_use_begin</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#A39F660B4140122E">public <b>materialized_use_empty</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#9043C3FEBF58A8E6">public <b>materialized_user_begin</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#7C0EE20FE9F677E8">public <b>materialized_user_begin</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#0F11A9AD19D853DF">public <b>materialized_users</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#D2096C0B4658CCC2">public <b>materialized_users</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#CDFFA3A02F95CFA3">public <b>materialized_uses</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#98081EEC740D3E5D">public <b>materialized_uses</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#9D6B34E3DF18D85D">public <b>mutateType</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#3EB036A8FCC376C1">public <b>print</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#A6EEFEB97558706B">public <b>print</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#63D047AA76275955">public <b>printAsOperand</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#BA8C75C9419962C6">public <b>printAsOperand</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#C8C57468174C73A8">public <b>replaceAllUsesWith</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#447D1E16BE30C50E">public <b>replaceNonMetadataUsesWith</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#1B88550B34DA3221">public <b>replaceUsesOutsideBlock</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#97676B211B131921">public <b>replaceUsesWithIf</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#A8DF9171F53BB217">public <b>reverseUseList</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#DE60F094920018C3">public <b>setName</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#8DF026820E40CF19">public <b>setValueName</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#1774B3E79DC68117">protected <b>setValueSubclassData</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#6B375D1EDD291527">public <b>sortUseList</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#993771A7B0129A0F">public <b>stripAndAccumulateConstantOffsets</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#0E1EF3BCA2A6B832">public <b>stripAndAccumulateConstantOffsets</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#887BCE3682C7F021">public <b>stripAndAccumulateInBoundsConstantOffsets</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#5DC55B553665684A">public <b>stripAndAccumulateInBoundsConstantOffsets</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#09485D37C2CD195C">public <b>stripInBoundsConstantOffsets</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#E1CA5A9188055ED3">public <b>stripInBoundsConstantOffsets</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#6D0EB0D7B29B74D8">public <b>stripInBoundsOffsets</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#4011F9050DE2B0DE">public <b>stripInBoundsOffsets</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#E57B514F0ED0CF88">public <b>stripPointerCasts</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#86903619B79031AE">public <b>stripPointerCasts</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#9B2D9BA0981FA887">public <b>stripPointerCastsAndAliases</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#3B22F0A87D041484">public <b>stripPointerCastsAndAliases</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#1A6C5536B6C44FB1">public <b>stripPointerCastsAndInvariantGroups</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#06E9FA9CEB34CCDD">public <b>stripPointerCastsAndInvariantGroups</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#B613AB4FAFB72209">public <b>stripPointerCastsSameRepresentation</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#998ABDB4805E3256">public <b>stripPointerCastsSameRepresentation</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#B25AFDB53303DB72">public <b>takeName</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#1F723DD4F50F61B2">public <b>use_begin</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#AD30C9AC09A00E41">public <b>use_begin</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#7BAC56979D3790C7">public <b>use_empty</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#122E81723F07F887">public <b>use_end</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#6144BF88867D1257">public <b>use_end</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#EDD4BBA3DD427A62">public <b>user_back</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#954698172F0044B5">public <b>user_back</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#BC935F9DBD6582C1">public <b>user_begin</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#42D2A367474CEC21">public <b>user_begin</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#EEDD95B313BBB17F">public <b>user_empty</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#F2423B9BD47F16B6">public <b>user_end</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#BB2C36CE096F9419">public <b>user_end</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#49BC85A24CAEFDB7">public <b>users</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#A5870CEC51BC9F16">public <b>users</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#0F39424275A93AB7">public <b>uses</b></a></li><li class="is-family-code"><a href="r4EC65655F3BC4E59.html#7820254B2A397748">public <b>uses</b></a></li></ul><h2>Methods</h2><h3 id="6A4ADF1CE6664A57"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6A4ADF1CE6664A57">¶</a><code class="hdoc-function-code language-cpp">ShuffleVectorInst(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V1,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V2,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Mask,
    const <a href="rA5E25CD0DF0DA048.html">llvm::Twine</a>&amp; NameStr = &quot;&quot;,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* InsertBefor = nullptr)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L1991">llvm/include/llvm/IR/Instructions.h:1991</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V1</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V2</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Mask</b></dt><dt class="is-family-code">const <a href="rA5E25CD0DF0DA048.html">llvm::Twine</a>&amp;<b> NameStr</b> = &quot;&quot;</dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> InsertBefor</b> = nullptr</dt></dl><h3 id="0DD35A0F2B216B92"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0DD35A0F2B216B92">¶</a><code class="hdoc-function-code language-cpp">ShuffleVectorInst(<a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V1,
                  <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V2,
                  <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Mask,
                  const <a href="rA5E25CD0DF0DA048.html">llvm::Twine</a>&amp; NameStr,
                  <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* InsertAtEnd)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L1994">llvm/include/llvm/IR/Instructions.h:1994</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V1</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V2</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Mask</b></dt><dt class="is-family-code">const <a href="rA5E25CD0DF0DA048.html">llvm::Twine</a>&amp;<b> NameStr</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> InsertAtEnd</b></dt></dl><h3 id="69A1C15B6E208B2E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#69A1C15B6E208B2E">¶</a><code class="hdoc-function-code language-cpp">bool changesLength() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle returns a vector with a different number of elements than its source vectors. Examples: shufflevector  &lt; 4 x n&gt; A,  &lt; 4 x n&gt; B,  &lt; 1,2,3&gt; shufflevector  &lt; 4 x n&gt; A,  &lt; 4 x n&gt; B,  &lt; 1,2,3,4,5&gt;</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2055">llvm/include/llvm/IR/Instructions.h:2055</a></p><h3 id="647DAF21FD8EE4D0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#647DAF21FD8EE4D0">¶</a><code class="hdoc-function-code language-cpp">static bool classof(const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2279">llvm/include/llvm/IR/Instructions.h:2279</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt></dl><h3 id="05A77D0A25438555"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#05A77D0A25438555">¶</a><code class="hdoc-function-code language-cpp">static bool classof(const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2276">llvm/include/llvm/IR/Instructions.h:2276</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt></dl><h3 id="3B634621762B99E3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3B634621762B99E3">¶</a><code class="hdoc-function-code language-cpp"><a href="rE85B047C9948BA28.html">llvm::ShuffleVectorInst</a>* cloneImpl() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L1988">llvm/include/llvm/IR/Instructions.h:1988</a></p><h3 id="31BC5B444682A8C8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#31BC5B444682A8C8">¶</a><code class="hdoc-function-code language-cpp">void commute()</code></pre></h3><h4>Description</h4><p>Swap the first 2 operands and adjust the mask to preserve the semantics of the instruction.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2004">llvm/include/llvm/IR/Instructions.h:2004</a></p><h3 id="DA3E6472A4B81551"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DA3E6472A4B81551">¶</a><code class="hdoc-function-code language-cpp">static void commuteShuffleMask(
    <a href="r2A28999597B8485F.html">MutableArrayRef</a>&lt;int&gt; Mask,
    unsigned int InVecNumElts)</code></pre></h3><h4>Description</h4><p>Change values in a shuffle permute mask assuming the two vector operands of length InVecNumElts have swapped position.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2264">llvm/include/llvm/IR/Instructions.h:2264</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r2A28999597B8485F.html">MutableArrayRef</a>&lt;int&gt;<b> Mask</b></dt><dt class="is-family-code">unsigned int<b> InVecNumElts</b></dt></dl><h3 id="7C6A0B0BD22AACB6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7C6A0B0BD22AACB6">¶</a><code class="hdoc-function-code language-cpp"><a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* getMask() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2020">llvm/include/llvm/IR/Instructions.h:2020</a></p><h3 id="9D648B273726AA1A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9D648B273726AA1A">¶</a><code class="hdoc-function-code language-cpp">static int getMaskValue(
    const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* Mask,
    unsigned int Elt)</code></pre></h3><h4>Description</h4><p>Return the shuffle mask value for the specified element of the mask. Return -1 if the element is undef.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2026">llvm/include/llvm/IR/Instructions.h:2026</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> Mask</b></dt><dt class="is-family-code">unsigned int<b> Elt</b></dt></dl><h3 id="F15BF0B1A166D75F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F15BF0B1A166D75F">¶</a><code class="hdoc-function-code language-cpp">int getMaskValue(unsigned int Elt) const</code></pre></h3><h4>Description</h4><p>Return the shuffle mask value of this instruction for the given element index. Return -1 if the element is undef.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2030">llvm/include/llvm/IR/Instructions.h:2030</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Elt</b></dt></dl><h3 id="7374AE550963E082"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7374AE550963E082">¶</a><code class="hdoc-function-code language-cpp">void getShuffleMask(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;int&gt;&amp; Result) const</code></pre></h3><h4>Description</h4><p>Return the mask for this instruction as a vector of integers. Undefined elements of the mask are returned as -1.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2041">llvm/include/llvm/IR/Instructions.h:2041</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;int&gt;&amp;<b> Result</b></dt></dl><h3 id="16B029B26C97857C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#16B029B26C97857C">¶</a><code class="hdoc-function-code language-cpp"><a href="r62CD0592E97953B6.html">SmallVector</a>&lt;int, 16&gt; getShuffleMask() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2045">llvm/include/llvm/IR/Instructions.h:2045</a></p><h3 id="F0F8FAEC62907033"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F0F8FAEC62907033">¶</a><code class="hdoc-function-code language-cpp">static void getShuffleMask(
    const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* Mask,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;int&gt;&amp; Result)</code></pre></h3><h4>Description</h4><p>Convert the input shuffle mask operand to a vector of integers. Undefined elements of the mask are returned as -1.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2036">llvm/include/llvm/IR/Instructions.h:2036</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> Mask</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;int&gt;&amp;<b> Result</b></dt></dl><h3 id="1E812A605B127B96"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1E812A605B127B96">¶</a><code class="hdoc-function-code language-cpp"><a href="rBA702C5D0CD7CD0E.html">llvm::VectorType</a>* getType() const</code></pre></h3><h4>Description</h4><p>Overload to return most specific vector type.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2013">llvm/include/llvm/IR/Instructions.h:2013</a></p><h3 id="7F79ADB1DB37DD63"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7F79ADB1DB37DD63">¶</a><code class="hdoc-function-code language-cpp">bool increasesLength() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle returns a vector with a greater number of elements than its source vectors. Example: shufflevector  &lt; 2 x n&gt; A,  &lt; 2 x n&gt; B,  &lt; 1,2,3&gt;</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2064">llvm/include/llvm/IR/Instructions.h:2064</a></p><h3 id="5E3B5A2C1658AB77"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5E3B5A2C1658AB77">¶</a><code class="hdoc-function-code language-cpp">bool isConcat() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle concatenates its 2 source vectors. This returns false if either input is undefined. In that case, the shuffle is is better classified as an identity with padding operation.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2122">llvm/include/llvm/IR/Instructions.h:2122</a></p><h3 id="336844EF32973BA4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#336844EF32973BA4">¶</a><code class="hdoc-function-code language-cpp">static bool isExtractSubvectorMask(
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt; Mask,
    int NumSrcElts,
    int&amp; Index)</code></pre></h3><h4>Description</h4><p>Return true if this shuffle mask is an extract subvector mask. A valid extract subvector mask returns a smaller vector from a single source operand. The base extraction index is returned as well.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2246">llvm/include/llvm/IR/Instructions.h:2246</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt;<b> Mask</b></dt><dt class="is-family-code">int<b> NumSrcElts</b></dt><dt class="is-family-code">int&amp;<b> Index</b></dt></dl><h3 id="6CACE9814BB607B5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6CACE9814BB607B5">¶</a><code class="hdoc-function-code language-cpp">static bool isExtractSubvectorMask(
    const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* Mask,
    int NumSrcElts,
    int&amp; Index)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2248">llvm/include/llvm/IR/Instructions.h:2248</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> Mask</b></dt><dt class="is-family-code">int<b> NumSrcElts</b></dt><dt class="is-family-code">int&amp;<b> Index</b></dt></dl><h3 id="548854718DC86DA0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#548854718DC86DA0">¶</a><code class="hdoc-function-code language-cpp">bool isExtractSubvectorMask(int&amp; Index) const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle mask is an extract subvector mask.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2257">llvm/include/llvm/IR/Instructions.h:2257</a></p><h4>Parameters</h4><dl><dt class="is-family-code">int&amp;<b> Index</b></dt></dl><h3 id="97685001D7F02275"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#97685001D7F02275">¶</a><code class="hdoc-function-code language-cpp">bool isIdentity() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle chooses elements from exactly one source vector without lane crossings and does not change the number of elements from its input vectors. Example: shufflevector  &lt; 4 x n&gt; A,  &lt; 4 x n&gt; B,  &lt; 4,undef,6,undef&gt;</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2107">llvm/include/llvm/IR/Instructions.h:2107</a></p><h3 id="56243E805ECA3801"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#56243E805ECA3801">¶</a><code class="hdoc-function-code language-cpp">static bool isIdentityMask(
    const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* Mask)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2096">llvm/include/llvm/IR/Instructions.h:2096</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> Mask</b></dt></dl><h3 id="34099E3204EA5E03"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#34099E3204EA5E03">¶</a><code class="hdoc-function-code language-cpp">static bool isIdentityMask(<a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt; Mask)</code></pre></h3><h4>Description</h4><p>Return true if this shuffle mask chooses elements from exactly one source vector without lane crossings. A shuffle using this mask is not necessarily a no-op because it may change the number of elements from its input vectors or it may provide demanded bits knowledge via undef lanes. Example:  &lt;undef ,undef,2,3&gt;</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2095">llvm/include/llvm/IR/Instructions.h:2095</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt;<b> Mask</b></dt></dl><h3 id="3B419E4EB8E0A00E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3B419E4EB8E0A00E">¶</a><code class="hdoc-function-code language-cpp">bool isIdentityWithExtract() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle extracts the first N elements of exactly one source vector.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2117">llvm/include/llvm/IR/Instructions.h:2117</a></p><h3 id="C42211386208F9AD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C42211386208F9AD">¶</a><code class="hdoc-function-code language-cpp">bool isIdentityWithPadding() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle lengthens exactly one source vector with undefs in the high elements.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2113">llvm/include/llvm/IR/Instructions.h:2113</a></p><h3 id="BA67BC19934C3130"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BA67BC19934C3130">¶</a><code class="hdoc-function-code language-cpp">bool isReverse() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle swaps the order of elements from exactly one source vector. Example: shufflevector  &lt; 4 x n&gt; A,  &lt; 4 x n&gt; B,  &lt; 3,undef,1,undef&gt; TODO: Optionally allow length-changing shuffles.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2168">llvm/include/llvm/IR/Instructions.h:2168</a></p><h3 id="CED172888E00452A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CED172888E00452A">¶</a><code class="hdoc-function-code language-cpp">static bool isReverseMask(<a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt; Mask)</code></pre></h3><h4>Description</h4><p>Return true if this shuffle mask swaps the order of elements from exactly one source vector. Example:  &lt; 7,6,undef,4&gt; This assumes that vector operands are the same length as the mask.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2156">llvm/include/llvm/IR/Instructions.h:2156</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt;<b> Mask</b></dt></dl><h3 id="DF1E57492DED437C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DF1E57492DED437C">¶</a><code class="hdoc-function-code language-cpp">static bool isReverseMask(
    const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* Mask)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2157">llvm/include/llvm/IR/Instructions.h:2157</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> Mask</b></dt></dl><h3 id="95F11D539CEAB81B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#95F11D539CEAB81B">¶</a><code class="hdoc-function-code language-cpp">bool isSelect() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle chooses elements from its source vectors without lane crossings and all operands have the same number of elements. In other words, this shuffle is equivalent to a vector select with a constant condition operand. Example: shufflevector  &lt; 4 x n&gt; A,  &lt; 4 x n&gt; B,  &lt;undef ,1,6,3&gt; This returns false if the mask does not choose from both input vectors. In that case, the shuffle is better classified as an identity shuffle. TODO: Optionally allow length-changing shuffles.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2148">llvm/include/llvm/IR/Instructions.h:2148</a></p><h3 id="A45BF403900F35C1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A45BF403900F35C1">¶</a><code class="hdoc-function-code language-cpp">static bool isSelectMask(<a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt; Mask)</code></pre></h3><h4>Description</h4><p>Return true if this shuffle mask chooses elements from its source vectors without lane crossings. A shuffle using this mask would be equivalent to a vector select with a constant condition operand. Example:  &lt; 4,1,6,undef&gt; This returns false if the mask does not choose from both input vectors. In that case, the shuffle is better classified as an identity shuffle. This assumes that vector operands are the same length as the mask (a length-changing shuffle can never be equivalent to a vector select).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2132">llvm/include/llvm/IR/Instructions.h:2132</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt;<b> Mask</b></dt></dl><h3 id="1ED83105658CCA0A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1ED83105658CCA0A">¶</a><code class="hdoc-function-code language-cpp">static bool isSelectMask(
    const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* Mask)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2133">llvm/include/llvm/IR/Instructions.h:2133</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> Mask</b></dt></dl><h3 id="8BCD2D198476AA0B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8BCD2D198476AA0B">¶</a><code class="hdoc-function-code language-cpp">bool isSingleSource() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle chooses elements from exactly one source vector without changing the length of that vector. Example: shufflevector  &lt; 4 x n&gt; A,  &lt; 4 x n&gt; B,  &lt; 3,0,undef,3&gt; TODO: Optionally allow length-changing shuffles.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2086">llvm/include/llvm/IR/Instructions.h:2086</a></p><h3 id="8909002C606B33BA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8909002C606B33BA">¶</a><code class="hdoc-function-code language-cpp">static bool isSingleSourceMask(<a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt; Mask)</code></pre></h3><h4>Description</h4><p>Return true if this shuffle mask chooses elements from exactly one source vector. Example:  &lt; 7,5,undef,7&gt; This assumes that vector operands are the same length as the mask.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2074">llvm/include/llvm/IR/Instructions.h:2074</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt;<b> Mask</b></dt></dl><h3 id="67713AF4AAC3FEBD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#67713AF4AAC3FEBD">¶</a><code class="hdoc-function-code language-cpp">static bool isSingleSourceMask(
    const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* Mask)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2075">llvm/include/llvm/IR/Instructions.h:2075</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> Mask</b></dt></dl><h3 id="3C9CFC5865FE3893"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3C9CFC5865FE3893">¶</a><code class="hdoc-function-code language-cpp">bool isTranspose() const</code></pre></h3><h4>Description</h4><p>Return true if this shuffle transposes the elements of its inputs without changing the length of the vectors. This operation may also be known as a merge or interleave. See the description for isTransposeMask() for the exact specification. Example: shufflevector  &lt; 4 x n&gt; A,  &lt; 4 x n&gt; B,  &lt; 0,4,2,6&gt;</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2239">llvm/include/llvm/IR/Instructions.h:2239</a></p><h3 id="C580942140582CAA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C580942140582CAA">¶</a><code class="hdoc-function-code language-cpp">static bool isTransposeMask(<a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt; Mask)</code></pre></h3><h4>Description</h4><p>Return true if this shuffle mask is a transpose mask. Transpose vector masks transpose a 2xn matrix. They read corresponding even- or odd-numbered vector elements from two n-dimensional source vectors and write each result into consecutive elements of an n-dimensional destination vector. Two shuffles are necessary to complete the transpose, one for the even elements and another for the odd elements. This description closely follows how the TRN1 and TRN2 AArch64 instructions operate. For example, a simple 2x2 matrix can be transposed with: ; Original matrix m0 =  &lt; a, b &gt; m1 =  &lt; c, d &gt; ; Transposed matrix t0 =  &lt; a, c &gt; = shufflevector m0, m1,  &lt; 0, 2 &gt; t1 =  &lt; b, d &gt; = shufflevector m0, m1,  &lt; 1, 3 &gt; For matrices having greater than n columns, the resulting nx2 transposed matrix is stored in two result vectors such that one vector contains interleaved elements from all the even-numbered rows and the other vector contains interleaved elements from all the odd-numbered rows. For example, a 2x4 matrix can be transposed with: ; Original matrix m0 =  &lt; a, b, c, d &gt; m1 =  &lt; e, f, g, h &gt; ; Transposed matrix t0 =  &lt; a, e, c, g &gt; = shufflevector m0, m1  &lt; 0, 4, 2, 6 &gt; t1 =  &lt; b, f, d, h &gt; = shufflevector m0, m1  &lt; 1, 5, 3, 7 &gt;</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2226">llvm/include/llvm/IR/Instructions.h:2226</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt;<b> Mask</b></dt></dl><h3 id="3C4541ABDDFE2AEA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3C4541ABDDFE2AEA">¶</a><code class="hdoc-function-code language-cpp">static bool isTransposeMask(
    const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* Mask)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2227">llvm/include/llvm/IR/Instructions.h:2227</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> Mask</b></dt></dl><h3 id="8E2CE66675A20F59"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8E2CE66675A20F59">¶</a><code class="hdoc-function-code language-cpp">static bool isValidOperands(
    const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V1,
    const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V2,
    const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Mask)</code></pre></h3><h4>Description</h4><p>Return true if a shufflevector instruction can be formed with the specified operands.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2008">llvm/include/llvm/IR/Instructions.h:2008</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V1</b></dt><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V2</b></dt><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Mask</b></dt></dl><h3 id="F5CBD4D0FE226804"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F5CBD4D0FE226804">¶</a><code class="hdoc-function-code language-cpp">bool isZeroEltSplat() const</code></pre></h3><h4>Description</h4><p>Return true if all elements of this shuffle are the same value as the first element of exactly one source vector without changing the length of that vector. Example: shufflevector  &lt; 4 x n&gt; A,  &lt; 4 x n&gt; B,  &lt;undef ,0,undef,0&gt; TODO: Optionally allow length-changing shuffles. TODO: Optionally allow splats from other elements.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2190">llvm/include/llvm/IR/Instructions.h:2190</a></p><h3 id="E972180AB4B25021"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E972180AB4B25021">¶</a><code class="hdoc-function-code language-cpp">static bool isZeroEltSplatMask(
    const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* Mask)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2177">llvm/include/llvm/IR/Instructions.h:2177</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> Mask</b></dt></dl><h3 id="1AF0AFA7938443E2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1AF0AFA7938443E2">¶</a><code class="hdoc-function-code language-cpp">static bool isZeroEltSplatMask(<a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt; Mask)</code></pre></h3><h4>Description</h4><p>Return true if this shuffle mask chooses all elements with the same value as the first element of exactly one source vector. Example:  &lt; 4,undef,undef,4&gt; This assumes that vector operands are the same length as the mask.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/IR/Instructions.h#L2176">llvm/include/llvm/IR/Instructions.h:2176</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;int&gt;<b> Mask</b></dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>