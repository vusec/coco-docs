<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class ScalarEvolution: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="page0D901B7ED6429B0A"><span>class ScalarEvolution</span></a></li></ul></nav><main class="content"><h1>class ScalarEvolution</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class ScalarEvolution { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>The main scalar evolution driver. Because client code (intentionally) can&apos;t do much with the SCEV objects directly, they must ask this class for services.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L441">llvm/include/llvm/Analysis/ScalarEvolution.h:441</a></p><h2>Method Overview</h2><ul><li class="is-family-code">public uint32_t  <a href="#0C797DA29D9EB55F"><b>GetMinTrailingZeros</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public  <a href="#7B7154D1ED28CEC1"><b>ScalarEvolution</b></a>(llvm::Function &amp; F, llvm::TargetLibraryInfo &amp; TLI, llvm::AssumptionCache &amp; AC, llvm::DominatorTree &amp; DT, llvm::LoopInfo &amp; LI)</li><li class="is-family-code">public  <a href="#F4CC9591C5A153E8"><b>ScalarEvolution</b></a>(llvm::ScalarEvolution &amp;&amp; Arg)</li><li class="is-family-code">public bool  <a href="#7DE453F32013515F"><b>SimplifyICmpOperands</b></a>(ICmpInst::Predicate &amp; Pred, const llvm::SCEV *&amp; LHS, const llvm::SCEV *&amp; RHS, unsigned int Depth = 0)</li><li class="is-family-code">public std::pair&lt;const SCEV *, const SCEV *&gt;  <a href="#DAF6B4D66F85341F"><b>SplitIntoInitAndPostInc</b></a>(const llvm::Loop * L, const llvm::SCEV * S)</li><li class="is-family-code">public static SCEV::NoWrapFlags  <a href="#8631E1BBAE022559"><b>clearFlags</b></a>(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OffFlags)</li><li class="is-family-code">public void  <a href="#850CAF6795AEFAF3"><b>collectParametricTerms</b></a>(const llvm::SCEV * Expr, SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Terms)</li><li class="is-family-code">public void  <a href="#FD6346A8624776CA"><b>computeAccessFunctions</b></a>(const llvm::SCEV * Expr, SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Subscripts, SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Sizes)</li><li class="is-family-code">public bool  <a href="#2AB83183E1347C08"><b>containsAddRecurrence</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public const llvm::SCEVAddRecExpr *  <a href="#D044163D4477108C"><b>convertSCEVToAddRecWithPredicates</b></a>(const llvm::SCEV * S, const llvm::Loop * L, SmallPtrSetImpl&lt;const llvm::SCEVPredicate *&gt; &amp; Preds)</li><li class="is-family-code">public Optional&lt;std::pair&lt;const SCEV *, SmallVector&lt;const SCEVPredicate *, 3&gt;&gt;&gt;  <a href="#FF5766DAE52CE536"><b>createAddRecFromPHIWithCasts</b></a>(const llvm::SCEVUnknown * SymbolicPHI)</li><li class="is-family-code">public void  <a href="#96F6CBFB0B7B9CA2"><b>delinearize</b></a>(const llvm::SCEV * Expr, SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Subscripts, SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Sizes, const llvm::SCEV * ElementSize)</li><li class="is-family-code">public bool  <a href="#1CB570681DB3B179"><b>dominates</b></a>(const llvm::SCEV * S, const llvm::BasicBlock * BB)</li><li class="is-family-code">public void  <a href="#491176644A57CEA1"><b>eraseValueFromMap</b></a>(llvm::Value * V)</li><li class="is-family-code">public void  <a href="#0157E9ECDAAE3AF7"><b>findArrayDimensions</b></a>(SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Terms, SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Sizes, const llvm::SCEV * ElementSize)</li><li class="is-family-code">public void  <a href="#49111EFF9D2D1008"><b>forgetAllLoops</b></a>()</li><li class="is-family-code">public void  <a href="#FC61E8B092BBB5C8"><b>forgetLoop</b></a>(const llvm::Loop * L)</li><li class="is-family-code">public void  <a href="#EBD7317AB5325020"><b>forgetLoopDispositions</b></a>(const llvm::Loop * L)</li><li class="is-family-code">public void  <a href="#806F29EA7D6DD58F"><b>forgetTopmostLoop</b></a>(const llvm::Loop * L)</li><li class="is-family-code">public void  <a href="#33481EEAB477AD86"><b>forgetValue</b></a>(llvm::Value * V)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#8D5DAE308B72D5B4"><b>getAddExpr</b></a>(SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Ops, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap, unsigned int Depth = 0)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#A972E14951AC576B"><b>getAddExpr</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap, unsigned int Depth = 0)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#E235CD2DC6E91C51"><b>getAddExpr</b></a>(const llvm::SCEV * Op0, const llvm::SCEV * Op1, const llvm::SCEV * Op2, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap, unsigned int Depth = 0)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#58030B9DBDD6BB80"><b>getAddRecExpr</b></a>(SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Operands, const llvm::Loop * L, SCEV::NoWrapFlags Flags)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#2E5000DC530253CB"><b>getAddRecExpr</b></a>(const llvm::SCEV * Start, const llvm::SCEV * Step, const llvm::Loop * L, SCEV::NoWrapFlags Flags)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#A34748E38CA525B5"><b>getAddRecExpr</b></a>(const SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Operands, const llvm::Loop * L, SCEV::NoWrapFlags Flags)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#A40C114A6E09216E"><b>getAnyExtendExpr</b></a>(const llvm::SCEV * Op, llvm::Type * Ty)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#9748AEC537AFEBCB"><b>getBackedgeTakenCount</b></a>(const llvm::Loop * L, llvm::ScalarEvolution::ExitCountKind Kind = Exact)</li><li class="is-family-code">public llvm::ScalarEvolution::BlockDisposition  <a href="#20EDA65C0EB40731"><b>getBlockDisposition</b></a>(const llvm::SCEV * S, const llvm::BasicBlock * BB)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#5EB85D53CA699A57"><b>getConstant</b></a>(llvm::Type * Ty, uint64_t V, bool isSigned = false)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#0122C7FC73AAE6E4"><b>getConstant</b></a>(const llvm::APInt &amp; Val)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#FE2DA0FAD53E4095"><b>getConstant</b></a>(llvm::ConstantInt * V)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#F1E711EFCD35455C"><b>getConstantMaxBackedgeTakenCount</b></a>(const llvm::Loop * L)</li><li class="is-family-code">public llvm::LLVMContext &amp;  <a href="#C7C9BDC006775D29"><b>getContext</b></a>() const</li><li class="is-family-code">public const llvm::SCEV *  <a href="#E7F1D07933C82027"><b>getCouldNotCompute</b></a>()</li><li class="is-family-code">public const llvm::DataLayout &amp;  <a href="#DCA17E6DF319FA1F"><b>getDataLayout</b></a>() const</li><li class="is-family-code">public llvm::Type *  <a href="#BE15B149CD253D8E"><b>getEffectiveSCEVType</b></a>(llvm::Type * Ty) const</li><li class="is-family-code">public const llvm::SCEV *  <a href="#68FBA55F8932B0F7"><b>getElementSize</b></a>(llvm::Instruction * Inst)</li><li class="is-family-code">public const llvm::SCEVPredicate *  <a href="#62CA3F764FA8B7BA"><b>getEqualPredicate</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#C48BFCB6DB3854FE"><b>getExitCount</b></a>(const llvm::Loop * L, llvm::BasicBlock * ExitingBlock, llvm::ScalarEvolution::ExitCountKind Kind = Exact)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#606C04A9A8F9CCF1"><b>getGEPExpr</b></a>(llvm::GEPOperator * GEP, const SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; IndexExprs)</li><li class="is-family-code">public llvm::ScalarEvolution::LoopDisposition  <a href="#5A1C8ACD8FA35C32"><b>getLoopDisposition</b></a>(const llvm::SCEV * S, const llvm::Loop * L)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#EB19A78DCC0AF8BD"><b>getMinMaxExpr</b></a>(unsigned int Kind, SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Operands)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#0CD49FD8C38465FB"><b>getMinusSCEV</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap, unsigned int Depth = 0)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#04DBC8AA19E7E476"><b>getMulExpr</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap, unsigned int Depth = 0)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#92478883881D088D"><b>getMulExpr</b></a>(const llvm::SCEV * Op0, const llvm::SCEV * Op1, const llvm::SCEV * Op2, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap, unsigned int Depth = 0)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#8BF804FE9AFFD793"><b>getMulExpr</b></a>(SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Ops, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap, unsigned int Depth = 0)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#8FB8D00D85D64085"><b>getNegativeSCEV</b></a>(const llvm::SCEV * V, SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#234D0FD4B8C01701"><b>getNoopOrAnyExtend</b></a>(const llvm::SCEV * V, llvm::Type * Ty)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#AEB20D9716BBB499"><b>getNoopOrSignExtend</b></a>(const llvm::SCEV * V, llvm::Type * Ty)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#9BCEAD0C1966742F"><b>getNoopOrZeroExtend</b></a>(const llvm::SCEV * V, llvm::Type * Ty)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#FAF5CA7A110D6718"><b>getNotSCEV</b></a>(const llvm::SCEV * V)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#E1B124C10CF45D2D"><b>getOffsetOfExpr</b></a>(llvm::Type * IntTy, llvm::StructType * STy, unsigned int FieldNo)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#83338E18642AD956"><b>getOne</b></a>(llvm::Type * Ty)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#899050257128472F"><b>getPointerBase</b></a>(const llvm::SCEV * V)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#645D54F9E2165F69"><b>getPredicatedBackedgeTakenCount</b></a>(const llvm::Loop * L, llvm::SCEVUnionPredicate &amp; Predicates)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#0E1A80CFF51D6D2A"><b>getSCEV</b></a>(llvm::Value * V)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#FC8566193215AD66"><b>getSCEVAtScope</b></a>(llvm::Value * V, const llvm::Loop * L)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#D928532BEE1E9DA1"><b>getSCEVAtScope</b></a>(const llvm::SCEV * S, const llvm::Loop * L)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#50252ABD7A5E81C6"><b>getSMaxExpr</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#465F950738B6E414"><b>getSMaxExpr</b></a>(SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Operands)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#AA3F3D5B1733EB3A"><b>getSMinExpr</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#C4F36D646AC09564"><b>getSMinExpr</b></a>(SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Operands)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#E05904EE22F66F7E"><b>getSignExtendExpr</b></a>(const llvm::SCEV * Op, llvm::Type * Ty, unsigned int Depth = 0)</li><li class="is-family-code">public llvm::ConstantRange  <a href="#99FC8011772D3E31"><b>getSignedRange</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public llvm::APInt  <a href="#688661638EBDB506"><b>getSignedRangeMax</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public llvm::APInt  <a href="#13C60FC889C6518B"><b>getSignedRangeMin</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#E424CC6B99CB303F"><b>getSizeOfExpr</b></a>(llvm::Type * IntTy, llvm::Type * AllocTy)</li><li class="is-family-code">public unsigned int  <a href="#1F1012E364E5DB86"><b>getSmallConstantMaxTripCount</b></a>(const llvm::Loop * L)</li><li class="is-family-code">public unsigned int  <a href="#75FE8D0821509BE1"><b>getSmallConstantTripCount</b></a>(const llvm::Loop * L)</li><li class="is-family-code">public unsigned int  <a href="#A0D4B44638A00C66"><b>getSmallConstantTripCount</b></a>(const llvm::Loop * L, llvm::BasicBlock * ExitingBlock)</li><li class="is-family-code">public unsigned int  <a href="#8ABD43F4D82DE5D1"><b>getSmallConstantTripMultiple</b></a>(const llvm::Loop * L)</li><li class="is-family-code">public unsigned int  <a href="#60C1192B1E37BD89"><b>getSmallConstantTripMultiple</b></a>(const llvm::Loop * L, llvm::BasicBlock * ExitingBlock)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#3F3699624AE56784"><b>getTruncateExpr</b></a>(const llvm::SCEV * Op, llvm::Type * Ty, unsigned int Depth = 0)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#E832F5F5C78993F4"><b>getTruncateOrNoop</b></a>(const llvm::SCEV * V, llvm::Type * Ty)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#4B170B229745840F"><b>getTruncateOrSignExtend</b></a>(const llvm::SCEV * V, llvm::Type * Ty, unsigned int Depth = 0)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#1EA829730629E971"><b>getTruncateOrZeroExtend</b></a>(const llvm::SCEV * V, llvm::Type * Ty, unsigned int Depth = 0)</li><li class="is-family-code">public uint64_t  <a href="#A12E0669C482446F"><b>getTypeSizeInBits</b></a>(llvm::Type * Ty) const</li><li class="is-family-code">public const llvm::SCEV *  <a href="#AD795EC5982BBD26"><b>getUDivExactExpr</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#FFC8976E5C6C9AE0"><b>getUDivExpr</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#42530E0D24A5136C"><b>getUMaxExpr</b></a>(SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Operands)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#AF2262E632298AD6"><b>getUMaxExpr</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#3E745D9D6CC2A8B5"><b>getUMaxFromMismatchedTypes</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#D214A9126D4A7BA7"><b>getUMinExpr</b></a>(SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Operands)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#77A2C04CD97FB8C2"><b>getUMinExpr</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#947B26995AE95C37"><b>getUMinFromMismatchedTypes</b></a>(SmallVectorImpl&lt;const llvm::SCEV *&gt; &amp; Ops)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#5DC6F183B0B8D7CD"><b>getUMinFromMismatchedTypes</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#622882C33A452EC1"><b>getURemExpr</b></a>(const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#EDF16E47CF76F44C"><b>getUnknown</b></a>(llvm::Value * V)</li><li class="is-family-code">public llvm::ConstantRange  <a href="#A3C21B9F97ABD970"><b>getUnsignedRange</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public llvm::APInt  <a href="#A9CA306722D2EB03"><b>getUnsignedRangeMax</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public llvm::APInt  <a href="#12B617134B215E66"><b>getUnsignedRangeMin</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public llvm::Type *  <a href="#74412A6F2FF52412"><b>getWiderType</b></a>(llvm::Type * Ty1, llvm::Type * Ty2) const</li><li class="is-family-code">public const llvm::SCEVPredicate *  <a href="#44E912DDA06FB20A"><b>getWrapPredicate</b></a>(const llvm::SCEVAddRecExpr * AR, SCEVWrapPredicate::IncrementWrapFlags AddedFlags)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#7D8BAE93D7854760"><b>getZero</b></a>(llvm::Type * Ty)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#5CF84674F07D714B"><b>getZeroExtendExpr</b></a>(const llvm::SCEV * Op, llvm::Type * Ty, unsigned int Depth = 0)</li><li class="is-family-code">public bool  <a href="#530CA2098233C572"><b>hasComputableLoopEvolution</b></a>(const llvm::SCEV * S, const llvm::Loop * L)</li><li class="is-family-code">public bool  <a href="#8468851D5EF390C4"><b>hasLoopInvariantBackedgeTakenCount</b></a>(const llvm::Loop * L)</li><li class="is-family-code">public bool  <a href="#FAE9524C23B28AD8"><b>hasOperand</b></a>(const llvm::SCEV * S, const llvm::SCEV * Op) const</li><li class="is-family-code">public bool  <a href="#B771257D41EC06A3"><b>invalidate</b></a>(llvm::Function &amp; F, const llvm::PreservedAnalyses &amp; PA, FunctionAnalysisManager::Invalidator &amp; Inv)</li><li class="is-family-code">public bool  <a href="#6C65519335F37101"><b>isAvailableAtLoopEntry</b></a>(const llvm::SCEV * S, const llvm::Loop * L)</li><li class="is-family-code">public bool  <a href="#54357F7EDE1F8FE2"><b>isBackedgeTakenCountMaxOrZero</b></a>(const llvm::Loop * L)</li><li class="is-family-code">public bool  <a href="#59EC182F7AE4EA1E"><b>isKnownNegative</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public bool  <a href="#137E475552B34728"><b>isKnownNonNegative</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public bool  <a href="#8661A2146C889B11"><b>isKnownNonPositive</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public bool  <a href="#6C96573F9B796C6D"><b>isKnownNonZero</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public bool  <a href="#EA32E419C081EFD4"><b>isKnownOnEveryIteration</b></a>(ICmpInst::Predicate Pred, const llvm::SCEVAddRecExpr * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public bool  <a href="#A42279D50CC34904"><b>isKnownPositive</b></a>(const llvm::SCEV * S)</li><li class="is-family-code">public bool  <a href="#5DAE7B927B11619D"><b>isKnownPredicate</b></a>(ICmpInst::Predicate Pred, const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public bool  <a href="#980F75DF5DD78061"><b>isKnownViaInduction</b></a>(ICmpInst::Predicate Pred, const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public bool  <a href="#7D6003FC337BA740"><b>isLoopBackedgeGuardedByCond</b></a>(const llvm::Loop * L, ICmpInst::Predicate Pred, const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public bool  <a href="#8B646DBF48216FC3"><b>isLoopEntryGuardedByCond</b></a>(const llvm::Loop * L, ICmpInst::Predicate Pred, const llvm::SCEV * LHS, const llvm::SCEV * RHS)</li><li class="is-family-code">public bool  <a href="#4F1C517DD533B2FA"><b>isLoopInvariant</b></a>(const llvm::SCEV * S, const llvm::Loop * L)</li><li class="is-family-code">public bool  <a href="#AFC98479AD710552"><b>isLoopInvariantPredicate</b></a>(ICmpInst::Predicate Pred, const llvm::SCEV * LHS, const llvm::SCEV * RHS, const llvm::Loop * L, ICmpInst::Predicate &amp; InvariantPred, const llvm::SCEV *&amp; InvariantLHS, const llvm::SCEV *&amp; InvariantRHS)</li><li class="is-family-code">public bool  <a href="#7A5D64D2B59C0F3A"><b>isMonotonicPredicate</b></a>(const llvm::SCEVAddRecExpr * LHS, ICmpInst::Predicate Pred, bool &amp; Increasing)</li><li class="is-family-code">public bool  <a href="#123C431252299170"><b>isSCEVable</b></a>(llvm::Type * Ty) const</li><li class="is-family-code">public static SCEV::NoWrapFlags  <a href="#3861FF3D65B5064D"><b>maskFlags</b></a>(SCEV::NoWrapFlags Flags, int Mask)</li><li class="is-family-code">public void  <a href="#796FC428BF51334E"><b>print</b></a>(llvm::raw_ostream &amp; OS) const</li><li class="is-family-code">public bool  <a href="#1BA3491EC9C9F62F"><b>properlyDominates</b></a>(const llvm::SCEV * S, const llvm::BasicBlock * BB)</li><li class="is-family-code">public const llvm::SCEV *  <a href="#78C128E8C487A2E2"><b>rewriteUsingPredicate</b></a>(const llvm::SCEV * S, const llvm::Loop * L, llvm::SCEVUnionPredicate &amp; A)</li><li class="is-family-code">public static SCEV::NoWrapFlags  <a href="#9D4C755FAAD65807"><b>setFlags</b></a>(SCEV::NoWrapFlags Flags, SCEV::NoWrapFlags OnFlags)</li><li class="is-family-code">public void  <a href="#A2F58DF02BE5FB97"><b>verify</b></a>() const</li><li class="is-family-code">public  <a href="#EAB1E5756034BC5C"><b>~ScalarEvolution</b></a>()</li></ul><h2>Methods</h2><h3 id="0C797DA29D9EB55F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0C797DA29D9EB55F">¶</a><code class="hdoc-function-code language-cpp">uint32_t GetMinTrailingZeros(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Determine the minimum number of zero bits that S is guaranteed to end in (at every loop iteration).  It is, at the same time, the minimum number of times S is divisible by 2.  For example, given {4,+,8} it returns 2. If S is guaranteed to be 0, it returns the bitwidth of S.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L813">llvm/include/llvm/Analysis/ScalarEvolution.h:813</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="7B7154D1ED28CEC1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7B7154D1ED28CEC1">¶</a><code class="hdoc-function-code language-cpp">ScalarEvolution(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F,
                <a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>&amp; TLI,
                <a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>&amp; AC,
                <a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp; DT,
                <a href="r289205FCE270195C.html">llvm::LoopInfo</a>&amp; LI)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L474">llvm/include/llvm/Analysis/ScalarEvolution.h:474</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt><dt class="is-family-code"><a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>&amp;<b> TLI</b></dt><dt class="is-family-code"><a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>&amp;<b> AC</b></dt><dt class="is-family-code"><a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp;<b> DT</b></dt><dt class="is-family-code"><a href="r289205FCE270195C.html">llvm::LoopInfo</a>&amp;<b> LI</b></dt></dl><h3 id="F4CC9591C5A153E8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F4CC9591C5A153E8">¶</a><code class="hdoc-function-code language-cpp">ScalarEvolution(<a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>&amp;&amp; Arg)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L476">llvm/include/llvm/Analysis/ScalarEvolution.h:476</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>&amp;&amp;<b> Arg</b></dt></dl><h3 id="7DE453F32013515F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7DE453F32013515F">¶</a><code class="hdoc-function-code language-cpp">bool SimplifyICmpOperands(
    ICmpInst::Predicate&amp; Pred,
    const llvm::SCEV*&amp; LHS,
    const llvm::SCEV*&amp; RHS,
    unsigned int Depth = 0)</code></pre></h3><h4>Description</h4><p>Simplify LHS and RHS in a comparison with predicate Pred. Return true iff any changes were made. If the operands are provably equal or unequal, LHS and RHS are set to the same value and Pred is set to either ICMP_EQ or ICMP_NE.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L938">llvm/include/llvm/Analysis/ScalarEvolution.h:938</a></p><h4>Parameters</h4><dl><dt class="is-family-code">ICmpInst::Predicate&amp;<b> Pred</b></dt><dt class="is-family-code">const llvm::SCEV*&amp;<b> LHS</b></dt><dt class="is-family-code">const llvm::SCEV*&amp;<b> RHS</b></dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="DAF6B4D66F85341F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DAF6B4D66F85341F">¶</a><code class="hdoc-function-code language-cpp"><a href="https://en.cppreference.com/w/cpp/utility/pair">std::pair</a>&lt;const SCEV*, const SCEV*&gt;
SplitIntoInitAndPostInc(const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
                        const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Splits SCEV expression \p S into two SCEVs. One of them is obtained from\p S by substitution of all AddRec sub-expression related to loop \p L with initial value of that SCEV. The second is obtained from \p S by substitution of all AddRec sub-expressions related to loop \p L with post increment of this AddRec in the loop \p L. In both cases all other AddRec sub-expressions (not related to \p L) remain the same. If the \p S contains non-invariant unknown SCEV the function returns CouldNotCompute SCEV in both values of std::pair. For example, for SCEV S={0, +, 1} &lt;L1 &gt; + {0, +, 1} &lt;L2 &gt; and loop L=L1 the function returns pair: first = {0, +, 1} &lt;L2 &gt; second = {1, +, 1} &lt;L1 &gt; + {0, +, 1} &lt;L2 &gt; We can see that for the first AddRec sub-expression it was replaced with 0 (initial value) for the first element and to {1, +, 1} &lt;L1 &gt; (post increment value) for the second one. In both cases AddRec expression related to L2 remains the same.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L878">llvm/include/llvm/Analysis/ScalarEvolution.h:878</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="8631E1BBAE022559"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8631E1BBAE022559">¶</a><code class="hdoc-function-code language-cpp">static SCEV::NoWrapFlags clearFlags(
    SCEV::NoWrapFlags Flags,
    SCEV::NoWrapFlags OffFlags)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L470">llvm/include/llvm/Analysis/ScalarEvolution.h:470</a></p><h4>Parameters</h4><dl><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> OffFlags</b></dt></dl><h3 id="850CAF6795AEFAF3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#850CAF6795AEFAF3">¶</a><code class="hdoc-function-code language-cpp">void collectParametricTerms(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Expr,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Terms)</code></pre></h3><h4>Description</h4><p>Collect parametric terms occurring in step expressions (first step of delinearization).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L992">llvm/include/llvm/Analysis/ScalarEvolution.h:992</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Expr</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Terms</b></dt></dl><h3 id="FD6346A8624776CA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FD6346A8624776CA">¶</a><code class="hdoc-function-code language-cpp">void computeAccessFunctions(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Expr,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;
        Subscripts,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Sizes)</code></pre></h3><h4>Description</h4><p>Return in Subscripts the access functions for each dimension in Sizes (third step of delinearization).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L997">llvm/include/llvm/Analysis/ScalarEvolution.h:997</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Expr</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Subscripts</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Sizes</b></dt></dl><h3 id="2AB83183E1347C08"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2AB83183E1347C08">¶</a><code class="hdoc-function-code language-cpp">bool containsAddRecurrence(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Return true if the SCEV is a scAddRecExpr or it contains scAddRecExpr. The result will be cached in HasRecMap.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L501">llvm/include/llvm/Analysis/ScalarEvolution.h:501</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="D044163D4477108C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D044163D4477108C">¶</a><code class="hdoc-function-code language-cpp">const <a href="r1A478F84B722C311.html">llvm::SCEVAddRecExpr</a>*
convertSCEVToAddRecWithPredicates(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;const llvm::SCEVPredicate*&gt;&amp;
        Preds)</code></pre></h3><h4>Description</h4><p>Tries to convert the \p S expression to an AddRec expression, adding additional predicates to \p Preds as required.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L1086">llvm/include/llvm/Analysis/ScalarEvolution.h:1086</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;const llvm::SCEVPredicate*&gt;&amp;<b> Preds</b></dt></dl><h3 id="FF5766DAE52CE536"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FF5766DAE52CE536">¶</a><code class="hdoc-function-code language-cpp"><a href="r6607998C23E31109.html">Optional</a>&lt;std::pair&lt;
    const SCEV*,
    SmallVector&lt;const SCEVPredicate*, 3&gt;&gt;&gt;
createAddRecFromPHIWithCasts(
    const <a href="rE7F9E7B54D73644E.html">llvm::SCEVUnknown</a>* SymbolicPHI)</code></pre></h3><h4>Description</h4><p>Checks if \p SymbolicPHI can be rewritten as an AddRecExpr under some Predicates. If successful return these  &lt;AddRecExpr , Predicates&gt;; The function is intended to be called from PSCEV (the caller will decide whether to actually add the predicates and carry out the rewrites).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L565">llvm/include/llvm/Analysis/ScalarEvolution.h:565</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE7F9E7B54D73644E.html">llvm::SCEVUnknown</a>*<b> SymbolicPHI</b></dt></dl><h3 id="96F6CBFB0B7B9CA2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#96F6CBFB0B7B9CA2">¶</a><code class="hdoc-function-code language-cpp">void delinearize(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Expr,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;
        Subscripts,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*&gt;&amp; Sizes,
    const llvm::SCEV* ElementSize)</code></pre></h3><h4>Description</h4><p>Split this SCEVAddRecExpr into two vectors of SCEVs representing the subscripts and sizes of an array access. The delinearization is a 3 step process: the first two steps compute the sizes of each subscript and the third step computes the access functions for the delinearized array: 1. Find the terms in the step functions 2. Compute the array size 3. Compute the access function: divide the SCEV by the array size starting with the innermost dimensions found in step 2. The Quotient is the SCEV to be divided in the next step of the recursion. The Remainder is the subscript of the innermost dimension. Loop over all array dimensions computed in step 2. To compute a uniform array size for several memory accesses to the same object, one can collect in step 1 all the step terms for all the memory accesses, and compute in step 2 a unique array shape. This guarantees that the array shape will be the same across all memory accesses. FIXME: We could derive the result of steps 1 and 2 from a description of the array shape given in metadata. Example: A[][n][m] for i for j for k A[j+k][2i][5i] = The initial SCEV: A[{{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k] 1. Find the different terms in the step functions: -&gt; [2*m, 5, n*m, n*m] 2. Compute the array size: sort and unique them -&gt; [n*m, 2*m, 5] find the GCD of all the terms = 1 divide by the GCD and erase constant terms -&gt; [n*m, 2*m] GCD = m divide by GCD -&gt; [n, 2] remove constant terms -&gt; [n] size of the array is A[unknown][n][m] 3. Compute the access function a. Divide {{{0,+,2*m+5}_i, +, n*m}_j, +, n*m}_k by the innermost size m Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k Remainder: {{{0,+,5}_i, +, 0}_j, +, 0}_k The remainder is the subscript of the innermost array dimension: [5i]. b. Divide Quotient: {{{0,+,2}_i, +, n}_j, +, n}_k by next outer size n Quotient: {{{0,+,0}_i, +, 1}_j, +, 1}_k Remainder: {{{0,+,2}_i, +, 0}_j, +, 0}_k The Remainder is the subscript of the next array dimension: [2i]. The subscript of the outermost dimension is the Quotient: [j+k]. Overall, we have: A[][n][m], and the access function: A[j+k][2i][5i].</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L1065">llvm/include/llvm/Analysis/ScalarEvolution.h:1065</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Expr</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Subscripts</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Sizes</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> ElementSize</b></dt></dl><h3 id="1CB570681DB3B179"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1CB570681DB3B179">¶</a><code class="hdoc-function-code language-cpp">bool dominates(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
               const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><h4>Description</h4><p>Return true if elements that makes up the given SCEV dominate the specified basic block.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L966">llvm/include/llvm/Analysis/ScalarEvolution.h:966</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="491176644A57CEA1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#491176644A57CEA1">¶</a><code class="hdoc-function-code language-cpp">void eraseValueFromMap(<a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V)</code></pre></h3><h4>Description</h4><p>Erase Value from ValueExprMap and ExprValueMap.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L504">llvm/include/llvm/Analysis/ScalarEvolution.h:504</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt></dl><h3 id="0157E9ECDAAE3AF7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0157E9ECDAAE3AF7">¶</a><code class="hdoc-function-code language-cpp">void findArrayDimensions(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Terms,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*&gt;&amp; Sizes,
    const llvm::SCEV* ElementSize)</code></pre></h3><h4>Description</h4><p>Compute the array dimensions Sizes from the set of Terms extracted from the memory access function of this SCEVAddRecExpr (second step of delinearization).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L981">llvm/include/llvm/Analysis/ScalarEvolution.h:981</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Terms</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Sizes</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> ElementSize</b></dt></dl><h3 id="49111EFF9D2D1008"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#49111EFF9D2D1008">¶</a><code class="hdoc-function-code language-cpp">void forgetAllLoops()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L783">llvm/include/llvm/Analysis/ScalarEvolution.h:783</a></p><h3 id="FC61E8B092BBB5C8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FC61E8B092BBB5C8">¶</a><code class="hdoc-function-code language-cpp">void forgetLoop(const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>This method should be called by the client when it has changed a loop in a way that may effect ScalarEvolution&apos;s ability to compute a trip count, or if the loop is deleted.  This call is potentially expensive for large loop bodies.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L789">llvm/include/llvm/Analysis/ScalarEvolution.h:789</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="EBD7317AB5325020"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EBD7317AB5325020">¶</a><code class="hdoc-function-code language-cpp">void forgetLoopDispositions(const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Called when the client has changed the disposition of values in this loop. We don&apos;t have a way to invalidate per-loop dispositions. Clear and recompute is simpler.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L807">llvm/include/llvm/Analysis/ScalarEvolution.h:807</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="806F29EA7D6DD58F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#806F29EA7D6DD58F">¶</a><code class="hdoc-function-code language-cpp">void forgetTopmostLoop(const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L795">llvm/include/llvm/Analysis/ScalarEvolution.h:795</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="33481EEAB477AD86"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#33481EEAB477AD86">¶</a><code class="hdoc-function-code language-cpp">void forgetValue(<a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V)</code></pre></h3><h4>Description</h4><p>This method should be called by the client when it has changed a value in a way that may effect its value, or which may disconnect it from a def-use chain linking it to a loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L800">llvm/include/llvm/Analysis/ScalarEvolution.h:800</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt></dl><h3 id="8D5DAE308B72D5B4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8D5DAE308B72D5B4">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getAddExpr(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Ops,
    SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,
    unsigned int Depth = 0)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L517">llvm/include/llvm/Analysis/ScalarEvolution.h:517</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Ops</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b> = SCEV::FlagAnyWrap</dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="A972E14951AC576B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A972E14951AC576B">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getAddExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS,
    SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,
    unsigned int Depth = 0)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L520">llvm/include/llvm/Analysis/ScalarEvolution.h:520</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b> = SCEV::FlagAnyWrap</dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="E235CD2DC6E91C51"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E235CD2DC6E91C51">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getAddExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op0,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op1,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op2,
    SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,
    unsigned int Depth = 0)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L526">llvm/include/llvm/Analysis/ScalarEvolution.h:526</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op0</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op1</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op2</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b> = SCEV::FlagAnyWrap</dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="58030B9DBDD6BB80"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#58030B9DBDD6BB80">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getAddRecExpr(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Operands,
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    SCEV::NoWrapFlags Flags)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L552">llvm/include/llvm/Analysis/ScalarEvolution.h:552</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Operands</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b></dt></dl><h3 id="2E5000DC530253CB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2E5000DC530253CB">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getAddRecExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Start,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Step,
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    SCEV::NoWrapFlags Flags)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L550">llvm/include/llvm/Analysis/ScalarEvolution.h:550</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Start</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Step</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b></dt></dl><h3 id="A34748E38CA525B5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A34748E38CA525B5">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getAddRecExpr(
    const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;
        Operands,
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    SCEV::NoWrapFlags Flags)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L554">llvm/include/llvm/Analysis/ScalarEvolution.h:554</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Operands</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b></dt></dl><h3 id="A40C114A6E09216E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A40C114A6E09216E">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getAnyExtendExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L516">llvm/include/llvm/Analysis/ScalarEvolution.h:516</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="9748AEC537AFEBCB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9748AEC537AFEBCB">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getBackedgeTakenCount(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    llvm::ScalarEvolution::ExitCountKind Kind =
        Exact)</code></pre></h3><h4>Description</h4><p>If the specified loop has a predictable backedge-taken count, return it, otherwise return a SCEVCouldNotCompute object. The backedge-taken count is the number of times the loop header will be branched to from within the loop, assuming there are no abnormal exists like exception throws. This is one less than the trip count of the loop, since it doesn&apos;t count the first iteration, when the header is branched to from outside the loop. Note that it is not valid to call this method on a loop without a loop-invariant backedge-taken count (see hasLoopInvariantBackedgeTakenCount).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L753">llvm/include/llvm/Analysis/ScalarEvolution.h:753</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code">llvm::ScalarEvolution::ExitCountKind<b> Kind</b> = Exact</dt></dl><h3 id="20EDA65C0EB40731"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#20EDA65C0EB40731">¶</a><code class="hdoc-function-code language-cpp">llvm::ScalarEvolution::BlockDisposition
getBlockDisposition(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
                    const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><h4>Description</h4><p>Return the &quot;disposition&quot; of the given SCEV with respect to the given block.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L962">llvm/include/llvm/Analysis/ScalarEvolution.h:962</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="5EB85D53CA699A57"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5EB85D53CA699A57">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getConstant(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    uint64_t V,
    bool isSigned = false)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L512">llvm/include/llvm/Analysis/ScalarEvolution.h:512</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code">uint64_t<b> V</b></dt><dt class="is-family-code">bool<b> isSigned</b> = false</dt></dl><h3 id="0122C7FC73AAE6E4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0122C7FC73AAE6E4">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getConstant(
    const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp; Val)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L511">llvm/include/llvm/Analysis/ScalarEvolution.h:511</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp;<b> Val</b></dt></dl><h3 id="FE2DA0FAD53E4095"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FE2DA0FAD53E4095">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getConstant(
    <a href="r822119A505FDAFD1.html">llvm::ConstantInt</a>* V)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L510">llvm/include/llvm/Analysis/ScalarEvolution.h:510</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r822119A505FDAFD1.html">llvm::ConstantInt</a>*<b> V</b></dt></dl><h3 id="F1E711EFCD35455C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F1E711EFCD35455C">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*
getConstantMaxBackedgeTakenCount(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>When successful, this returns a SCEVConstant that is greater than or equal to (i.e. a &quot;conservative over-approximation&quot;) of the value returend by getBackedgeTakenCount.  If such a value cannot be computed, it returns the SCEVCouldNotCompute object.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L766">llvm/include/llvm/Analysis/ScalarEvolution.h:766</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="C7C9BDC006775D29"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C7C9BDC006775D29">¶</a><code class="hdoc-function-code language-cpp"><a href="rB8F46D3CD599E2BD.html">llvm::LLVMContext</a>&amp; getContext() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L479">llvm/include/llvm/Analysis/ScalarEvolution.h:479</a></p><h3 id="E7F1D07933C82027"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E7F1D07933C82027">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getCouldNotCompute()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L585">llvm/include/llvm/Analysis/ScalarEvolution.h:585</a></p><h3 id="DCA17E6DF319FA1F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DCA17E6DF319FA1F">¶</a><code class="hdoc-function-code language-cpp">const <a href="r36886900CAFBFB15.html">llvm::DataLayout</a>&amp; getDataLayout() const</code></pre></h3><h4>Description</h4><p>Return the DataLayout associated with the module this SCEV instance is operating on.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L1071">llvm/include/llvm/Analysis/ScalarEvolution.h:1071</a></p><h3 id="BE15B149CD253D8E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BE15B149CD253D8E">¶</a><code class="hdoc-function-code language-cpp"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>* getEffectiveSCEVType(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Return a type with the same bitwidth as the given type and which represents how SCEV will treat the given type, for which isSCEVable must return true. For pointer types, this is the pointer-sized integer type.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L494">llvm/include/llvm/Analysis/ScalarEvolution.h:494</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="68FBA55F8932B0F7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#68FBA55F8932B0F7">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getElementSize(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* Inst)</code></pre></h3><h4>Description</h4><p>Return the size of an element read or written by Inst.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L976">llvm/include/llvm/Analysis/ScalarEvolution.h:976</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> Inst</b></dt></dl><h3 id="62CA3F764FA8B7BA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#62CA3F764FA8B7BA">¶</a><code class="hdoc-function-code language-cpp">const <a href="rCEC578313A34AB50.html">llvm::SCEVPredicate</a>* getEqualPredicate(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L1075">llvm/include/llvm/Analysis/ScalarEvolution.h:1075</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="C48BFCB6DB3854FE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C48BFCB6DB3854FE">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getExitCount(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* ExitingBlock,
    llvm::ScalarEvolution::ExitCountKind Kind =
        Exact)</code></pre></h3><h4>Description</h4><p>Return the number of times the backedge executes before the given exit would be taken; if not exactly computable, return SCEVCouldNotCompute.  For a single exit loop, this value is equivelent to the result of getBackedgeTakenCount.  The loop is guaranteed to exit (via *some* exit) before the backedge is executed (ExitCount + 1) times.  Note that there is no guarantee about *which* exit is taken on the exiting iteration.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L740">llvm/include/llvm/Analysis/ScalarEvolution.h:740</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> ExitingBlock</b></dt><dt class="is-family-code">llvm::ScalarEvolution::ExitCountKind<b> Kind</b> = Exact</dt></dl><h3 id="606C04A9A8F9CCF1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#606C04A9A8F9CCF1">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getGEPExpr(
    <a href="rBF3F0ACA4580C32E.html">llvm::GEPOperator</a>* GEP,
    const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;
        IndexExprs)</code></pre></h3><h4>Description</h4><p>Returns an expression for a GEP \p GEP The GEP. The indices contained in the GEP itself are ignored, instead we use IndexExprs.\p IndexExprs The expressions for the indices.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L572">llvm/include/llvm/Analysis/ScalarEvolution.h:572</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rBF3F0ACA4580C32E.html">llvm::GEPOperator</a>*<b> GEP</b></dt><dt class="is-family-code">const <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> IndexExprs</b></dt></dl><h3 id="5A1C8ACD8FA35C32"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5A1C8ACD8FA35C32">¶</a><code class="hdoc-function-code language-cpp">llvm::ScalarEvolution::LoopDisposition
getLoopDisposition(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
                   const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Return the &quot;disposition&quot; of the given SCEV with respect to the given loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L943">llvm/include/llvm/Analysis/ScalarEvolution.h:943</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="EB19A78DCC0AF8BD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EB19A78DCC0AF8BD">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getMinMaxExpr(
    unsigned int Kind,
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Operands)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L574">llvm/include/llvm/Analysis/ScalarEvolution.h:574</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Kind</b></dt><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Operands</b></dt></dl><h3 id="0CD49FD8C38465FB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0CD49FD8C38465FB">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getMinusSCEV(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS,
    SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,
    unsigned int Depth = 0)</code></pre></h3><h4>Description</h4><p>Return LHS-RHS.  Minus is represented in SCEV as A+B*-1.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L607">llvm/include/llvm/Analysis/ScalarEvolution.h:607</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b> = SCEV::FlagAnyWrap</dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="04DBC8AA19E7E476"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#04DBC8AA19E7E476">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getMulExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS,
    SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,
    unsigned int Depth = 0)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L535">llvm/include/llvm/Analysis/ScalarEvolution.h:535</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b> = SCEV::FlagAnyWrap</dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="92478883881D088D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#92478883881D088D">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getMulExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op0,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op1,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op2,
    SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,
    unsigned int Depth = 0)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L541">llvm/include/llvm/Analysis/ScalarEvolution.h:541</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op0</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op1</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op2</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b> = SCEV::FlagAnyWrap</dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="8BF804FE9AFFD793"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8BF804FE9AFFD793">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getMulExpr(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Ops,
    SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap,
    unsigned int Depth = 0)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L532">llvm/include/llvm/Analysis/ScalarEvolution.h:532</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Ops</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b> = SCEV::FlagAnyWrap</dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="8FB8D00D85D64085"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8FB8D00D85D64085">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getNegativeSCEV(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* V,
    SCEV::NoWrapFlags Flags = SCEV::FlagAnyWrap)</code></pre></h3><h4>Description</h4><p>Return the SCEV object corresponding to -V.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L600">llvm/include/llvm/Analysis/ScalarEvolution.h:600</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> V</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b> = SCEV::FlagAnyWrap</dt></dl><h3 id="234D0FD4B8C01701"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#234D0FD4B8C01701">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getNoopOrAnyExtend(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* V,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty)</code></pre></h3><h4>Description</h4><p>Return a SCEV corresponding to a conversion of the input value to the specified type. If the type must be extended, it is extended with unspecified bits. The conversion must not be narrowing.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L634">llvm/include/llvm/Analysis/ScalarEvolution.h:634</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> V</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="AEB20D9716BBB499"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AEB20D9716BBB499">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getNoopOrSignExtend(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* V,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty)</code></pre></h3><h4>Description</h4><p>Return a SCEV corresponding to a conversion of the input value to the specified type.  If the type must be extended, it is sign extended.  The conversion must not be narrowing.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L629">llvm/include/llvm/Analysis/ScalarEvolution.h:629</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> V</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="9BCEAD0C1966742F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9BCEAD0C1966742F">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getNoopOrZeroExtend(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* V,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty)</code></pre></h3><h4>Description</h4><p>Return a SCEV corresponding to a conversion of the input value to the specified type.  If the type must be extended, it is zero extended.  The conversion must not be narrowing.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L624">llvm/include/llvm/Analysis/ScalarEvolution.h:624</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> V</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="FAF5CA7A110D6718"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FAF5CA7A110D6718">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getNotSCEV(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* V)</code></pre></h3><h4>Description</h4><p>Return the SCEV object corresponding to ~V.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L604">llvm/include/llvm/Analysis/ScalarEvolution.h:604</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> V</b></dt></dl><h3 id="E1B124C10CF45D2D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E1B124C10CF45D2D">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getOffsetOfExpr(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* IntTy,
    <a href="r61CB4851BF37ED67.html">llvm::StructType</a>* STy,
    unsigned int FieldNo)</code></pre></h3><h4>Description</h4><p>Return an expression for offsetof on the given field with type IntTy</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L597">llvm/include/llvm/Analysis/ScalarEvolution.h:597</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> IntTy</b></dt><dt class="is-family-code"><a href="r61CB4851BF37ED67.html">llvm::StructType</a>*<b> STy</b></dt><dt class="is-family-code">unsigned int<b> FieldNo</b></dt></dl><h3 id="83338E18642AD956"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#83338E18642AD956">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getOne(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty)</code></pre></h3><h4>Description</h4><p>Return a SCEV for the constant 1 of a specific type.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L591">llvm/include/llvm/Analysis/ScalarEvolution.h:591</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="899050257128472F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#899050257128472F">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getPointerBase(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* V)</code></pre></h3><h4>Description</h4><p>Transitively follow the chain of pointer-type operands until reaching a SCEV that does not have a single pointer operand. This returns a SCEVUnknown pointer for well-formed pointer-type expressions, but corner cases do exist.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L656">llvm/include/llvm/Analysis/ScalarEvolution.h:656</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> V</b></dt></dl><h3 id="645D54F9E2165F69"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#645D54F9E2165F69">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getPredicatedBackedgeTakenCount(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r54D1A136CCE6B02F.html">llvm::SCEVUnionPredicate</a>&amp; Predicates)</code></pre></h3><h4>Description</h4><p>Similar to getBackedgeTakenCount, except it will add a set of SCEV predicates to Predicates that are required to be true in order for the answer to be correct. Predicates can be checked with run-time checks and can be used to perform loop versioning.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L759">llvm/include/llvm/Analysis/ScalarEvolution.h:759</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r54D1A136CCE6B02F.html">llvm::SCEVUnionPredicate</a>&amp;<b> Predicates</b></dt></dl><h3 id="0E1A80CFF51D6D2A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0E1A80CFF51D6D2A">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getSCEV(<a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V)</code></pre></h3><h4>Description</h4><p>Return a SCEV expression for the full generality of the specified expression.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L508">llvm/include/llvm/Analysis/ScalarEvolution.h:508</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt></dl><h3 id="FC8566193215AD66"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FC8566193215AD66">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getSCEVAtScope(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V,
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>This is a convenience function which does getSCEVAtScope(getSCEV(V), L).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L671">llvm/include/llvm/Analysis/ScalarEvolution.h:671</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="D928532BEE1E9DA1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D928532BEE1E9DA1">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getSCEVAtScope(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Return a SCEV expression for the specified value at the specified scope in the program.  The L value specifies a loop nest to evaluate the expression at, where null is the top-level or a specified loop is immediately inside of the loop. This method can be used to compute the exit value for a variable defined in a loop by querying what the value will hold in the parent loop. In the case that a relevant loop exit value cannot be computed, the original value V is returned.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L668">llvm/include/llvm/Analysis/ScalarEvolution.h:668</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="50252ABD7A5E81C6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#50252ABD7A5E81C6">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getSMaxExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L576">llvm/include/llvm/Analysis/ScalarEvolution.h:576</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="465F950738B6E414"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#465F950738B6E414">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getSMaxExpr(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Operands)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L577">llvm/include/llvm/Analysis/ScalarEvolution.h:577</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Operands</b></dt></dl><h3 id="AA3F3D5B1733EB3A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AA3F3D5B1733EB3A">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getSMinExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L580">llvm/include/llvm/Analysis/ScalarEvolution.h:580</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="C4F36D646AC09564"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C4F36D646AC09564">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getSMinExpr(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Operands)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L581">llvm/include/llvm/Analysis/ScalarEvolution.h:581</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Operands</b></dt></dl><h3 id="E05904EE22F66F7E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E05904EE22F66F7E">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getSignExtendExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    unsigned int Depth = 0)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L515">llvm/include/llvm/Analysis/ScalarEvolution.h:515</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="99FC8011772D3E31"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#99FC8011772D3E31">¶</a><code class="hdoc-function-code language-cpp"><a href="r24723C29060272A1.html">llvm::ConstantRange</a> getSignedRange(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Determine the signed range for a particular SCEV. NOTE: This returns a copy of the reference returned by getRangeRef.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L833">llvm/include/llvm/Analysis/ScalarEvolution.h:833</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="688661638EBDB506"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#688661638EBDB506">¶</a><code class="hdoc-function-code language-cpp"><a href="r50D306F9F4C3FD25.html">llvm::APInt</a> getSignedRangeMax(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Determine the max of the signed range for a particular SCEV.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L843">llvm/include/llvm/Analysis/ScalarEvolution.h:843</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="13C60FC889C6518B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#13C60FC889C6518B">¶</a><code class="hdoc-function-code language-cpp"><a href="r50D306F9F4C3FD25.html">llvm::APInt</a> getSignedRangeMin(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Determine the min of the signed range for a particular SCEV.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L838">llvm/include/llvm/Analysis/ScalarEvolution.h:838</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="E424CC6B99CB303F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E424CC6B99CB303F">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getSizeOfExpr(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* IntTy,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* AllocTy)</code></pre></h3><h4>Description</h4><p>Return an expression for sizeof AllocTy that is type IntTy</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L594">llvm/include/llvm/Analysis/ScalarEvolution.h:594</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> IntTy</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> AllocTy</b></dt></dl><h3 id="1F1012E364E5DB86"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1F1012E364E5DB86">¶</a><code class="hdoc-function-code language-cpp">unsigned int getSmallConstantMaxTripCount(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Returns the upper bound of the loop trip count as a normal unsigned value. Returns 0 if the trip count is unknown or not constant.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L703">llvm/include/llvm/Analysis/ScalarEvolution.h:703</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="75FE8D0821509BE1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#75FE8D0821509BE1">¶</a><code class="hdoc-function-code language-cpp">unsigned int getSmallConstantTripCount(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Returns the maximum trip count of the loop if it is a single-exit loop and we can compute a small maximum for that loop. Implemented in terms of the \c getSmallConstantTripCount overload with the single exiting block passed to it. See that routine for details.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L689">llvm/include/llvm/Analysis/ScalarEvolution.h:689</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="A0D4B44638A00C66"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A0D4B44638A00C66">¶</a><code class="hdoc-function-code language-cpp">unsigned int getSmallConstantTripCount(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* ExitingBlock)</code></pre></h3><h4>Description</h4><p>Returns the maximum trip count of this loop as a normal unsigned value. Returns 0 if the trip count is unknown or not constant. This &quot;trip count&quot; assumes that control exits via ExitingBlock. More precisely, it is the number of times that control may reach ExitingBlock before taking the branch. For loops with multiple exits, it may not be the number times that the loop header executes if the loop exits prematurely via another branch.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L698">llvm/include/llvm/Analysis/ScalarEvolution.h:698</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> ExitingBlock</b></dt></dl><h3 id="8ABD43F4D82DE5D1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8ABD43F4D82DE5D1">¶</a><code class="hdoc-function-code language-cpp">unsigned int getSmallConstantTripMultiple(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Returns the largest constant divisor of the trip count of the loop if it is a single-exit loop and we can compute a small maximum for that loop. Implemented in terms of the \c getSmallConstantTripMultiple overload with the single exiting block passed to it. See that routine for details.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L711">llvm/include/llvm/Analysis/ScalarEvolution.h:711</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="60C1192B1E37BD89"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#60C1192B1E37BD89">¶</a><code class="hdoc-function-code language-cpp">unsigned int getSmallConstantTripMultiple(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* ExitingBlock)</code></pre></h3><h4>Description</h4><p>Returns the largest constant divisor of the trip count of this loop as a normal unsigned value, if possible. This means that the actual trip count is always a multiple of the returned value (don&apos;t forget the trip count could very well be zero as well!). As explained in the comments for getSmallConstantTripCount, this assumes that control exits the loop via ExitingBlock.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L719">llvm/include/llvm/Analysis/ScalarEvolution.h:719</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> ExitingBlock</b></dt></dl><h3 id="3F3699624AE56784"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3F3699624AE56784">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getTruncateExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    unsigned int Depth = 0)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L513">llvm/include/llvm/Analysis/ScalarEvolution.h:513</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="E832F5F5C78993F4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E832F5F5C78993F4">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getTruncateOrNoop(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* V,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty)</code></pre></h3><h4>Description</h4><p>Return a SCEV corresponding to a conversion of the input value to the specified type.  The conversion must not be widening.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L638">llvm/include/llvm/Analysis/ScalarEvolution.h:638</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> V</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="4B170B229745840F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4B170B229745840F">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getTruncateOrSignExtend(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* V,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    unsigned int Depth = 0)</code></pre></h3><h4>Description</h4><p>Return a SCEV corresponding to a conversion of the input value to the specified type.  If the type must be extended, it is sign extended.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L618">llvm/include/llvm/Analysis/ScalarEvolution.h:618</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> V</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="1EA829730629E971"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1EA829730629E971">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getTruncateOrZeroExtend(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* V,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    unsigned int Depth = 0)</code></pre></h3><h4>Description</h4><p>Return a SCEV corresponding to a conversion of the input value to the specified type.  If the type must be extended, it is zero extended.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L613">llvm/include/llvm/Analysis/ScalarEvolution.h:613</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> V</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="A12E0669C482446F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A12E0669C482446F">¶</a><code class="hdoc-function-code language-cpp">uint64_t getTypeSizeInBits(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Return the size in bits of the specified type, for which isSCEVable must return true.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L489">llvm/include/llvm/Analysis/ScalarEvolution.h:489</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="AD795EC5982BBD26"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AD795EC5982BBD26">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUDivExactExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L548">llvm/include/llvm/Analysis/ScalarEvolution.h:548</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="FFC8976E5C6C9AE0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FFC8976E5C6C9AE0">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUDivExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L547">llvm/include/llvm/Analysis/ScalarEvolution.h:547</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="42530E0D24A5136C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#42530E0D24A5136C">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUMaxExpr(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Operands)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L579">llvm/include/llvm/Analysis/ScalarEvolution.h:579</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Operands</b></dt></dl><h3 id="AF2262E632298AD6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AF2262E632298AD6">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUMaxExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L578">llvm/include/llvm/Analysis/ScalarEvolution.h:578</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="3E745D9D6CC2A8B5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3E745D9D6CC2A8B5">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUMaxFromMismatchedTypes(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><h4>Description</h4><p>Promote the operands to the wider of the types using zero-extension, and then perform a umax operation with them.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L642">llvm/include/llvm/Analysis/ScalarEvolution.h:642</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="D214A9126D4A7BA7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D214A9126D4A7BA7">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUMinExpr(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Operands)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L583">llvm/include/llvm/Analysis/ScalarEvolution.h:583</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Operands</b></dt></dl><h3 id="77A2C04CD97FB8C2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#77A2C04CD97FB8C2">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUMinExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L582">llvm/include/llvm/Analysis/ScalarEvolution.h:582</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="947B26995AE95C37"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#947B26995AE95C37">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUMinFromMismatchedTypes(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp; Ops)</code></pre></h3><h4>Description</h4><p>Promote the operands to the wider of the types using zero-extension, and then perform a umin operation with them. N-ary function.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L650">llvm/include/llvm/Analysis/ScalarEvolution.h:650</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;const llvm::SCEV*&gt;&amp;<b> Ops</b></dt></dl><h3 id="5DC6F183B0B8D7CD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5DC6F183B0B8D7CD">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUMinFromMismatchedTypes(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><h4>Description</h4><p>Promote the operands to the wider of the types using zero-extension, and then perform a umin operation with them.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L646">llvm/include/llvm/Analysis/ScalarEvolution.h:646</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="622882C33A452EC1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#622882C33A452EC1">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getURemExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L549">llvm/include/llvm/Analysis/ScalarEvolution.h:549</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="EDF16E47CF76F44C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EDF16E47CF76F44C">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getUnknown(<a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L584">llvm/include/llvm/Analysis/ScalarEvolution.h:584</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt></dl><h3 id="A3C21B9F97ABD970"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A3C21B9F97ABD970">¶</a><code class="hdoc-function-code language-cpp"><a href="r24723C29060272A1.html">llvm::ConstantRange</a> getUnsignedRange(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Determine the unsigned range for a particular SCEV. NOTE: This returns a copy of the reference returned by getRangeRef.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L817">llvm/include/llvm/Analysis/ScalarEvolution.h:817</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="A9CA306722D2EB03"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A9CA306722D2EB03">¶</a><code class="hdoc-function-code language-cpp"><a href="r50D306F9F4C3FD25.html">llvm::APInt</a> getUnsignedRangeMax(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Determine the max of the unsigned range for a particular SCEV.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L827">llvm/include/llvm/Analysis/ScalarEvolution.h:827</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="12B617134B215E66"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#12B617134B215E66">¶</a><code class="hdoc-function-code language-cpp"><a href="r50D306F9F4C3FD25.html">llvm::APInt</a> getUnsignedRangeMin(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Determine the min of the unsigned range for a particular SCEV.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L822">llvm/include/llvm/Analysis/ScalarEvolution.h:822</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="74412A6F2FF52412"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#74412A6F2FF52412">¶</a><code class="hdoc-function-code language-cpp"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>* getWiderType(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty1,
                         <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty2) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L497">llvm/include/llvm/Analysis/ScalarEvolution.h:497</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty1</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty2</b></dt></dl><h3 id="44E912DDA06FB20A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#44E912DDA06FB20A">¶</a><code class="hdoc-function-code language-cpp">const <a href="rCEC578313A34AB50.html">llvm::SCEVPredicate</a>* getWrapPredicate(
    const <a href="r1A478F84B722C311.html">llvm::SCEVAddRecExpr</a>* AR,
    SCEVWrapPredicate::IncrementWrapFlags
        AddedFlags)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L1078">llvm/include/llvm/Analysis/ScalarEvolution.h:1078</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r1A478F84B722C311.html">llvm::SCEVAddRecExpr</a>*<b> AR</b></dt><dt class="is-family-code">SCEVWrapPredicate::IncrementWrapFlags<b> AddedFlags</b></dt></dl><h3 id="7D8BAE93D7854760"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7D8BAE93D7854760">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getZero(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty)</code></pre></h3><h4>Description</h4><p>Return a SCEV for the constant 0 of a specific type.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L588">llvm/include/llvm/Analysis/ScalarEvolution.h:588</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="5CF84674F07D714B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5CF84674F07D714B">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* getZeroExtendExpr(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    unsigned int Depth = 0)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L514">llvm/include/llvm/Analysis/ScalarEvolution.h:514</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code">unsigned int<b> Depth</b> = 0</dt></dl><h3 id="530CA2098233C572"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#530CA2098233C572">¶</a><code class="hdoc-function-code language-cpp">bool hasComputableLoopEvolution(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Return true if the given SCEV changes value in a known way in the specified loop.  This property being true implies that the value is variant in the loop AND that we can emit an expression to compute the value of the expression at any particular loop iteration.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L958">llvm/include/llvm/Analysis/ScalarEvolution.h:958</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="8468851D5EF390C4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8468851D5EF390C4">¶</a><code class="hdoc-function-code language-cpp">bool hasLoopInvariantBackedgeTakenCount(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Return true if the specified loop has an analyzable loop-invariant backedge-taken count.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L776">llvm/include/llvm/Analysis/ScalarEvolution.h:776</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="FAE9524C23B28AD8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FAE9524C23B28AD8">¶</a><code class="hdoc-function-code language-cpp">bool hasOperand(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
                const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Op) const</code></pre></h3><h4>Description</h4><p>Test whether the given SCEV has Op as a direct or indirect operand.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L973">llvm/include/llvm/Analysis/ScalarEvolution.h:973</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Op</b></dt></dl><h3 id="B771257D41EC06A3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B771257D41EC06A3">¶</a><code class="hdoc-function-code language-cpp">bool invalidate(
    <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F,
    const <a href="r9EDCE8A1E6A8CDD6.html">llvm::PreservedAnalyses</a>&amp; PA,
    FunctionAnalysisManager::Invalidator&amp; Inv)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L987">llvm/include/llvm/Analysis/ScalarEvolution.h:987</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt><dt class="is-family-code">const <a href="r9EDCE8A1E6A8CDD6.html">llvm::PreservedAnalyses</a>&amp;<b> PA</b></dt><dt class="is-family-code">FunctionAnalysisManager::Invalidator&amp;<b> Inv</b></dt></dl><h3 id="6C65519335F37101"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6C65519335F37101">¶</a><code class="hdoc-function-code language-cpp">bool isAvailableAtLoopEntry(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
                            const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Determine if the SCEV can be evaluated at loop&apos;s entry. It is true if it doesn&apos;t depend on a SCEVUnknown of an instruction which is dominated by the header of loop L.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L952">llvm/include/llvm/Analysis/ScalarEvolution.h:952</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="54357F7EDE1F8FE2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#54357F7EDE1F8FE2">¶</a><code class="hdoc-function-code language-cpp">bool isBackedgeTakenCountMaxOrZero(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Return true if the backedge taken count is either the value returned by getConstantMaxBackedgeTakenCount or zero.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L772">llvm/include/llvm/Analysis/ScalarEvolution.h:772</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="59EC182F7AE4EA1E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#59EC182F7AE4EA1E">¶</a><code class="hdoc-function-code language-cpp">bool isKnownNegative(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Test if the given expression is known to be negative.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L848">llvm/include/llvm/Analysis/ScalarEvolution.h:848</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="137E475552B34728"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#137E475552B34728">¶</a><code class="hdoc-function-code language-cpp">bool isKnownNonNegative(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Test if the given expression is known to be non-negative.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L854">llvm/include/llvm/Analysis/ScalarEvolution.h:854</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="8661A2146C889B11"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8661A2146C889B11">¶</a><code class="hdoc-function-code language-cpp">bool isKnownNonPositive(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Test if the given expression is known to be non-positive.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L857">llvm/include/llvm/Analysis/ScalarEvolution.h:857</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="6C96573F9B796C6D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6C96573F9B796C6D">¶</a><code class="hdoc-function-code language-cpp">bool isKnownNonZero(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Test if the given expression is known to be non-zero.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L860">llvm/include/llvm/Analysis/ScalarEvolution.h:860</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="EA32E419C081EFD4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EA32E419C081EFD4">¶</a><code class="hdoc-function-code language-cpp">bool isKnownOnEveryIteration(
    ICmpInst::Predicate Pred,
    const <a href="r1A478F84B722C311.html">llvm::SCEVAddRecExpr</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><h4>Description</h4><p>Test if the condition described by Pred, LHS, RHS is known to be true on every iteration of the loop of the recurrency LHS.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L909">llvm/include/llvm/Analysis/ScalarEvolution.h:909</a></p><h4>Parameters</h4><dl><dt class="is-family-code">ICmpInst::Predicate<b> Pred</b></dt><dt class="is-family-code">const <a href="r1A478F84B722C311.html">llvm::SCEVAddRecExpr</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="A42279D50CC34904"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A42279D50CC34904">¶</a><code class="hdoc-function-code language-cpp">bool isKnownPositive(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S)</code></pre></h3><h4>Description</h4><p>Test if the given expression is known to be positive.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L851">llvm/include/llvm/Analysis/ScalarEvolution.h:851</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt></dl><h3 id="5DAE7B927B11619D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5DAE7B927B11619D">¶</a><code class="hdoc-function-code language-cpp">bool isKnownPredicate(ICmpInst::Predicate Pred,
                      const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
                      const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><h4>Description</h4><p>Test if the given expression is known to satisfy the condition described by Pred, LHS, and RHS.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L904">llvm/include/llvm/Analysis/ScalarEvolution.h:904</a></p><h4>Parameters</h4><dl><dt class="is-family-code">ICmpInst::Predicate<b> Pred</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="980F75DF5DD78061"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#980F75DF5DD78061">¶</a><code class="hdoc-function-code language-cpp">bool isKnownViaInduction(ICmpInst::Predicate Pred,
                         const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
                         const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><h4>Description</h4><p>We&apos;d like to check the predicate on every iteration of the most dominated loop between loops used in LHS and RHS. To do this we use the following list of steps: 1. Collect set S all loops on which either LHS or RHS depend. 2. If S is non-empty a. Let PD be the element of S which is dominated by all other elements. b. Let E(LHS) be value of LHS on entry of PD. To get E(LHS), we should just take LHS and replace all AddRecs that are attached to PD on with their entry values. Define E(RHS) in the same way. c. Let B(LHS) be value of L on backedge of PD. To get B(LHS), we should just take LHS and replace all AddRecs that are attached to PD on with their backedge values. Define B(RHS) in the same way. d. Note that E(LHS) and E(RHS) are automatically available on entry of PD, so we can assert on that. e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS))  &amp; &amp; isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L899">llvm/include/llvm/Analysis/ScalarEvolution.h:899</a></p><h4>Parameters</h4><dl><dt class="is-family-code">ICmpInst::Predicate<b> Pred</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="7D6003FC337BA740"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7D6003FC337BA740">¶</a><code class="hdoc-function-code language-cpp">bool isLoopBackedgeGuardedByCond(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    ICmpInst::Predicate Pred,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><h4>Description</h4><p>Test whether the backedge of the loop is protected by a conditional between LHS and RHS.  This is used to eliminate casts.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L681">llvm/include/llvm/Analysis/ScalarEvolution.h:681</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code">ICmpInst::Predicate<b> Pred</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="8B646DBF48216FC3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8B646DBF48216FC3">¶</a><code class="hdoc-function-code language-cpp">bool isLoopEntryGuardedByCond(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    ICmpInst::Predicate Pred,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS)</code></pre></h3><h4>Description</h4><p>Test whether entry to the loop is protected by a conditional between LHS and RHS.  This is used to help avoid max expressions in loop trip counts, and to eliminate casts.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L676">llvm/include/llvm/Analysis/ScalarEvolution.h:676</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code">ICmpInst::Predicate<b> Pred</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt></dl><h3 id="4F1C517DD533B2FA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4F1C517DD533B2FA">¶</a><code class="hdoc-function-code language-cpp">bool isLoopInvariant(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
                     const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L)</code></pre></h3><h4>Description</h4><p>Return true if the value of the given SCEV is unchanging in the specified loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L947">llvm/include/llvm/Analysis/ScalarEvolution.h:947</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="AFC98479AD710552"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AFC98479AD710552">¶</a><code class="hdoc-function-code language-cpp">bool isLoopInvariantPredicate(
    ICmpInst::Predicate Pred,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* LHS,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* RHS,
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    ICmpInst::Predicate&amp; InvariantPred,
    const llvm::SCEV*&amp; InvariantLHS,
    const llvm::SCEV*&amp; InvariantRHS)</code></pre></h3><h4>Description</h4><p>Return true if the result of the predicate LHS `Pred` RHS is loop invariant with respect to L.  Set InvariantPred, InvariantLHS and InvariantLHS so that InvariantLHS `InvariantPred` InvariantRHS is the loop invariant form of LHS `Pred` RHS.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L928">llvm/include/llvm/Analysis/ScalarEvolution.h:928</a></p><h4>Parameters</h4><dl><dt class="is-family-code">ICmpInst::Predicate<b> Pred</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> LHS</b></dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> RHS</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code">ICmpInst::Predicate&amp;<b> InvariantPred</b></dt><dt class="is-family-code">const llvm::SCEV*&amp;<b> InvariantLHS</b></dt><dt class="is-family-code">const llvm::SCEV*&amp;<b> InvariantRHS</b></dt></dl><h3 id="7A5D64D2B59C0F3A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7A5D64D2B59C0F3A">¶</a><code class="hdoc-function-code language-cpp">bool isMonotonicPredicate(
    const <a href="r1A478F84B722C311.html">llvm::SCEVAddRecExpr</a>* LHS,
    ICmpInst::Predicate Pred,
    bool&amp; Increasing)</code></pre></h3><h4>Description</h4><p>Return true if, for all loop invariant X, the predicate &quot;LHS `Pred` X&quot; is monotonically increasing or decreasing.  In the former case set `Increasing` to true and in the latter case set `Increasing` to false. A predicate is said to be monotonically increasing if may go from being false to being true as the loop iterates, but never the other way around.  A predicate is said to be monotonically decreasing if may go from being true to being false as the loop iterates, but never the other way around.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L921">llvm/include/llvm/Analysis/ScalarEvolution.h:921</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r1A478F84B722C311.html">llvm::SCEVAddRecExpr</a>*<b> LHS</b></dt><dt class="is-family-code">ICmpInst::Predicate<b> Pred</b></dt><dt class="is-family-code">bool&amp;<b> Increasing</b></dt></dl><h3 id="123C431252299170"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#123C431252299170">¶</a><code class="hdoc-function-code language-cpp">bool isSCEVable(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Test if values of the given type are analyzable within the SCEV framework. This primarily includes integer types, and it can optionally include pointer types if the ScalarEvolution class has access to target-specific information.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L485">llvm/include/llvm/Analysis/ScalarEvolution.h:485</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="3861FF3D65B5064D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3861FF3D65B5064D">¶</a><code class="hdoc-function-code language-cpp">static SCEV::NoWrapFlags maskFlags(
    SCEV::NoWrapFlags Flags,
    int Mask)</code></pre></h3><h4>Description</h4><p>Convenient NoWrapFlags manipulation that hides enum casts and is visible in the ScalarEvolution name space.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L461">llvm/include/llvm/Analysis/ScalarEvolution.h:461</a></p><h4>Parameters</h4><dl><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b></dt><dt class="is-family-code">int<b> Mask</b></dt></dl><h3 id="796FC428BF51334E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#796FC428BF51334E">¶</a><code class="hdoc-function-code language-cpp">void print(<a href="r6E5FB907260499A2.html">llvm::raw_ostream</a>&amp; OS) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L985">llvm/include/llvm/Analysis/ScalarEvolution.h:985</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6E5FB907260499A2.html">llvm::raw_ostream</a>&amp;<b> OS</b></dt></dl><h3 id="1BA3491EC9C9F62F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1BA3491EC9C9F62F">¶</a><code class="hdoc-function-code language-cpp">bool properlyDominates(const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
                       const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB)</code></pre></h3><h4>Description</h4><p>Return true if elements that makes up the given SCEV properly dominate the specified basic block.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L970">llvm/include/llvm/Analysis/ScalarEvolution.h:970</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt></dl><h3 id="78C128E8C487A2E2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#78C128E8C487A2E2">¶</a><code class="hdoc-function-code language-cpp">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* rewriteUsingPredicate(
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* S,
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r54D1A136CCE6B02F.html">llvm::SCEVUnionPredicate</a>&amp; A)</code></pre></h3><h4>Description</h4><p>Re-writes the SCEV according to the Predicates in \p A.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L1082">llvm/include/llvm/Analysis/ScalarEvolution.h:1082</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> S</b></dt><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r54D1A136CCE6B02F.html">llvm::SCEVUnionPredicate</a>&amp;<b> A</b></dt></dl><h3 id="9D4C755FAAD65807"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9D4C755FAAD65807">¶</a><code class="hdoc-function-code language-cpp">static SCEV::NoWrapFlags setFlags(
    SCEV::NoWrapFlags Flags,
    SCEV::NoWrapFlags OnFlags)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L465">llvm/include/llvm/Analysis/ScalarEvolution.h:465</a></p><h4>Parameters</h4><dl><dt class="is-family-code">SCEV::NoWrapFlags<b> Flags</b></dt><dt class="is-family-code">SCEV::NoWrapFlags<b> OnFlags</b></dt></dl><h3 id="A2F58DF02BE5FB97"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A2F58DF02BE5FB97">¶</a><code class="hdoc-function-code language-cpp">void verify() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L986">llvm/include/llvm/Analysis/ScalarEvolution.h:986</a></p><h3 id="EAB1E5756034BC5C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EAB1E5756034BC5C">¶</a><code class="hdoc-function-code language-cpp">~ScalarEvolution()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/ScalarEvolution.h#L477">llvm/include/llvm/Analysis/ScalarEvolution.h:477</a></p></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>