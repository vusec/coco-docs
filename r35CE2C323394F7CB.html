<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class MemorySSAUpdater: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="page35CE2C323394F7CB"><span>class MemorySSAUpdater</span></a></li></ul></nav><main class="content"><h1>class MemorySSAUpdater</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class MemorySSAUpdater { /* full declaration omitted */ };</code></pre><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L70">llvm/include/llvm/Analysis/MemorySSAUpdater.h:70</a></p><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#5B88BCA4A770F2FD"><b>MemorySSAUpdater</b></a>(llvm::MemorySSA * MSSA)</li><li class="is-family-code">public void  <a href="#BA9A8129D79B25EB"><b>applyInsertUpdates</b></a>(ArrayRef&lt;llvm::CFGUpdate&gt; Updates, llvm::DominatorTree &amp; DT)</li><li class="is-family-code">public void  <a href="#7E0585E35F7F3F0D"><b>applyUpdates</b></a>(ArrayRef&lt;llvm::CFGUpdate&gt; Updates, llvm::DominatorTree &amp; DT)</li><li class="is-family-code">public void  <a href="#568698D17753A093"><b>changeCondBranchToUnconditionalTo</b></a>(const llvm::BranchInst * BI, const llvm::BasicBlock * To)</li><li class="is-family-code">public void  <a href="#F3854F5D5A7A0C7E"><b>changeToUnreachable</b></a>(const llvm::Instruction * I)</li><li class="is-family-code">public llvm::MemoryUseOrDef *  <a href="#ED22E80290F30115"><b>createMemoryAccessAfter</b></a>(llvm::Instruction * I, llvm::MemoryAccess * Definition, llvm::MemoryAccess * InsertPt)</li><li class="is-family-code">public llvm::MemoryUseOrDef *  <a href="#F22A9A268F8B1030"><b>createMemoryAccessBefore</b></a>(llvm::Instruction * I, llvm::MemoryAccess * Definition, llvm::MemoryUseOrDef * InsertPt)</li><li class="is-family-code">public llvm::MemoryAccess *  <a href="#427EF505E9999DD1"><b>createMemoryAccessInBB</b></a>(llvm::Instruction * I, llvm::MemoryAccess * Definition, const llvm::BasicBlock * BB, MemorySSA::InsertionPlace Point)</li><li class="is-family-code">public llvm::MemorySSA *  <a href="#A6CD2DA0105CEA2B"><b>getMemorySSA</b></a>() const</li><li class="is-family-code">public void  <a href="#687C92B0849BC520"><b>insertDef</b></a>(llvm::MemoryDef * Def, bool RenameUses = false)</li><li class="is-family-code">public void  <a href="#E1E1B6699F063128"><b>insertUse</b></a>(llvm::MemoryUse * Use, bool RenameUses = false)</li><li class="is-family-code">public void  <a href="#849ACB828B9DCA3A"><b>moveAfter</b></a>(llvm::MemoryUseOrDef * What, llvm::MemoryUseOrDef * Where)</li><li class="is-family-code">public void  <a href="#3B5340302152E6D1"><b>moveAllAfterMergeBlocks</b></a>(llvm::BasicBlock * From, llvm::BasicBlock * To, llvm::Instruction * Start)</li><li class="is-family-code">public void  <a href="#D8BFDC4FC7112695"><b>moveAllAfterSpliceBlocks</b></a>(llvm::BasicBlock * From, llvm::BasicBlock * To, llvm::Instruction * Start)</li><li class="is-family-code">public void  <a href="#087E09B36FF367C5"><b>moveBefore</b></a>(llvm::MemoryUseOrDef * What, llvm::MemoryUseOrDef * Where)</li><li class="is-family-code">public void  <a href="#D1BF6343B61EF074"><b>moveToPlace</b></a>(llvm::MemoryUseOrDef * What, llvm::BasicBlock * BB, MemorySSA::InsertionPlace Where)</li><li class="is-family-code">public void  <a href="#CB1047781B0C7A17"><b>removeBlocks</b></a>(const SmallSetVector&lt;llvm::BasicBlock *, 8&gt; &amp; DeadBlocks)</li><li class="is-family-code">public void  <a href="#8BE8C0C827207448"><b>removeDuplicatePhiEdgesBetween</b></a>(const llvm::BasicBlock * From, const llvm::BasicBlock * To)</li><li class="is-family-code">public void  <a href="#7A284E336DA6DA69"><b>removeEdge</b></a>(llvm::BasicBlock * From, llvm::BasicBlock * To)</li><li class="is-family-code">public void  <a href="#F2465824928060A7"><b>removeMemoryAccess</b></a>(const llvm::Instruction * I, bool OptimizePhis = false)</li><li class="is-family-code">public void  <a href="#4F39E3EACC07CFB4"><b>removeMemoryAccess</b></a>(llvm::MemoryAccess *, bool OptimizePhis = false)</li><li class="is-family-code">public void  <a href="#498907F17C09BF23"><b>updateExitBlocksForClonedLoop</b></a>(ArrayRef&lt;llvm::BasicBlock *&gt; ExitBlocks, const llvm::ValueToValueMapTy &amp; VMap, llvm::DominatorTree &amp; DT)</li><li class="is-family-code">public void  <a href="#0948DDF229CD6A76"><b>updateExitBlocksForClonedLoop</b></a>(ArrayRef&lt;llvm::BasicBlock *&gt; ExitBlocks, ArrayRef&lt;std::unique_ptr&lt;ValueToValueMapTy&gt;&gt; VMaps, llvm::DominatorTree &amp; DT)</li><li class="is-family-code">public void  <a href="#C86F407648D22CB0"><b>updateForClonedBlockIntoPred</b></a>(llvm::BasicBlock * BB, llvm::BasicBlock * P1, const llvm::ValueToValueMapTy &amp; VM)</li><li class="is-family-code">public void  <a href="#F662D1DE68518CA2"><b>updateForClonedLoop</b></a>(const llvm::LoopBlocksRPO &amp; LoopBlocks, ArrayRef&lt;llvm::BasicBlock *&gt; ExitBlocks, const llvm::ValueToValueMapTy &amp; VM, bool IgnoreIncomingWithNoClones = false)</li><li class="is-family-code">public void  <a href="#C1B1A3ABFF0F1AD7"><b>updatePhisWhenInsertingUniqueBackedgeBlock</b></a>(llvm::BasicBlock * LoopHeader, llvm::BasicBlock * LoopPreheader, llvm::BasicBlock * BackedgeBlock)</li><li class="is-family-code">public void  <a href="#A7371C972C9861BF"><b>wireOldPredecessorsToNewImmediatePredecessor</b></a>(llvm::BasicBlock * Old, llvm::BasicBlock * New, ArrayRef&lt;llvm::BasicBlock *&gt; Preds, bool IdenticalEdgesWereMerged = true)</li></ul><h2>Methods</h2><h3 id="5B88BCA4A770F2FD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5B88BCA4A770F2FD">¶</a><code class="hdoc-function-code language-cpp">MemorySSAUpdater(<a href="r044AD4CD5978B88B.html">llvm::MemorySSA</a>* MSSA)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L82">llvm/include/llvm/Analysis/MemorySSAUpdater.h:82</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r044AD4CD5978B88B.html">llvm::MemorySSA</a>*<b> MSSA</b></dt></dl><h3 id="BA9A8129D79B25EB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BA9A8129D79B25EB">¶</a><code class="hdoc-function-code language-cpp">void applyInsertUpdates(
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::CFGUpdate&gt; Updates,
    <a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp; DT)</code></pre></h3><h4>Description</h4><p>Apply CFG insert updates, analogous with the DT edge updates.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L139">llvm/include/llvm/Analysis/MemorySSAUpdater.h:139</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::CFGUpdate&gt;<b> Updates</b></dt><dt class="is-family-code"><a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp;<b> DT</b></dt></dl><h3 id="7E0585E35F7F3F0D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7E0585E35F7F3F0D">¶</a><code class="hdoc-function-code language-cpp">void applyUpdates(
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::CFGUpdate&gt; Updates,
    <a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp; DT)</code></pre></h3><h4>Description</h4><p>Apply CFG updates, analogous with the DT edge updates.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L137">llvm/include/llvm/Analysis/MemorySSAUpdater.h:137</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::CFGUpdate&gt;<b> Updates</b></dt><dt class="is-family-code"><a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp;<b> DT</b></dt></dl><h3 id="568698D17753A093"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#568698D17753A093">¶</a><code class="hdoc-function-code language-cpp">void changeCondBranchToUnconditionalTo(
    const <a href="r5DC16D915F4AEC0F.html">llvm::BranchInst</a>* BI,
    const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* To)</code></pre></h3><h4>Description</h4><p>Conditional branch BI is changed or replaced with an unconditional branch to `To`. Update Phis in BI&apos;s successors to remove BI&apos;s BB.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L256">llvm/include/llvm/Analysis/MemorySSAUpdater.h:256</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r5DC16D915F4AEC0F.html">llvm::BranchInst</a>*<b> BI</b></dt><dt class="is-family-code">const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> To</b></dt></dl><h3 id="F3854F5D5A7A0C7E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F3854F5D5A7A0C7E">¶</a><code class="hdoc-function-code language-cpp">void changeToUnreachable(
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I)</code></pre></h3><h4>Description</h4><p>Instruction I will be changed to an unreachable. Remove all accesses in I&apos;s block that follow I (inclusive), and update the Phis in the blocks&apos; successors.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L252">llvm/include/llvm/Analysis/MemorySSAUpdater.h:252</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt></dl><h3 id="ED22E80290F30115"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#ED22E80290F30115">¶</a><code class="hdoc-function-code language-cpp"><a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>* createMemoryAccessAfter(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I,
    <a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>* Definition,
    <a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>* InsertPt)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L220">llvm/include/llvm/Analysis/MemorySSAUpdater.h:220</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt><dt class="is-family-code"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*<b> Definition</b></dt><dt class="is-family-code"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*<b> InsertPt</b></dt></dl><h3 id="F22A9A268F8B1030"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F22A9A268F8B1030">¶</a><code class="hdoc-function-code language-cpp"><a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>* createMemoryAccessBefore(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I,
    <a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>* Definition,
    <a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>* InsertPt)</code></pre></h3><h4>Description</h4><p>Create a MemoryAccess in MemorySSA before or after an existing MemoryAccess. Returns the new MemoryAccess. This should be called when a memory instruction is created that is being used to replace an existing memory instruction. It will *not* create PHI nodes, or verify the clobbering definition. Note: If a MemoryAccess already exists for I, this function will make it inaccessible and it *must* have removeMemoryAccess called on it.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L217">llvm/include/llvm/Analysis/MemorySSAUpdater.h:217</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt><dt class="is-family-code"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*<b> Definition</b></dt><dt class="is-family-code"><a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>*<b> InsertPt</b></dt></dl><h3 id="427EF505E9999DD1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#427EF505E9999DD1">¶</a><code class="hdoc-function-code language-cpp"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>* createMemoryAccessInBB(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I,
    <a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>* Definition,
    const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
    MemorySSA::InsertionPlace Point)</code></pre></h3><h4>Description</h4><p>Create a MemoryAccess in MemorySSA at a specified point in a block, with a specified clobbering definition. Returns the new MemoryAccess. This should be called when a memory instruction is created that is being used to replace an existing memory instruction. It will *not* create PHI nodes, or verify the clobbering definition. The insertion place is used solely to determine where in the memoryssa access lists the instruction will be placed. The caller is expected to keep ordering the same as instructions. It will return the new MemoryAccess. Note: If a MemoryAccess already exists for I, this function will make it inaccessible and it *must* have removeMemoryAccess called on it.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L203">llvm/include/llvm/Analysis/MemorySSAUpdater.h:203</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt><dt class="is-family-code"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*<b> Definition</b></dt><dt class="is-family-code">const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code">MemorySSA::InsertionPlace<b> Point</b></dt></dl><h3 id="A6CD2DA0105CEA2B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A6CD2DA0105CEA2B">¶</a><code class="hdoc-function-code language-cpp"><a href="r044AD4CD5978B88B.html">llvm::MemorySSA</a>* getMemorySSA() const</code></pre></h3><h4>Description</h4><p>Get handle on MemorySSA.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L260">llvm/include/llvm/Analysis/MemorySSAUpdater.h:260</a></p><h3 id="687C92B0849BC520"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#687C92B0849BC520">¶</a><code class="hdoc-function-code language-cpp">void insertDef(<a href="r3CDB563A131E2ADE.html">llvm::MemoryDef</a>* Def,
               bool RenameUses = false)</code></pre></h3><h4>Description</h4><p>Insert a definition into the MemorySSA IR.  RenameUses will rename any use below the new def block (and any inserted phis).  RenameUses should be set to true if the definition may cause new aliases for loads below it.  This is not the case for hoisting or sinking or other forms of code *movement*. It *is* the case for straight code insertion. For example: store a if (foo) { } load a Moving the store into the if block, and calling insertDef, does not require RenameUses. However, changing it to: store a if (foo) { store b } load a Where a mayalias b, *does* require RenameUses be set to true.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L101">llvm/include/llvm/Analysis/MemorySSAUpdater.h:101</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r3CDB563A131E2ADE.html">llvm::MemoryDef</a>*<b> Def</b></dt><dt class="is-family-code">bool<b> RenameUses</b> = false</dt></dl><h3 id="E1E1B6699F063128"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E1E1B6699F063128">¶</a><code class="hdoc-function-code language-cpp">void insertUse(<a href="r94B1880002A8844E.html">llvm::MemoryUse</a>* Use,
               bool RenameUses = false)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L102">llvm/include/llvm/Analysis/MemorySSAUpdater.h:102</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r94B1880002A8844E.html">llvm::MemoryUse</a>*<b> Use</b></dt><dt class="is-family-code">bool<b> RenameUses</b> = false</dt></dl><h3 id="849ACB828B9DCA3A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#849ACB828B9DCA3A">¶</a><code class="hdoc-function-code language-cpp">void moveAfter(<a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>* What,
               <a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>* Where)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L142">llvm/include/llvm/Analysis/MemorySSAUpdater.h:142</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>*<b> What</b></dt><dt class="is-family-code"><a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>*<b> Where</b></dt></dl><h3 id="3B5340302152E6D1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3B5340302152E6D1">¶</a><code class="hdoc-function-code language-cpp">void moveAllAfterMergeBlocks(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* From,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* To,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* Start)</code></pre></h3><h4>Description</h4><p>`From` block was merged into `To`. There is a CFG edge from `To` to `From`.`To` still branches to `From`, but all instructions were moved and `From` is now an empty block; `From` is about to be deleted. Move all accesses from `From` to `To` starting at instruction `Start`. `To` may have multiple successors, `From` has a single predecessor. `From` may have successors with MPhi nodes, replace their incoming block with `To`. |------|        |------| |  To  |        |  To  | |------|        |      | ||      =&gt;   |      | \ /           |      | |------|        |      |   &lt; - Start | From |        |      | |------|        |------|</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L174">llvm/include/llvm/Analysis/MemorySSAUpdater.h:174</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> From</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> To</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> Start</b></dt></dl><h3 id="D8BFDC4FC7112695"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D8BFDC4FC7112695">¶</a><code class="hdoc-function-code language-cpp">void moveAllAfterSpliceBlocks(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* From,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* To,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* Start)</code></pre></h3><h4>Description</h4><p>`From` block was spliced into `From` and `To`. There is a CFG edge from `From` to `To`. Move all accesses from `From` to `To` starting at instruction `Start`. `To` is newly created BB, so empty of MemorySSA::MemoryAccesses. Edges are already updated, so successors of `To` with MPhi nodes need to update incoming block. |------|        |------| | From |        | From | |      |        |------| |      |           || |      |   =&gt;       \ / |      |        |------|   &lt; - Start |      |        |  To  | |------|        |------|</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L158">llvm/include/llvm/Analysis/MemorySSAUpdater.h:158</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> From</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> To</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> Start</b></dt></dl><h3 id="087E09B36FF367C5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#087E09B36FF367C5">¶</a><code class="hdoc-function-code language-cpp">void moveBefore(<a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>* What,
                <a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>* Where)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L141">llvm/include/llvm/Analysis/MemorySSAUpdater.h:141</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>*<b> What</b></dt><dt class="is-family-code"><a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>*<b> Where</b></dt></dl><h3 id="D1BF6343B61EF074"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D1BF6343B61EF074">¶</a><code class="hdoc-function-code language-cpp">void moveToPlace(<a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>* What,
                 <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
                 MemorySSA::InsertionPlace Where)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L143">llvm/include/llvm/Analysis/MemorySSAUpdater.h:143</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rB46D5D32112FBFC1.html">llvm::MemoryUseOrDef</a>*<b> What</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code">MemorySSA::InsertionPlace<b> Where</b></dt></dl><h3 id="CB1047781B0C7A17"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CB1047781B0C7A17">¶</a><code class="hdoc-function-code language-cpp">void removeBlocks(
    const <a href="r48EAEBEF008DCB19.html">SmallSetVector</a>&lt;llvm::BasicBlock*, 8&gt;&amp;
        DeadBlocks)</code></pre></h3><h4>Description</h4><p>Remove all MemoryAcceses in a set of BasicBlocks about to be deleted. Assumption we make here: all uses of deleted defs and phi must either occur in blocks about to be deleted (thus will be deleted as well), or they occur in phis that will simply lose an incoming value. Deleted blocks still have successor info, but their predecessor edges and Phi nodes may already be updated. Instructions in DeadBlocks should be deleted after this call.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L247">llvm/include/llvm/Analysis/MemorySSAUpdater.h:247</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r48EAEBEF008DCB19.html">SmallSetVector</a>&lt;llvm::BasicBlock*, 8&gt;&amp;<b> DeadBlocks</b></dt></dl><h3 id="8BE8C0C827207448"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8BE8C0C827207448">¶</a><code class="hdoc-function-code language-cpp">void removeDuplicatePhiEdgesBetween(
    const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* From,
    const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* To)</code></pre></h3><h4>Description</h4><p>Update the MemoryPhi in `To` to have a single incoming edge from `From`, following a CFG change that replaced multiple edges (switch) with a direct branch.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L109">llvm/include/llvm/Analysis/MemorySSAUpdater.h:109</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> From</b></dt><dt class="is-family-code">const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> To</b></dt></dl><h3 id="7A284E336DA6DA69"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7A284E336DA6DA69">¶</a><code class="hdoc-function-code language-cpp">void removeEdge(<a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* From,
                <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* To)</code></pre></h3><h4>Description</h4><p>Update the MemoryPhi in `To` following an edge deletion between `From` and `To`. If `To` becomes unreachable, a call to removeBlocks should be made.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L105">llvm/include/llvm/Analysis/MemorySSAUpdater.h:105</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> From</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> To</b></dt></dl><h3 id="F2465824928060A7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F2465824928060A7">¶</a><code class="hdoc-function-code language-cpp">void removeMemoryAccess(
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I,
    bool OptimizePhis = false)</code></pre></h3><h4>Description</h4><p>Remove MemoryAccess for a given instruction, if a MemoryAccess exists. This should be called when an instruction (load/store) is deleted from the program.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L235">llvm/include/llvm/Analysis/MemorySSAUpdater.h:235</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt><dt class="is-family-code">bool<b> OptimizePhis</b> = false</dt></dl><h3 id="4F39E3EACC07CFB4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4F39E3EACC07CFB4">¶</a><code class="hdoc-function-code language-cpp">void removeMemoryAccess(<a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*,
                        bool OptimizePhis = false)</code></pre></h3><h4>Description</h4><p>Remove a MemoryAccess from MemorySSA, including updating all definitions and uses. This should be called when a memory instruction that has a MemoryAccess associated with it is erased from the program.  For example, if a store or load is simply erased (not replaced), removeMemoryAccess should be called on the MemoryAccess for that store/load.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L230">llvm/include/llvm/Analysis/MemorySSAUpdater.h:230</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r63E2593244B7B70D.html">llvm::MemoryAccess</a>*<b> </b></dt><dt class="is-family-code">bool<b> OptimizePhis</b> = false</dt></dl><h3 id="498907F17C09BF23"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#498907F17C09BF23">¶</a><code class="hdoc-function-code language-cpp">void updateExitBlocksForClonedLoop(
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::BasicBlock*&gt; ExitBlocks,
    const <a href="r86C9E2213D130A0C.html">llvm::ValueToValueMapTy</a>&amp; VMap,
    <a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp; DT)</code></pre></h3><h4>Description</h4><p>Update phi nodes in exit block successors following cloning. Exit blocks that were not cloned don&apos;t have additional predecessors added.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L129">llvm/include/llvm/Analysis/MemorySSAUpdater.h:129</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::BasicBlock*&gt;<b> ExitBlocks</b></dt><dt class="is-family-code">const <a href="r86C9E2213D130A0C.html">llvm::ValueToValueMapTy</a>&amp;<b> VMap</b></dt><dt class="is-family-code"><a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp;<b> DT</b></dt></dl><h3 id="0948DDF229CD6A76"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0948DDF229CD6A76">¶</a><code class="hdoc-function-code language-cpp">void updateExitBlocksForClonedLoop(
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::BasicBlock*&gt; ExitBlocks,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;std::unique_ptr&lt;ValueToValueMapTy&gt;&gt;
        VMaps,
    <a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp; DT)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L132">llvm/include/llvm/Analysis/MemorySSAUpdater.h:132</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::BasicBlock*&gt;<b> ExitBlocks</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;std::unique_ptr&lt;ValueToValueMapTy&gt;&gt;<b> VMaps</b></dt><dt class="is-family-code"><a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>&amp;<b> DT</b></dt></dl><h3 id="C86F407648D22CB0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C86F407648D22CB0">¶</a><code class="hdoc-function-code language-cpp">void updateForClonedBlockIntoPred(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BB,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* P1,
    const <a href="r86C9E2213D130A0C.html">llvm::ValueToValueMapTy</a>&amp; VM)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L125">llvm/include/llvm/Analysis/MemorySSAUpdater.h:125</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BB</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> P1</b></dt><dt class="is-family-code">const <a href="r86C9E2213D130A0C.html">llvm::ValueToValueMapTy</a>&amp;<b> VM</b></dt></dl><h3 id="F662D1DE68518CA2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F662D1DE68518CA2">¶</a><code class="hdoc-function-code language-cpp">void updateForClonedLoop(
    const <a href="rF8890F50ECB27B32.html">llvm::LoopBlocksRPO</a>&amp; LoopBlocks,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::BasicBlock*&gt; ExitBlocks,
    const <a href="r86C9E2213D130A0C.html">llvm::ValueToValueMapTy</a>&amp; VM,
    bool IgnoreIncomingWithNoClones = false)</code></pre></h3><h4>Description</h4><p>Update MemorySSA after a loop was cloned, given the blocks in RPO order, the exit blocks and a 1:1 mapping of all blocks and instructions cloned. This involves duplicating all defs and uses in the cloned blocks Updating phi nodes in exit block successors is done separately.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L119">llvm/include/llvm/Analysis/MemorySSAUpdater.h:119</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rF8890F50ECB27B32.html">llvm::LoopBlocksRPO</a>&amp;<b> LoopBlocks</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::BasicBlock*&gt;<b> ExitBlocks</b></dt><dt class="is-family-code">const <a href="r86C9E2213D130A0C.html">llvm::ValueToValueMapTy</a>&amp;<b> VM</b></dt><dt class="is-family-code">bool<b> IgnoreIncomingWithNoClones</b> = false</dt></dl><h3 id="C1B1A3ABFF0F1AD7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C1B1A3ABFF0F1AD7">¶</a><code class="hdoc-function-code language-cpp">void updatePhisWhenInsertingUniqueBackedgeBlock(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* LoopHeader,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* LoopPreheader,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BackedgeBlock)</code></pre></h3><h4>Description</h4><p>Update MemorySSA when inserting a unique backedge block for a loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L112">llvm/include/llvm/Analysis/MemorySSAUpdater.h:112</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> LoopHeader</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> LoopPreheader</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BackedgeBlock</b></dt></dl><h3 id="A7371C972C9861BF"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A7371C972C9861BF">¶</a><code class="hdoc-function-code language-cpp">void wireOldPredecessorsToNewImmediatePredecessor(
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* Old,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* New,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::BasicBlock*&gt; Preds,
    bool IdenticalEdgesWereMerged = true)</code></pre></h3><h4>Description</h4><p>A new empty BasicBlock (New) now branches directly to Old. Some of Old&apos;s predecessors (Preds) are now branching to New instead of Old. If New is the only predecessor, move Old&apos;s Phi, if present, to New. Otherwise, add a new Phi in New with appropriate incoming values, and update the incoming values in Old&apos;s Phi node too, if present.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/MemorySSAUpdater.h#L181">llvm/include/llvm/Analysis/MemorySSAUpdater.h:181</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> Old</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> New</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::BasicBlock*&gt;<b> Preds</b></dt><dt class="is-family-code">bool<b> IdenticalEdgesWereMerged</b> = true</dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>