<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class LSUnit: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li><a href="namespaces.html#EC803CF954D1ADA3"><span>namespace mca</span></a></li><li class="is-active"><a aria-current="pageFC4B62864B3472D9"><span>class LSUnit</span></a></li></ul></nav><main class="content"><h1>class LSUnit</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class LSUnit : public LSUnitBase { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>Default Load/Store Unit (LS Unit) for simulated processors. Each load (or store) consumes one entry in the load (or store) queue. Rules are: 1) A younger load is allowed to pass an older load only if there are no stores nor barriers in between the two loads. 2) An younger store is not allowed to pass an older store. 3) A younger store is not allowed to pass an older load. 4) A younger load is allowed to pass an older store only if the load does not alias with the store. This class optimistically assumes that loads don&apos;t alias store operations. Under this assumption, younger loads are always allowed to pass older stores (this would only affects rule 4). Essentially, this class doesn&apos;t perform any sort alias analysis to identify aliasing loads and stores. To enforce aliasing between loads and stores, flag `AssumeNoAlias` must be set to `false` by the constructor of LSUnit. Note that this class doesn&apos;t know about the existence of different memory types for memory operations (example: write-through, write-combining, etc.). Derived classes are responsible for implementing that extra knowledge, and provide different sets of rules for loads and stores by overriding method `isReady()`. To emulate a write-combining memory type, rule 2. must be relaxed in a derived class to enable the reordering of non-aliasing store operations. No assumptions are made by this class on the size of the store buffer.  This class doesn&apos;t know how to identify cases where store-to-load forwarding may occur. LSUnit doesn&apos;t attempt to predict whether a load or store hits or misses the L1 cache. To be more specific, LSUnit doesn&apos;t know anything about cache hierarchy and memory types. It only knows if an instruction &quot;mayLoad&quot; and/or &quot;mayStore&quot;. For loads, the scheduling model provides an &quot;optimistic&quot; load-to-use latency (which usually matches the load-to-use latency for when there is a hit in the L1D). Derived classes may expand this knowledge. Class MCInstrDesc in LLVM doesn&apos;t know about serializing operations, nor memory-barrier like instructions. LSUnit conservatively assumes that an instruction which `mayLoad` and has `unmodeled side effects` behave like a &quot;soft&quot; load-barrier. That means, it serializes loads without forcing a flush of the load queue. Similarly, instructions that both `mayStore` and have `unmodeled side effects` are treated like store barriers. A full memory barrier is a &apos;mayLoad&apos; and &apos;mayStore&apos; instruction with unmodeled side effects. This is obviously inaccurate, but this is the best that we can do at the moment. Each load/store barrier consumes one entry in the load/store queue. A load/store barrier enforces ordering of loads/stores: - A younger load cannot pass a load barrier. - A younger store cannot pass a store barrier. A younger load has to wait for the memory load barrier to execute. A load/store barrier is &quot;executed&quot; when it becomes the oldest entry in the load/store queue(s). That also means, all the older loads/stores have already been executed.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h#L375">llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:375</a></p><p>Inherits from: <a href="r6EEC9808288CBE32.html">LSUnitBase</a></p><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#B35929D34EE0CF28"><b>LSUnit</b></a>(const llvm::MCSchedModel &amp; SM)</li><li class="is-family-code">public  <a href="#90B9D1E791AED372"><b>LSUnit</b></a>(const llvm::MCSchedModel &amp; SM, unsigned int LQ, unsigned int SQ)</li><li class="is-family-code">public  <a href="#34A9E55A64CB5D34"><b>LSUnit</b></a>(const llvm::MCSchedModel &amp; SM, unsigned int LQ, unsigned int SQ, bool AssumeNoAlias)</li><li class="is-family-code">public unsigned int  <a href="#232F80A2F4169C12"><b>dispatch</b></a>(const llvm::mca::InstRef &amp; IR)</li><li class="is-family-code">public llvm::mca::LSUnitBase::Status  <a href="#896CFE498AAD0563"><b>isAvailable</b></a>(const llvm::mca::InstRef &amp; IR) const</li><li class="is-family-code">public void  <a href="#1A508B5E19006D99"><b>onInstructionExecuted</b></a>(const llvm::mca::InstRef &amp; IR)</li></ul><p>Inherited from <a href="r6EEC9808288CBE32.html">LSUnitBase</a>:</p><ul><li class="is-family-code"><a href="r6EEC9808288CBE32.html#905B5252919A7862">public <b>acquireLQSlot</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#A3319DB0B3B605D8">public <b>acquireSQSlot</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#7D2EF30AD255A891">public <b>assumeNoAlias</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#3EF83A7815075CE4">public <b>createMemoryGroup</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#C213F40C253DB7A1">public <b>cycleEvent</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#1D2AED92836F4571">public <b>dispatch</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#74FF5B8989EB2335">public <b>dump</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#A6D5B5188AE8ABDD">public <b>getGroup</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#837679D5A5FF258F">public <b>getGroup</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#7CC4394618099666">public <b>getLoadQueueSize</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#8C5024BDF2587DD2">public <b>getStoreQueueSize</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#13496E6AA381F049">public <b>getUsedLQEntries</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#D74F6FA21A0A3D15">public <b>getUsedSQEntries</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#7FE59533B13ABB54">public <b>hasDependentUsers</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#1DC2A6610F16C0FA">public <b>isAvailable</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#8A310A2D122A5794">public <b>isLQEmpty</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#033C9D22E141B0F5">public <b>isLQFull</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#C73FC1550D15A64B">public <b>isPending</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#7519DD175ECD21A2">public <b>isReady</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#B25E3F9002B41B02">public <b>isSQEmpty</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#9D1A6A45B241F437">public <b>isSQFull</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#E131A19CE7C4E191">public <b>isValidGroupID</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#992148C1CB7DED8C">public <b>isWaiting</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#37DED01BC0D92364">public <b>onInstructionExecuted</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#2DB68EE0AC1B78D7">public <b>onInstructionIssued</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#807445E2AF0D50D4">public <b>onInstructionRetired</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#552B647369BACD8B">public <b>releaseLQSlot</b></a></li><li class="is-family-code"><a href="r6EEC9808288CBE32.html#1993F22709DC56EC">public <b>releaseSQSlot</b></a></li></ul><p>Inherited from <a href="r250414C369B823D9.html">HardwareUnit</a>:</p><ul></ul><h2>Methods</h2><h3 id="B35929D34EE0CF28"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B35929D34EE0CF28">¶</a><code class="hdoc-function-code language-cpp">LSUnit(const <a href="rAF8698858E59FDB0.html">llvm::MCSchedModel</a>&amp; SM)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h#L419">llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:419</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAF8698858E59FDB0.html">llvm::MCSchedModel</a>&amp;<b> SM</b></dt></dl><h3 id="90B9D1E791AED372"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#90B9D1E791AED372">¶</a><code class="hdoc-function-code language-cpp">LSUnit(const <a href="rAF8698858E59FDB0.html">llvm::MCSchedModel</a>&amp; SM,
       unsigned int LQ,
       unsigned int SQ)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h#L421">llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:421</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAF8698858E59FDB0.html">llvm::MCSchedModel</a>&amp;<b> SM</b></dt><dt class="is-family-code">unsigned int<b> LQ</b></dt><dt class="is-family-code">unsigned int<b> SQ</b></dt></dl><h3 id="34A9E55A64CB5D34"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#34A9E55A64CB5D34">¶</a><code class="hdoc-function-code language-cpp">LSUnit(const <a href="rAF8698858E59FDB0.html">llvm::MCSchedModel</a>&amp; SM,
       unsigned int LQ,
       unsigned int SQ,
       bool AssumeNoAlias)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h#L423">llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:423</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rAF8698858E59FDB0.html">llvm::MCSchedModel</a>&amp;<b> SM</b></dt><dt class="is-family-code">unsigned int<b> LQ</b></dt><dt class="is-family-code">unsigned int<b> SQ</b></dt><dt class="is-family-code">bool<b> AssumeNoAlias</b></dt></dl><h3 id="232F80A2F4169C12"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#232F80A2F4169C12">¶</a><code class="hdoc-function-code language-cpp">unsigned int dispatch(
    const <a href="r9D24E7ED0C0C7942.html">llvm::mca::InstRef</a>&amp; IR)</code></pre></h3><h4>Description</h4><p>Allocates LS resources for instruction IR. This method assumes that a previous call to `isAvailable(IR)` succeeded returning LSU_AVAILABLE. Rules are: By default, rules are: 1. A store may not pass a previous store. 2. A load may not pass a previous store unless flag &apos;NoAlias&apos; is set. 3. A load may pass a previous load. 4. A store may not pass a previous load (regardless of flag &apos;NoAlias&apos;). 5. A load has to wait until an older load barrier is fully executed. 6. A store has to wait until an older store barrier is fully executed.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h#L444">llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:444</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r9D24E7ED0C0C7942.html">llvm::mca::InstRef</a>&amp;<b> IR</b></dt></dl><h3 id="896CFE498AAD0563"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#896CFE498AAD0563">¶</a><code class="hdoc-function-code language-cpp">llvm::mca::LSUnitBase::Status isAvailable(
    const <a href="r9D24E7ED0C0C7942.html">llvm::mca::InstRef</a>&amp; IR) const</code></pre></h3><h4>Description</h4><p>Returns LSU_AVAILABLE if there are enough load/store queue entries to accomodate instruction IR.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h#L429">llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:429</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r9D24E7ED0C0C7942.html">llvm::mca::InstRef</a>&amp;<b> IR</b></dt></dl><h3 id="1A508B5E19006D99"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1A508B5E19006D99">¶</a><code class="hdoc-function-code language-cpp">void onInstructionExecuted(
    const <a href="r9D24E7ED0C0C7942.html">llvm::mca::InstRef</a>&amp; IR)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/MCA/HardwareUnits/LSUnit.h#L446">llvm/include/llvm/MCA/HardwareUnits/LSUnit.h:446</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r9D24E7ED0C0C7942.html">llvm::mca::InstRef</a>&amp;<b> IR</b></dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>