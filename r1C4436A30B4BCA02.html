<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class FunctionComparator: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="page1C4436A30B4BCA02"><span>class FunctionComparator</span></a></li></ul></nav><main class="content"><h1>class FunctionComparator</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class FunctionComparator { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>FunctionComparator - Compares two functions to determine whether or not they will generate machine code with the same behaviour. DataLayout is used if available. The comparator always fails conservatively (erring on the side of claiming that two functions are different).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L93">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:93</a></p><h2>Member Variables</h2><dl><dt class="is-family-code" id="var_FnL">protected  const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* <b>FnL</b></dt><dt class="is-family-code" id="var_FnR">protected  const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* <b>FnR</b></dt></dl><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#1349A4C68D8B3578"><b>FunctionComparator</b></a>(const llvm::Function * F1, const llvm::Function * F2, llvm::GlobalNumberState * GN)</li><li class="is-family-code">protected void  <a href="#49D54F0CC6C5DBF7"><b>beginCompare</b></a>()</li><li class="is-family-code">protected int  <a href="#AC6139642E293396"><b>cmpAPFloats</b></a>(const llvm::APFloat &amp; L, const llvm::APFloat &amp; R) const</li><li class="is-family-code">protected int  <a href="#D087F754DC6FCAD1"><b>cmpAPInts</b></a>(const llvm::APInt &amp; L, const llvm::APInt &amp; R) const</li><li class="is-family-code">protected int  <a href="#F9375F21348F556F"><b>cmpBasicBlocks</b></a>(const llvm::BasicBlock * BBL, const llvm::BasicBlock * BBR) const</li><li class="is-family-code">protected int  <a href="#515CE4E458A8B144"><b>cmpConstants</b></a>(const llvm::Constant * L, const llvm::Constant * R) const</li><li class="is-family-code">protected int  <a href="#03FA566492A2A070"><b>cmpGlobalValues</b></a>(llvm::GlobalValue * L, llvm::GlobalValue * R) const</li><li class="is-family-code">protected int  <a href="#E8DB798C70446DE5"><b>cmpMem</b></a>(llvm::StringRef L, llvm::StringRef R) const</li><li class="is-family-code">protected int  <a href="#9FE4F2D85356D3C3"><b>cmpNumbers</b></a>(uint64_t L, uint64_t R) const</li><li class="is-family-code">protected int  <a href="#B390BFAA4079C83B"><b>cmpOperations</b></a>(const llvm::Instruction * L, const llvm::Instruction * R, bool &amp; needToCmpOperands) const</li><li class="is-family-code">protected int  <a href="#20CC53F333108C7C"><b>cmpTypes</b></a>(llvm::Type * TyL, llvm::Type * TyR) const</li><li class="is-family-code">protected int  <a href="#13A2AB88F1E37430"><b>cmpValues</b></a>(const llvm::Value * L, const llvm::Value * R) const</li><li class="is-family-code">public int  <a href="#171E1A832540F65C"><b>compare</b></a>()</li><li class="is-family-code">protected int  <a href="#C834E69801E84837"><b>compareSignature</b></a>() const</li><li class="is-family-code">public static llvm::FunctionComparator::FunctionHash  <a href="#EA957578F3072B63"><b>functionHash</b></a>(llvm::Function &amp;)</li></ul><h2>Methods</h2><h3 id="1349A4C68D8B3578"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1349A4C68D8B3578">¶</a><code class="hdoc-function-code language-cpp">FunctionComparator(const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* F1,
                   const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* F2,
                   <a href="rE2DB038E8CD593DA.html">llvm::GlobalNumberState</a>* GN)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L95">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:95</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> F1</b></dt><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> F2</b></dt><dt class="is-family-code"><a href="rE2DB038E8CD593DA.html">llvm::GlobalNumberState</a>*<b> GN</b></dt></dl><h3 id="49D54F0CC6C5DBF7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#49D54F0CC6C5DBF7">¶</a><code class="hdoc-function-code language-cpp">void beginCompare()</code></pre></h3><h4>Description</h4><p>Start the comparison.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L109">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:109</a></p><h3 id="AC6139642E293396"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AC6139642E293396">¶</a><code class="hdoc-function-code language-cpp">int cmpAPFloats(const <a href="r66A1A9331FF88FE0.html">llvm::APFloat</a>&amp; L,
                const <a href="r66A1A9331FF88FE0.html">llvm::APFloat</a>&amp; R) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L324">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:324</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r66A1A9331FF88FE0.html">llvm::APFloat</a>&amp;<b> L</b></dt><dt class="is-family-code">const <a href="r66A1A9331FF88FE0.html">llvm::APFloat</a>&amp;<b> R</b></dt></dl><h3 id="D087F754DC6FCAD1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D087F754DC6FCAD1">¶</a><code class="hdoc-function-code language-cpp">int cmpAPInts(const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp; L,
              const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp; R) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L323">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:323</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp;<b> L</b></dt><dt class="is-family-code">const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp;<b> R</b></dt></dl><h3 id="F9375F21348F556F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F9375F21348F556F">¶</a><code class="hdoc-function-code language-cpp">int cmpBasicBlocks(
    const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BBL,
    const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* BBR) const</code></pre></h3><h4>Description</h4><p>Test whether two basic blocks have equivalent behaviour.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L118">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:118</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BBL</b></dt><dt class="is-family-code">const <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> BBR</b></dt></dl><h3 id="515CE4E458A8B144"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#515CE4E458A8B144">¶</a><code class="hdoc-function-code language-cpp">int cmpConstants(const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* L,
                 const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* R) const</code></pre></h3><h4>Description</h4><p>Constants comparison. Its analog to lexicographical comparison between hypothetical numbers of next format: &lt;bitcastability -trait&gt; &lt;raw -bit-contents&gt; 1. Bitcastability. Check whether L&apos;s type could be losslessly bitcasted to R&apos;s type. On this stage method, in case when lossless bitcast is not possible method returns -1 or 1, thus also defining which type is greater in context of bitcastability. Stage 0: If types are equal in terms of cmpTypes, then we can go straight to the contents comparison. If types differ, remember types comparison result and check whether we still can bitcast types. Stage 1: Types that satisfies isFirstClassType conditions are always greater then others. Stage 2: Vector is greater then non-vector. If both types are vectors, then vector with greater bitwidth is greater. If both types are vectors with the same bitwidth, then types are bitcastable, and we can skip other stages, and go to contents comparison. Stage 3: Pointer types are greater than non-pointers. If both types are pointers of the same address space - go to contents comparison. Different address spaces: pointer with greater address space is greater. Stage 4: Types are neither vectors, nor pointers. And they differ. We don&apos;t know how to bitcast them. So, we better don&apos;t do it, and return types comparison result (so it determines the relationship among constants we don&apos;t know how to bitcast). Just for clearance, let&apos;s see how the set of constants could look on single dimension axis: [NFCT], [FCT, &quot;others&quot;], [FCT, pointers], [FCT, vectors] Where: NFCT - Not a FirstClassType FCT - FirstClassTyp: 2. Compare raw contents. It ignores types on this stage and only compares bits from L and R. Returns 0, if L and R has equivalent contents. -1 or 1 if values are different. Pretty trivial: 2.1. If contents are numbers, compare numbers. Ints with greater bitwidth are greater. Ints with same bitwidths compared by their contents. 2.2. &quot;And so on&quot;. Just to avoid discrepancies with comments perhaps it would be better to read the implementation itself. 3. And again about overall picture. Let&apos;s look back at how the ordered set of constants will look like: [NFCT], [FCT, &quot;others&quot;], [FCT, pointers], [FCT, vectors] Now look, what could be inside [FCT, &quot;others&quot;], for example: [FCT, &quot;others&quot;] = [ [double 0.1], [double 1.23], [i32 1], [i32 2], { double 1.0 },       ; StructTyID, NumElements = 1 { i32 1 },            ; StructTyID, NumElements = 1 { double 1, i32 1 },  ; StructTyID, NumElements = 2 { i32 1, double 1 }   ; StructTyID, NumElements = 2 ] Let&apos;s explain the order. Float numbers will be less than integers, just because of cmpType terms: FloatTyID  &lt; IntegerTyID. Floats (with same fltSemantics) are sorted according to their value. Then you can see integers, and they are, like a floats, could be easy sorted among each others. The structures. Structures are grouped at the tail, again because of their TypeID: StructTyID &gt; IntegerTyID &gt; FloatTyID. Structures with greater number of elements are greater. Structures with greater elements going first are greater. The same logic with vectors, arrays and other possible complex types. Bitcastable constants. Let&apos;s assume, that some constant, belongs to some group of &quot;so-called-equal&quot; values with different types, and at the same time belongs to another group of constants with equal types and &quot;really&quot; equal values. Now, prove that this is impossible: If constant A with type TyA is bitcastable to B with type TyB, then: 1. All constants with equal types to TyA, are bitcastable to B. Since those should be vectors (if TyA is vector), pointers (if TyA is pointer), or else (if TyA equal to TyB), those types should be equal to TyB. 2. All constants with non-equal, but bitcastable types to TyA, are bitcastable to B. Once again, just because we allow it to vectors and pointers only. This statement could be expanded as below: 2.1. All vectors with equal bitwidth to vector A, has equal bitwidth to vector B, and thus bitcastable to B as well. 2.2. All pointers of the same address space, no matter what they point to, bitcastable. So if C is pointer, it could be bitcasted to A and to B. So any constant equal or bitcastable to A is equal or bitcastable to B. QED. In another words, for pointers and vectors, we ignore top-level type and look at their particular properties (bit-width for vectors, and address space for pointers). If these properties are equal - compare their contents.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L222">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:222</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> L</b></dt><dt class="is-family-code">const <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> R</b></dt></dl><h3 id="03FA566492A2A070"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#03FA566492A2A070">¶</a><code class="hdoc-function-code language-cpp">int cmpGlobalValues(<a href="rC19E204A1DC9E834.html">llvm::GlobalValue</a>* L,
                    <a href="rC19E204A1DC9E834.html">llvm::GlobalValue</a>* R) const</code></pre></h3><h4>Description</h4><p>Compares two global values by number. Uses the GlobalNumbersState to identify the same gobals across function calls.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L226">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:226</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rC19E204A1DC9E834.html">llvm::GlobalValue</a>*<b> L</b></dt><dt class="is-family-code"><a href="rC19E204A1DC9E834.html">llvm::GlobalValue</a>*<b> R</b></dt></dl><h3 id="E8DB798C70446DE5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E8DB798C70446DE5">¶</a><code class="hdoc-function-code language-cpp">int cmpMem(<a href="rECFCAF624C04523A.html">llvm::StringRef</a> L,
           <a href="rECFCAF624C04523A.html">llvm::StringRef</a> R) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L325">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:325</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rECFCAF624C04523A.html">llvm::StringRef</a><b> L</b></dt><dt class="is-family-code"><a href="rECFCAF624C04523A.html">llvm::StringRef</a><b> R</b></dt></dl><h3 id="9FE4F2D85356D3C3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9FE4F2D85356D3C3">¶</a><code class="hdoc-function-code language-cpp">int cmpNumbers(uint64_t L, uint64_t R) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L322">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:322</a></p><h4>Parameters</h4><dl><dt class="is-family-code">uint64_t<b> L</b></dt><dt class="is-family-code">uint64_t<b> R</b></dt></dl><h3 id="B390BFAA4079C83B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B390BFAA4079C83B">¶</a><code class="hdoc-function-code language-cpp">int cmpOperations(const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* L,
                  const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* R,
                  bool&amp; needToCmpOperands) const</code></pre></h3><h4>Description</h4><p>Compare two Instructions for equivalence, similar to Instruction::isSameOperationAs. Stages are listed in &quot;most significant stage first&quot; order: On each stage below, we do comparison between some left and right operation parts. If parts are non-equal, we assign parts comparison result to the operation comparison result and exit from method. Otherwise we proceed to the next stage. Stages: 1. Operations opcodes. Compared as numbers. 2. Number of operands. 3. Operation types. Compared with cmpType method. 4. Compare operation subclass optional data as stream of bytes: just convert it to integers and call cmpNumbers. 5. Compare in operation operand types with cmpType in most significant operand first order. 6. Last stage. Check operations for some specific attributes. For example, for Load it would be: 6.1.Load: volatile (as boolean flag) 6.2.Load: alignment (as integer numbers) 6.3.Load: ordering (as underlying enum class value) 6.4.Load: synch-scope (as integer numbers) 6.5.Load: range metadata (as integer ranges) On this stage its better to see the code, since its not more than 10-15 strings for particular instruction, and could change sometimes. Sets \p needToCmpOperands to true if the operands of the instructions still must be compared afterwards. In this case it&apos;s already guaranteed that both instructions have the same number of operands.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L277">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:277</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> L</b></dt><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> R</b></dt><dt class="is-family-code">bool&amp;<b> needToCmpOperands</b></dt></dl><h3 id="20CC53F333108C7C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#20CC53F333108C7C">¶</a><code class="hdoc-function-code language-cpp">int cmpTypes(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* TyL,
             <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* TyR) const</code></pre></h3><h4>Description</h4><p>cmpType - compares two types, defines total ordering among the types set. Return values: 0 if types are equal, -1 if Left is less than Right, +1 if Left is greater than Right. Description: Comparison is broken onto stages. Like in lexicographical comparison stage coming first has higher priority. On each explanation stage keep in mind total ordering properties. 0. Before comparison we coerce pointer types of 0 address space to integer. We also don&apos;t bother with same type at left and right, so just return 0 in this case. 1. If types are of different kind (different type IDs). Return result of type IDs comparison, treating them as numbers. 2. If types are integers, check that they have the same width. If they are vectors, check that they have the same count and subtype. 3. Types have the same ID, so check whether they are one of: * Void * Float * Double * X86_FP80 * FP128 * PPC_FP128 * Label * Metadata We can treat these types as equal whenever their IDs are same. 4. If Left and Right are pointers, return result of address space comparison (numbers comparison). We can treat pointer types of same address space as equal. 5. If types are complex. Then both Left and Right are to be expanded and their element types will be checked with the same way. If we get Res != 0 on some stage, return it. Otherwise return 0. 6. For all other cases put llvm_unreachable.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L320">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:320</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> TyL</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> TyR</b></dt></dl><h3 id="13A2AB88F1E37430"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#13A2AB88F1E37430">¶</a><code class="hdoc-function-code language-cpp">int cmpValues(const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* L,
              const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* R) const</code></pre></h3><h4>Description</h4><p>Assign or look up previously assigned numbers for the two values, and return whether the numbers are equal. Numbers are assigned in the order visited. Comparison order: Stage 0: Value that is function itself is always greater then others. If left and right values are references to their functions, then they are equal. Stage 1: Constants are greater than non-constants. If both left and right are constants, then the result of cmpConstants is used as cmpValues result. Stage 2: InlineAsm instances are greater than others. If both left and right are InlineAsm instances, InlineAsm* pointers casted to integers and compared as numbers. Stage 3: For all other cases we compare order we meet these values in their functions. If right value was met first during scanning, then left value is greater. In another words, we compare serial numbers, for more details see comments for sn_mapL and sn_mapR.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L246">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:246</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> L</b></dt><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> R</b></dt></dl><h3 id="171E1A832540F65C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#171E1A832540F65C">¶</a><code class="hdoc-function-code language-cpp">int compare()</code></pre></h3><h4>Description</h4><p>Test whether the two functions have equivalent behaviour.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L100">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:100</a></p><h3 id="C834E69801E84837"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C834E69801E84837">¶</a><code class="hdoc-function-code language-cpp">int compareSignature() const</code></pre></h3><h4>Description</h4><p>Compares the signature and other general attributes of the two functions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L115">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:115</a></p><h3 id="EA957578F3072B63"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EA957578F3072B63">¶</a><code class="hdoc-function-code language-cpp">static <a href="rADBA2A8E0906EC47.html">llvm::Function</a>Comparator::FunctionHash
functionHash(llvm::Function&amp;)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/Utils/FunctionComparator.h#L105">llvm/include/llvm/Transforms/Utils/FunctionComparator.h:105</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> </b></dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>