<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>struct Attributor: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="page2C6CFCCDD6551E5E"><span>struct Attributor</span></a></li></ul></nav><main class="content"><h1>struct Attributor</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">struct Attributor { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>The fixpoint analysis framework that orchestrates the attribute deduction. The Attributor provides a general abstract analysis framework (guided fixpoint iteration) as well as helper functions for the deduction of (LLVM-IR) attributes. However, also other code properties can be deduced, propagated, and ultimately manifested through the Attributor framework. This is particularly useful if these properties interact with attributes and a co-scheduled deduction allows to improve the solution. Even if not, thus if attributes/properties are completely isolated, they should use the Attributor framework to reduce the number of fixpoint iteration frameworks in the code base. Note that the Attributor design makes sure that isolated attributes are not impacted, in any way, by others derived at the same time if there is no cross-reasoning performed. The public facing interface of the Attributor is kept simple and basically allows abstract attributes to one thing, query abstract attributes in-flight. There are two reasons to do this: a) The optimistic state of one abstract attribute can justify an optimistic state of another, allowing to framework to end up with an optimistic (=best possible) fixpoint instead of one based solely on information in the IR. b) This avoids reimplementing various kinds of lookups, e.g., to check for existing IR attributes, in favor of a single lookups interface provided by an abstract attribute subclass. NOTE: The mechanics of adding a new &quot;concrete&quot; abstract attribute are described in the file comment.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L685">llvm/include/llvm/Transforms/IPO/Attributor.h:685</a></p><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#F8959912D3894694"><b>Attributor</b></a>(llvm::InformationCache &amp; InfoCache, unsigned int DepRecomputeInterval, DenseSet&lt;const char *&gt; * Whitelist = nullptr)</li><li class="is-family-code">public void  <a href="#CAD5B21C2BC570FD"><b>changeToUnreachableAfterManifest</b></a>(llvm::Instruction * I)</li><li class="is-family-code">public bool  <a href="#174B3A297C0AE0B8"><b>changeUseAfterManifest</b></a>(llvm::Use &amp; U, llvm::Value &amp; NV)</li><li class="is-family-code">public bool  <a href="#A167505643E019E0"><b>changeValueAfterManifest</b></a>(llvm::Value &amp; V, llvm::Value &amp; NV)</li><li class="is-family-code">public bool  <a href="#9A67EBA370116FFA"><b>checkForAllCallLikeInstructions</b></a>(const function_ref&lt;bool (llvm::Instruction &amp;)&gt; &amp; Pred, const llvm::AbstractAttribute &amp; QueryingAA)</li><li class="is-family-code">public bool  <a href="#882B0B1C9356E4EF"><b>checkForAllCallSites</b></a>(const function_ref&lt;bool (llvm::AbstractCallSite)&gt; &amp; Pred, const llvm::AbstractAttribute &amp; QueryingAA, bool RequireAllCallSites)</li><li class="is-family-code">public bool  <a href="#47BCE09F20876BF9"><b>checkForAllInstructions</b></a>(const function_ref&lt;bool (llvm::Instruction &amp;)&gt; &amp; Pred, const llvm::AbstractAttribute &amp; QueryingAA, const ArrayRef&lt;unsigned int&gt; &amp; Opcodes)</li><li class="is-family-code">public bool  <a href="#C21C530609A1C158"><b>checkForAllReadWriteInstructions</b></a>(const llvm::function_ref&lt;bool (Instruction &amp;)&gt; &amp; Pred, llvm::AbstractAttribute &amp; QueryingAA)</li><li class="is-family-code">public bool  <a href="#2B7DC80D11343427"><b>checkForAllReturnedValues</b></a>(const function_ref&lt;bool (llvm::Value &amp;)&gt; &amp; Pred, const llvm::AbstractAttribute &amp; QueryingAA)</li><li class="is-family-code">public bool  <a href="#0953C3A4DFC5FB44"><b>checkForAllReturnedValuesAndReturnInsts</b></a>(const function_ref&lt;bool (llvm::Value &amp;, const SmallSetVector&lt;llvm::ReturnInst *, 4&gt; &amp;)&gt; &amp; Pred, const llvm::AbstractAttribute &amp; QueryingAA)</li><li class="is-family-code">public bool  <a href="#4755EAF5F6600F38"><b>checkForAllUses</b></a>(const function_ref&lt;bool (const llvm::Use &amp;, bool &amp;)&gt; &amp; Pred, const llvm::AbstractAttribute &amp; QueryingAA, const llvm::Value &amp; V)</li><li class="is-family-code">public void  <a href="#C22DB9D7094F7D51"><b>deleteAfterManifest</b></a>(llvm::Instruction &amp; I)</li><li class="is-family-code">public void  <a href="#2EB057046D0F3B40"><b>deleteAfterManifest</b></a>(llvm::BasicBlock &amp; BB)</li><li class="is-family-code">public void  <a href="#852CD797D8D1CF4A"><b>deleteAfterManifest</b></a>(llvm::Function &amp; F)</li><li class="is-family-code">public template &lt;typename AAType&gt;const AAType &amp;  <a href="#5787380E74E3BFDB"><b>getAAFor</b></a>(const llvm::AbstractAttribute &amp; QueryingAA, const llvm::IRPosition &amp; IRP, bool TrackDependence = true, llvm::DepClassTy DepClass = DepClassTy::REQUIRED)</li><li class="is-family-code">public const llvm::DataLayout &amp;  <a href="#BBF61EE9C6472680"><b>getDataLayout</b></a>() const</li><li class="is-family-code">public llvm::InformationCache &amp;  <a href="#D4EA8E73B03E588D"><b>getInfoCache</b></a>()</li><li class="is-family-code">public static const llvm::Value *  <a href="#7219AB17CB9CB450"><b>getPointerOperand</b></a>(const llvm::Instruction * I, bool AllowVolatile)</li><li class="is-family-code">public void  <a href="#4E706EB69BDE1B35"><b>identifyDefaultAbstractAttributes</b></a>(llvm::Function &amp; F)</li><li class="is-family-code">public void  <a href="#D114D41ED0910DC5"><b>initializeInformationCache</b></a>(llvm::Function &amp; F)</li><li class="is-family-code">public bool  <a href="#860030B3B848A2A9"><b>isAssumedDead</b></a>(const llvm::AbstractAttribute &amp; AA, const llvm::AAIsDead * LivenessAA)</li><li class="is-family-code">public void  <a href="#D052CE07D0F6CF25"><b>markLiveInternalFunction</b></a>(const llvm::Function &amp; F)</li><li class="is-family-code">public void  <a href="#64F54126BFDADB36"><b>recordDependence</b></a>(const llvm::AbstractAttribute &amp; FromAA, const llvm::AbstractAttribute &amp; ToAA, llvm::DepClassTy DepClass)</li><li class="is-family-code">public template &lt;typename AAType&gt;AAType &amp;  <a href="#17E2F7E3C341D1E9"><b>registerAA</b></a>(AAType &amp; AA)</li><li class="is-family-code">public bool  <a href="#7C7C704CB571D2E7"><b>registerFunctionSignatureRewrite</b></a>(llvm::Argument &amp; Arg, ArrayRef&lt;llvm::Type *&gt; ReplacementTypes, ArgumentReplacementInfo::CalleeRepairCBTy &amp;&amp; CalleeRepairCB, ArgumentReplacementInfo::ACSRepairCBTy &amp;&amp; ACSRepairCB)</li><li class="is-family-code">public void  <a href="#C3830E8ECF4B3D86"><b>registerInvokeWithDeadSuccessor</b></a>(llvm::InvokeInst &amp; II)</li><li class="is-family-code">public llvm::ChangeStatus  <a href="#E85481E4FA6AF841"><b>run</b></a>(llvm::Module &amp; M)</li><li class="is-family-code">public  <a href="#876FECFBE31D7BDA"><b>~Attributor</b></a>()</li></ul><h2>Methods</h2><h3 id="F8959912D3894694"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F8959912D3894694">Â¶</a><code class="hdoc-function-code language-cpp">Attributor(
    <a href="r6FFAD89A81F8A036.html">llvm::InformationCache</a>&amp; InfoCache,
    unsigned int DepRecomputeInterval,
    <a href="r30EF9B14EFC7AC5C.html">DenseSet</a>&lt;const char*&gt;* Whitelist = nullptr)</code></pre></h3><h4>Description</h4><p>Constructor</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L693">llvm/include/llvm/Transforms/IPO/Attributor.h:693</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6FFAD89A81F8A036.html">llvm::InformationCache</a>&amp;<b> InfoCache</b></dt><dd>Cache to hold various information accessible for the abstract attributes.</dd><dt class="is-family-code">unsigned int<b> DepRecomputeInterval</b></dt><dd>Number of iterations until the dependences between abstract attributes are recomputed.</dd><dt class="is-family-code"><a href="r30EF9B14EFC7AC5C.html">DenseSet</a>&lt;const char*&gt;*<b> Whitelist</b> = nullptr</dt><dd>If not null, a set limiting the attribute opportunities.</dd></dl><h3 id="CAD5B21C2BC570FD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CAD5B21C2BC570FD">Â¶</a><code class="hdoc-function-code language-cpp">void changeToUnreachableAfterManifest(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I)</code></pre></h3><h4>Description</h4><p>Record that \p I is to be replaced with `unreachable` after information was manifested.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L865">llvm/include/llvm/Transforms/IPO/Attributor.h:865</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt></dl><h3 id="174B3A297C0AE0B8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#174B3A297C0AE0B8">Â¶</a><code class="hdoc-function-code language-cpp">bool changeUseAfterManifest(<a href="r6C343CD5AE971AE1.html">llvm::Use</a>&amp; U,
                            <a href="r4EC65655F3BC4E59.html">llvm::Value</a>&amp; NV)</code></pre></h3><h4>Description</h4><p>Record that \p U is to be replaces with \p NV after information was manifested. This also triggers deletion of trivially dead istructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L810">llvm/include/llvm/Transforms/IPO/Attributor.h:810</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6C343CD5AE971AE1.html">llvm::Use</a>&amp;<b> U</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>&amp;<b> NV</b></dt></dl><h3 id="A167505643E019E0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A167505643E019E0">Â¶</a><code class="hdoc-function-code language-cpp">bool changeValueAfterManifest(<a href="r4EC65655F3BC4E59.html">llvm::Value</a>&amp; V,
                              <a href="r4EC65655F3BC4E59.html">llvm::Value</a>&amp; NV)</code></pre></h3><h4>Description</h4><p>Helper function to replace all uses of \p V with \p NV. Return true if there is any change.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L823">llvm/include/llvm/Transforms/IPO/Attributor.h:823</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>&amp;<b> V</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>&amp;<b> NV</b></dt></dl><h3 id="9A67EBA370116FFA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9A67EBA370116FFA">Â¶</a><code class="hdoc-function-code language-cpp">bool checkForAllCallLikeInstructions(
    const function_ref&lt;bool(llvm::Instruction&amp;)&gt;&amp;
        Pred,
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; QueryingAA)</code></pre></h3><h4>Description</h4><p>Check \p Pred on all call-like instructions (=CallBased derived). See checkForAllCallLikeInstructions(...) for more information.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L1029">llvm/include/llvm/Transforms/IPO/Attributor.h:1029</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const function_ref&lt;bool(llvm::Instruction&amp;)&gt;&amp;<b> Pred</b></dt><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> QueryingAA</b></dt></dl><h3 id="882B0B1C9356E4EF"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#882B0B1C9356E4EF">Â¶</a><code class="hdoc-function-code language-cpp">bool checkForAllCallSites(
    const function_ref&lt;
        bool(llvm::AbstractCallSite)&gt;&amp; Pred,
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; QueryingAA,
    bool RequireAllCallSites)</code></pre></h3><h4>Description</h4><p>Check \p Pred on all function call sites. This method will evaluate \p Pred on call sites and return true if \p Pred holds in every call sites. However, this is only possible all call sites are known, hence the function has internal linkage.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L995">llvm/include/llvm/Transforms/IPO/Attributor.h:995</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const function_ref&lt;bool(llvm::AbstractCallSite)&gt;&amp;<b> Pred</b></dt><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> QueryingAA</b></dt><dt class="is-family-code">bool<b> RequireAllCallSites</b></dt></dl><h3 id="47BCE09F20876BF9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#47BCE09F20876BF9">Â¶</a><code class="hdoc-function-code language-cpp">bool checkForAllInstructions(
    const function_ref&lt;bool(llvm::Instruction&amp;)&gt;&amp;
        Pred,
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; QueryingAA,
    const <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt;&amp; Opcodes)</code></pre></h3><h4>Description</h4><p>Check \p Pred on all instructions with an opcode present in \p Opcodes. This method will evaluate \p Pred on all instructions with an opcode present in \p Opcode and return true if \p Pred holds on all of them.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L1021">llvm/include/llvm/Transforms/IPO/Attributor.h:1021</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const function_ref&lt;bool(llvm::Instruction&amp;)&gt;&amp;<b> Pred</b></dt><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> QueryingAA</b></dt><dt class="is-family-code">const <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt;&amp;<b> Opcodes</b></dt></dl><h3 id="C21C530609A1C158"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C21C530609A1C158">Â¶</a><code class="hdoc-function-code language-cpp">bool checkForAllReadWriteInstructions(
    const llvm::function_ref&lt;bool(Instruction&amp;)&gt;&amp;
        Pred,
    <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; QueryingAA)</code></pre></h3><h4>Description</h4><p>Check \p Pred on all Read/Write instructions. This method will evaluate \p Pred on all instructions that read or write to memory present in the information cache and return true if \p Pred holds on all of them.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L1042">llvm/include/llvm/Transforms/IPO/Attributor.h:1042</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const llvm::function_ref&lt;bool(Instruction&amp;)&gt;&amp;<b> Pred</b></dt><dt class="is-family-code"><a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> QueryingAA</b></dt></dl><h3 id="2B7DC80D11343427"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2B7DC80D11343427">Â¶</a><code class="hdoc-function-code language-cpp">bool checkForAllReturnedValues(
    const function_ref&lt;bool(llvm::Value&amp;)&gt;&amp; Pred,
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; QueryingAA)</code></pre></h3><h4>Description</h4><p>Check \p Pred on all values potentially returned by the function associated with \p QueryingAA. This is the context insensitive version of the method above.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L1014">llvm/include/llvm/Transforms/IPO/Attributor.h:1014</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const function_ref&lt;bool(llvm::Value&amp;)&gt;&amp;<b> Pred</b></dt><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> QueryingAA</b></dt></dl><h3 id="0953C3A4DFC5FB44"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0953C3A4DFC5FB44">Â¶</a><code class="hdoc-function-code language-cpp">bool checkForAllReturnedValuesAndReturnInsts(
    const function_ref&lt;bool(
        llvm::Value&amp;,
        const SmallSetVector&lt;llvm::ReturnInst*,
                             4&gt;&amp;)&gt;&amp; Pred,
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; QueryingAA)</code></pre></h3><h4>Description</h4><p>Check \p Pred on all values potentially returned by \p F. This method will evaluate \p Pred on all values potentially returned by the function associated with \p QueryingAA. The returned values are matched with their respective return instructions. Returns true if \p Pred holds on all of them.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L1005">llvm/include/llvm/Transforms/IPO/Attributor.h:1005</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const function_ref&lt;bool(
    llvm::Value&amp;,
    const SmallSetVector&lt;llvm::ReturnInst*, 4&gt;&amp;)&gt;&amp;<b> Pred</b></dt><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> QueryingAA</b></dt></dl><h3 id="4755EAF5F6600F38"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4755EAF5F6600F38">Â¶</a><code class="hdoc-function-code language-cpp">bool checkForAllUses(
    const function_ref&lt;bool(const llvm::Use&amp;,
                            bool&amp;)&gt;&amp; Pred,
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; QueryingAA,
    const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>&amp; V)</code></pre></h3><h4>Description</h4><p>Check \p Pred on all (transitive) uses of \p V. This method will evaluate \p Pred on all (transitive) uses of the associated value and return true if \p Pred holds every time.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L896">llvm/include/llvm/Transforms/IPO/Attributor.h:896</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const function_ref&lt;bool(const llvm::Use&amp;, bool&amp;)&gt;&amp;<b> Pred</b></dt><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> QueryingAA</b></dt><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>&amp;<b> V</b></dt></dl><h3 id="C22DB9D7094F7D51"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C22DB9D7094F7D51">Â¶</a><code class="hdoc-function-code language-cpp">void deleteAfterManifest(<a href="rE266D8602316BABC.html">llvm::Instruction</a>&amp; I)</code></pre></h3><h4>Description</h4><p>Record that \p I is deleted after information was manifested. This also triggers deletion of trivially dead istructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L878">llvm/include/llvm/Transforms/IPO/Attributor.h:878</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>&amp;<b> I</b></dt></dl><h3 id="2EB057046D0F3B40"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2EB057046D0F3B40">Â¶</a><code class="hdoc-function-code language-cpp">void deleteAfterManifest(<a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>&amp; BB)</code></pre></h3><h4>Description</h4><p>Record that \p BB is deleted after information was manifested. This also triggers deletion of trivially dead istructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L882">llvm/include/llvm/Transforms/IPO/Attributor.h:882</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>&amp;<b> BB</b></dt></dl><h3 id="852CD797D8D1CF4A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#852CD797D8D1CF4A">Â¶</a><code class="hdoc-function-code language-cpp">void deleteAfterManifest(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F)</code></pre></h3><h4>Description</h4><p>Record that \p F is deleted after information was manifested.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L885">llvm/include/llvm/Transforms/IPO/Attributor.h:885</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt></dl><h3 id="5787380E74E3BFDB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5787380E74E3BFDB">Â¶</a><code class="hdoc-function-code language-cpp">template &lt;typename AAType&gt;
const AAType&amp; getAAFor(
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; QueryingAA,
    const <a href="rC81257CA68D97389.html">llvm::IRPosition</a>&amp; IRP,
    bool TrackDependence = true,
    llvm::DepClassTy DepClass =
        DepClassTy::REQUIRED)</code></pre></h3><h4>Description</h4><p>Lookup an abstract attribute of type \p AAType at position \p IRP. While no abstract attribute is found equivalent positions are checked, see SubsumingPositionIterator. Thus, the returned abstract attribute might be anchored at a different position, e.g., the callee if \p IRP is a call base. This method is the only (supported) way an abstract attribute can retrieve information from another abstract attribute. As an example, take an abstract attribute that determines the memory access behavior for a argument (readnone, readonly, ...). It should use `getAAFor` to get the most optimistic information for other abstract attributes in-flight, e.g. the one reasoning about the &quot;captured&quot; state for the argument or the one reasoning on the memory access behavior of the function as a whole. If the flag \p TrackDependence is set to false the dependence from\p QueryingAA to the return abstract attribute is not automatically recorded. This should only be used if the caller will record the dependence explicitly if necessary, thus if it the returned abstract attribute is used for reasoning. To record the dependences explicitly use the `Attributor::recordDependence` method.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L733">llvm/include/llvm/Transforms/IPO/Attributor.h:733</a></p><h4>Templates</h4><dl><dt class="is-family-code"><b> AAType</b></dt></dl><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> QueryingAA</b></dt><dt class="is-family-code">const <a href="rC81257CA68D97389.html">llvm::IRPosition</a>&amp;<b> IRP</b></dt><dt class="is-family-code">bool<b> TrackDependence</b> = true</dt><dt class="is-family-code">llvm::DepClassTy<b> DepClass</b> = DepClassTy::REQUIRED</dt></dl><h3 id="BBF61EE9C6472680"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BBF61EE9C6472680">Â¶</a><code class="hdoc-function-code language-cpp">const <a href="r36886900CAFBFB15.html">llvm::DataLayout</a>&amp; getDataLayout() const</code></pre></h3><h4>Description</h4><p>Return the data layout associated with the anchor scope.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L1047">llvm/include/llvm/Transforms/IPO/Attributor.h:1047</a></p><h3 id="D4EA8E73B03E588D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D4EA8E73B03E588D">Â¶</a><code class="hdoc-function-code language-cpp"><a href="r6FFAD89A81F8A036.html">llvm::InformationCache</a>&amp; getInfoCache()</code></pre></h3><h4>Description</h4><p>Return the internal information cache.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L777">llvm/include/llvm/Transforms/IPO/Attributor.h:777</a></p><h3 id="7219AB17CB9CB450"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7219AB17CB9CB450">Â¶</a><code class="hdoc-function-code language-cpp">static const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* getPointerOperand(
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I,
    bool AllowVolatile)</code></pre></h3><h4>Description</h4><p>Get pointer operand of memory accessing instruction. If \p I is not a memory accessing instruction, return nullptr. If \p AllowVolatile, is set to false and the instruction is volatile, return nullptr.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L834">llvm/include/llvm/Transforms/IPO/Attributor.h:834</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt><dt class="is-family-code">bool<b> AllowVolatile</b></dt></dl><h3 id="4E706EB69BDE1B35"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4E706EB69BDE1B35">Â¶</a><code class="hdoc-function-code language-cpp">void identifyDefaultAbstractAttributes(
    <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F)</code></pre></h3><h4>Description</h4><p>Determine opportunities to derive &apos;default&apos; attributes in \p F and create abstract attribute objects for them. Note that abstract attribute instances are generally created even if the IR already contains the information they would deduce. The most important reason for this is the single interface, the one of the abstract attribute instance, which can be queried without the need to look at the IR in various places.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L789">llvm/include/llvm/Transforms/IPO/Attributor.h:789</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt><dd>The function that is checked for attribute opportunities.</dd></dl><h3 id="D114D41ED0910DC5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D114D41ED0910DC5">Â¶</a><code class="hdoc-function-code language-cpp">void initializeInformationCache(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F)</code></pre></h3><h4>Description</h4><p>Initialize the information cache for queries regarding function \p F. This method needs to be called for all function that might be looked at through the information cache interface *prior* to looking at them.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L795">llvm/include/llvm/Transforms/IPO/Attributor.h:795</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt></dl><h3 id="860030B3B848A2A9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#860030B3B848A2A9">Â¶</a><code class="hdoc-function-code language-cpp">bool isAssumedDead(
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; AA,
    const <a href="rAB1F28EE5925B869.html">llvm::AAIsDead</a>* LivenessAA)</code></pre></h3><h4>Description</h4><p>Return true if \p AA (or its context instruction) is assumed dead. If \p LivenessAA is not provided it is queried.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L890">llvm/include/llvm/Transforms/IPO/Attributor.h:890</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> AA</b></dt><dt class="is-family-code">const <a href="rAB1F28EE5925B869.html">llvm::AAIsDead</a>*<b> LivenessAA</b></dt></dl><h3 id="D052CE07D0F6CF25"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D052CE07D0F6CF25">Â¶</a><code class="hdoc-function-code language-cpp">void markLiveInternalFunction(
    const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F)</code></pre></h3><h4>Description</h4><p>Mark the internal function \p F as live. This will trigger the identification and initialization of attributes for\p F.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L801">llvm/include/llvm/Transforms/IPO/Attributor.h:801</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt></dl><h3 id="64F54126BFDADB36"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#64F54126BFDADB36">Â¶</a><code class="hdoc-function-code language-cpp">void recordDependence(
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; FromAA,
    const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp; ToAA,
    llvm::DepClassTy DepClass)</code></pre></h3><h4>Description</h4><p>Explicitly record a dependence from \p FromAA to \p ToAA, that is if\p FromAA changes \p ToAA should be updated as well. This method should be used in conjunction with the `getAAFor` method and with the TrackDependence flag passed to the method set to false. This can be beneficial to avoid false dependences but it requires the users of `getAAFor` to explicitly record true dependences through this method. The \p DepClass flag indicates if the dependence is striclty necessary. That means for required dependences, if \p FromAA changes to an invalid state, \p ToAA can be moved to a pessimistic fixpoint because it required information from \p FromAA but none are available anymore.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L751">llvm/include/llvm/Transforms/IPO/Attributor.h:751</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> FromAA</b></dt><dt class="is-family-code">const <a href="r5E2FF1C7192677A1.html">llvm::AbstractAttribute</a>&amp;<b> ToAA</b></dt><dt class="is-family-code">llvm::DepClassTy<b> DepClass</b></dt></dl><h3 id="17E2F7E3C341D1E9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#17E2F7E3C341D1E9">Â¶</a><code class="hdoc-function-code language-cpp">template &lt;typename AAType&gt;
AAType&amp; registerAA(AAType&amp; AA)</code></pre></h3><h4>Description</h4><p>Introduce a new abstract attribute into the fixpoint analysis. Note that ownership of the attribute is given to the Attributor. It will invoke delete for the Attributor on destruction of the Attributor. Attributes are identified by their IR position (AAType::getIRPosition()) and the address of their static member (see AAType::ID).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L761">llvm/include/llvm/Transforms/IPO/Attributor.h:761</a></p><h4>Templates</h4><dl><dt class="is-family-code"><b> AAType</b></dt></dl><h4>Parameters</h4><dl><dt class="is-family-code">AAType&amp;<b> AA</b></dt></dl><h3 id="7C7C704CB571D2E7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7C7C704CB571D2E7">Â¶</a><code class="hdoc-function-code language-cpp">bool registerFunctionSignatureRewrite(
    <a href="rD25407E973068684.html">llvm::Argument</a>&amp; Arg,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt; ReplacementTypes,
    ArgumentReplacementInfo::CalleeRepairCBTy&amp;&amp;
        CalleeRepairCB,
    ArgumentReplacementInfo::ACSRepairCBTy&amp;&amp;
        ACSRepairCB)</code></pre></h3><h4>Description</h4><p>Register a rewrite for a function signature. The argument \p Arg is replaced with new ones defined by the number, order, and types in \p ReplacementTypes. The rewiring at the call sites is done through \p ACSRepairCB and at the callee site through\p CalleeRepairCB.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L985">llvm/include/llvm/Transforms/IPO/Attributor.h:985</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD25407E973068684.html">llvm::Argument</a>&amp;<b> Arg</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt;<b> ReplacementTypes</b></dt><dt class="is-family-code">ArgumentReplacementInfo::CalleeRepairCBTy&amp;&amp;<b> CalleeRepairCB</b></dt><dt class="is-family-code">ArgumentReplacementInfo::ACSRepairCBTy&amp;&amp;<b> ACSRepairCB</b></dt></dl><h4>Returns</h4><p>True, if the replacement was registered, false otherwise.</p><h3 id="C3830E8ECF4B3D86"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C3830E8ECF4B3D86">Â¶</a><code class="hdoc-function-code language-cpp">void registerInvokeWithDeadSuccessor(
    <a href="r2FC30BEF376E44C4.html">llvm::InvokeInst</a>&amp; II)</code></pre></h3><h4>Description</h4><p>Record that \p II has at least one dead successor block. This information is used, e.g., to replace \p II with a call, after information was manifested.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L872">llvm/include/llvm/Transforms/IPO/Attributor.h:872</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r2FC30BEF376E44C4.html">llvm::InvokeInst</a>&amp;<b> II</b></dt></dl><h3 id="E85481E4FA6AF841"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E85481E4FA6AF841">Â¶</a><code class="hdoc-function-code language-cpp">llvm::ChangeStatus run(<a href="r1428BC327E1751C3.html">llvm::Module</a>&amp; M)</code></pre></h3><h4>Description</h4><p>Run the analyses until a fixpoint is reached or enforced (timeout). The attributes registered with this Attributor can be used after as long as the Attributor is not destroyed (it owns the attributes now).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L710">llvm/include/llvm/Transforms/IPO/Attributor.h:710</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r1428BC327E1751C3.html">llvm::Module</a>&amp;<b> M</b></dt></dl><h4>Returns</h4><p>CHANGED if the IR was changed, otherwise UNCHANGED.</p><h3 id="876FECFBE31D7BDA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#876FECFBE31D7BDA">Â¶</a><code class="hdoc-function-code language-cpp">~Attributor()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/Attributor.h#L698">llvm/include/llvm/Transforms/IPO/Attributor.h:698</a></p></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>