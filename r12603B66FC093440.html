<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>struct GlobalLayoutBuilder: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li><a href="namespaces.html#488C7851E8DF27D3"><span>namespace lowertypetests</span></a></li><li class="is-active"><a aria-current="page12603B66FC093440"><span>struct GlobalLayoutBuilder</span></a></li></ul></nav><main class="content"><h1>struct GlobalLayoutBuilder</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">struct GlobalLayoutBuilder { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>This class implements a layout algorithm for globals referenced by bit sets that tries to keep members of small bit sets together. This can significantly reduce bit set sizes in many cases. It works by assembling fragments of layout from sets of referenced globals. Each set of referenced globals causes the algorithm to create a new fragment, which is assembled by appending each referenced global in the set into the fragment. If a referenced global has already been referenced by an fragment created earlier, we instead delete that fragment and append its contents into the fragment we are assembling. By starting with the smallest fragments, we minimize the size of the fragments that are copied into larger fragments. This is most intuitively thought about when considering the case where the globals are virtual tables and the bit sets represent their derived classes: in a single inheritance hierarchy, the optimum layout would involve a depth-first search of the class hierarchy (and in fact the computed layout ends up looking a lot like a DFS), but a naive DFS would not work well in the presence of multiple inheritance. This aspect of the algorithm ends up fitting smaller hierarchies inside larger ones where that would be beneficial. For example, consider this class hierarchy: A       B \ / |  \ ///     C   D   E We have five bit sets: bsA (A, C), bsB (B, C, D, E), bsC (C), bsD (D) and bsE (E). If we laid out our objects by DFS traversing B followed by A, our layout would be {B, C, D, E, A}. This is optimal for bsB as it needs to cover the only 4 objects in its hierarchy, but not for bsA as it needs to cover 5 objects, i.e. the entire layout. Our algorithm proceeds as follows: Add bsC, fragments {{C}} Add bsD, fragments {{C}, {D}} Add bsE, fragments {{C}, {D}, {E}} Add bsA, fragments {{A, C}, {D}, {E}} Add bsB, fragments {{B, A, C, D, E}} This layout is optimal for bsA, as it now only needs to cover two (i.e. 3 fewer) objects, at the cost of bsB needing to cover 1 more object. The bit set lowering pass assigns an object index to each object that needs to be laid out, and calls addFragment for each bit set passing the object indices of its referenced globals. It then assembles a layout from the computed layout in the Fragments field.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h#L126">llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:126</a></p><h2>Member Variables</h2><dl><dt class="is-family-code" id="var_Fragments">public  <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;std::vector&lt;uint64_t&gt;&gt; <b>Fragments</b></dt><dd>The computed layout. Each element of this vector contains a fragment of layout (which may be empty) consisting of object indices.</dd><dt class="is-family-code" id="var_FragmentMap">public  <a href="https://en.cppreference.com/w/cpp/container/vector">std::vector</a>&lt;uint64_t&gt; <b>FragmentMap</b></dt><dd>Mapping from object index to fragment index.</dd></dl><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#A9978B55F2280A39"><b>GlobalLayoutBuilder</b></a>(uint64_t NumObjects)</li><li class="is-family-code">public void  <a href="#5AFED177FBB6D556"><b>addFragment</b></a>(const std::set&lt;uint64_t&gt; &amp; F)</li></ul><h2>Methods</h2><h3 id="A9978B55F2280A39"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A9978B55F2280A39">¶</a><code class="hdoc-function-code language-cpp">GlobalLayoutBuilder(uint64_t NumObjects)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h#L134">llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:134</a></p><h4>Parameters</h4><dl><dt class="is-family-code">uint64_t<b> NumObjects</b></dt></dl><h3 id="5AFED177FBB6D556"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5AFED177FBB6D556">¶</a><code class="hdoc-function-code language-cpp">void addFragment(const <a href="https://en.cppreference.com/w/cpp/container/set">std::set</a>&lt;uint64_t&gt;&amp; F)</code></pre></h3><h4>Description</h4><p>Add F to the layout while trying to keep its indices contiguous. If a previously seen fragment uses any of F&apos;s indices, that fragment will be laid out inside F.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Transforms/IPO/LowerTypeTests.h#L140">llvm/include/llvm/Transforms/IPO/LowerTypeTests.h:140</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="https://en.cppreference.com/w/cpp/container/set">std::set</a>&lt;uint64_t&gt;&amp;<b> F</b></dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>