<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class TargetTransformInfo: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="page76DB21423DDE140B"><span>class TargetTransformInfo</span></a></li></ul></nav><main class="content"><h1>class TargetTransformInfo</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class TargetTransformInfo { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>This pass provides access to the codegen interfaces that are needed for IR-level transformations.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L111">llvm/include/llvm/Analysis/TargetTransformInfo.h:111</a></p><h2>Method Overview</h2><ul><li class="is-family-code">public bool  <a href="#6B3A3BE5152A6CA6"><b>LSRWithInstrQueries</b></a>() const</li><li class="is-family-code">public  <a href="#B3A99F152622AA28"><b>TargetTransformInfo</b></a>(llvm::TargetTransformInfo &amp;&amp; Arg)</li><li class="is-family-code">public template &lt;typename T&gt; <a href="#615D8263D185A45A"><b>TargetTransformInfo</b></a>(T Impl)</li><li class="is-family-code">public  <a href="#F8B750EB7AF8B3FE"><b>TargetTransformInfo</b></a>(const llvm::DataLayout &amp; DL)</li><li class="is-family-code">public bool  <a href="#CB1207EA2EC94EE4"><b>allowsMisalignedMemoryAccesses</b></a>(llvm::LLVMContext &amp; Context, unsigned int BitWidth, unsigned int AddressSpace = 0, unsigned int Alignment = 1, bool * Fast = nullptr) const</li><li class="is-family-code">public bool  <a href="#2CBBB9E2DDD26274"><b>areFunctionArgsABICompatible</b></a>(const llvm::Function * Caller, const llvm::Function * Callee, SmallPtrSetImpl&lt;llvm::Argument *&gt; &amp; Args) const</li><li class="is-family-code">public bool  <a href="#704617D6EE74316D"><b>areInlineCompatible</b></a>(const llvm::Function * Caller, const llvm::Function * Callee) const</li><li class="is-family-code">public bool  <a href="#DA1B40AA57B31BD8"><b>canMacroFuseCmp</b></a>() const</li><li class="is-family-code">public bool  <a href="#4B91DCD4C207096A"><b>canSaveCmp</b></a>(llvm::Loop * L, llvm::BranchInst ** BI, llvm::ScalarEvolution * SE, llvm::LoopInfo * LI, llvm::DominatorTree * DT, llvm::AssumptionCache * AC, llvm::TargetLibraryInfo * LibInfo) const</li><li class="is-family-code">public bool  <a href="#CD462A2F7539DC30"><b>collectFlatAddressOperands</b></a>(SmallVectorImpl&lt;int&gt; &amp; OpIndexes, Intrinsic::ID IID) const</li><li class="is-family-code">public bool  <a href="#1C13CD1DA4E99524"><b>enableAggressiveInterleaving</b></a>(bool LoopHasReductions) const</li><li class="is-family-code">public bool  <a href="#E50E8FB5153F0C35"><b>enableInterleavedAccessVectorization</b></a>() const</li><li class="is-family-code">public bool  <a href="#A3D3FFDAB5544AA3"><b>enableMaskedInterleavedAccessVectorization</b></a>() const</li><li class="is-family-code">public llvm::TargetTransformInfo::MemCmpExpansionOptions  <a href="#B2CAD04698A2DE20"><b>enableMemCmpExpansion</b></a>(bool OptSize, bool IsZeroCmp) const</li><li class="is-family-code">public int  <a href="#3F8737BD6EDA7B84"><b>getAddressComputationCost</b></a>(llvm::Type * Ty, llvm::ScalarEvolution * SE = nullptr, const llvm::SCEV * Ptr = nullptr) const</li><li class="is-family-code">public int  <a href="#6E44D5C51FF88A5B"><b>getArithmeticInstrCost</b></a>(unsigned int Opcode, llvm::Type * Ty, llvm::TargetTransformInfo::OperandValueKind Opd1Info = OK_AnyValue, llvm::TargetTransformInfo::OperandValueKind Opd2Info = OK_AnyValue, llvm::TargetTransformInfo::OperandValueProperties Opd1PropInfo = OP_None, llvm::TargetTransformInfo::OperandValueProperties Opd2PropInfo = OP_None, ArrayRef&lt;const llvm::Value *&gt; Args = llvm::ArrayRef&lt;const llvm::Value *&gt;(), const llvm::Instruction * CxtI = nullptr) const</li><li class="is-family-code">public int  <a href="#ECFC4187B7235650"><b>getArithmeticReductionCost</b></a>(unsigned int Opcode, llvm::Type * Ty, bool IsPairwiseForm) const</li><li class="is-family-code">public unsigned int  <a href="#E4224B4C01ACE797"><b>getAtomicMemIntrinsicMaxElementSize</b></a>() const</li><li class="is-family-code">public int  <a href="#3D9B78A06469EA7B"><b>getCFInstrCost</b></a>(unsigned int Opcode) const</li><li class="is-family-code">public llvm::Optional&lt;unsigned int&gt;  <a href="#AA1B6D960B2D9CAE"><b>getCacheAssociativity</b></a>(llvm::TargetTransformInfo::CacheLevel Level) const</li><li class="is-family-code">public unsigned int  <a href="#9FEEAC82B37D172F"><b>getCacheLineSize</b></a>() const</li><li class="is-family-code">public llvm::Optional&lt;unsigned int&gt;  <a href="#3D818AD878744060"><b>getCacheSize</b></a>(llvm::TargetTransformInfo::CacheLevel Level) const</li><li class="is-family-code">public int  <a href="#F37108000D8B97B3"><b>getCallCost</b></a>(const llvm::Function * F, ArrayRef&lt;const llvm::Value *&gt; Arguments, const llvm::User * U = nullptr) const</li><li class="is-family-code">public int  <a href="#119CDC8A7969927D"><b>getCallCost</b></a>(llvm::FunctionType * FTy, int NumArgs = -1, const llvm::User * U = nullptr) const</li><li class="is-family-code">public int  <a href="#C38F9F9F696E2F26"><b>getCallCost</b></a>(const llvm::Function * F, int NumArgs = -1, const llvm::User * U = nullptr) const</li><li class="is-family-code">public int  <a href="#400F0D58BE62B7DB"><b>getCallInstrCost</b></a>(llvm::Function * F, llvm::Type * RetTy, ArrayRef&lt;llvm::Type *&gt; Tys) const</li><li class="is-family-code">public int  <a href="#2090B707B6430DDB"><b>getCastInstrCost</b></a>(unsigned int Opcode, llvm::Type * Dst, llvm::Type * Src, const llvm::Instruction * I = nullptr) const</li><li class="is-family-code">public int  <a href="#51023D98122FD4A4"><b>getCmpSelInstrCost</b></a>(unsigned int Opcode, llvm::Type * ValTy, llvm::Type * CondTy = nullptr, const llvm::Instruction * I = nullptr) const</li><li class="is-family-code">public unsigned int  <a href="#9BFB22324BE3494F"><b>getCostOfKeepingLiveOverCall</b></a>(ArrayRef&lt;llvm::Type *&gt; Tys) const</li><li class="is-family-code">public unsigned int  <a href="#C6C61675536AC3A0"><b>getEstimatedNumberOfCaseClusters</b></a>(const llvm::SwitchInst &amp; SI, unsigned int &amp; JTSize, llvm::ProfileSummaryInfo * PSI, llvm::BlockFrequencyInfo * BFI) const</li><li class="is-family-code">public int  <a href="#A0BCBE67AA005CC5"><b>getExtCost</b></a>(const llvm::Instruction * I, const llvm::Value * Src) const</li><li class="is-family-code">public int  <a href="#68F96D6F5DAA5CA6"><b>getExtractWithExtendCost</b></a>(unsigned int Opcode, llvm::Type * Dst, llvm::VectorType * VecTy, unsigned int Index = -1) const</li><li class="is-family-code">public int  <a href="#54C1642AA7DAF1E6"><b>getFPOpCost</b></a>(llvm::Type * Ty) const</li><li class="is-family-code">public unsigned int  <a href="#33996ED0A712F7DC"><b>getFlatAddressSpace</b></a>() const</li><li class="is-family-code">public int  <a href="#16D84845BF186F16"><b>getGEPCost</b></a>(llvm::Type * PointeeType, const llvm::Value * Ptr, ArrayRef&lt;const llvm::Value *&gt; Operands) const</li><li class="is-family-code">public unsigned int  <a href="#2999B6BA2194D98E"><b>getGISelRematGlobalCost</b></a>() const</li><li class="is-family-code">public int  <a href="#751C05AA05C4D580"><b>getGatherScatterOpCost</b></a>(unsigned int Opcode, llvm::Type * DataTy, llvm::Value * Ptr, bool VariableMask, unsigned int Alignment) const</li><li class="is-family-code">public int  <a href="#655434316838039A"><b>getInlinerVectorBonusPercent</b></a>() const</li><li class="is-family-code">public unsigned int  <a href="#04FE052E3B102863"><b>getInliningThresholdMultiplier</b></a>() const</li><li class="is-family-code">public int  <a href="#6E2A625500598816"><b>getInstructionCost</b></a>(const llvm::Instruction * I, enum TargetCostKind kind) const</li><li class="is-family-code">public int  <a href="#ADCECDFE4075E785"><b>getIntImmCodeSizeCost</b></a>(unsigned int Opc, unsigned int Idx, const llvm::APInt &amp; Imm, llvm::Type * Ty) const</li><li class="is-family-code">public int  <a href="#79A54799EB9CFC54"><b>getIntImmCost</b></a>(const llvm::APInt &amp; Imm, llvm::Type * Ty) const</li><li class="is-family-code">public int  <a href="#D464A9EACF6430FD"><b>getIntImmCostInst</b></a>(unsigned int Opc, unsigned int Idx, const llvm::APInt &amp; Imm, llvm::Type * Ty) const</li><li class="is-family-code">public int  <a href="#078BE150BC26C513"><b>getIntImmCostIntrin</b></a>(Intrinsic::ID IID, unsigned int Idx, const llvm::APInt &amp; Imm, llvm::Type * Ty) const</li><li class="is-family-code">public int  <a href="#E6C24FDA62493DE6"><b>getInterleavedMemoryOpCost</b></a>(unsigned int Opcode, llvm::Type * VecTy, unsigned int Factor, ArrayRef&lt;unsigned int&gt; Indices, unsigned int Alignment, unsigned int AddressSpace, bool UseMaskForCond = false, bool UseMaskForGaps = false) const</li><li class="is-family-code">public int  <a href="#ACBFD7E3C3B36EEA"><b>getIntrinsicCost</b></a>(Intrinsic::ID IID, llvm::Type * RetTy, ArrayRef&lt;llvm::Type *&gt; ParamTys, const llvm::User * U = nullptr) const</li><li class="is-family-code">public int  <a href="#4E37569C17DF3DD1"><b>getIntrinsicCost</b></a>(Intrinsic::ID IID, llvm::Type * RetTy, ArrayRef&lt;const llvm::Value *&gt; Arguments, const llvm::User * U = nullptr) const</li><li class="is-family-code">public int  <a href="#701C63C9D08A9CD2"><b>getIntrinsicInstrCost</b></a>(Intrinsic::ID ID, llvm::Type * RetTy, ArrayRef&lt;llvm::Value *&gt; Args, llvm::FastMathFlags FMF, unsigned int VF = 1) const</li><li class="is-family-code">public int  <a href="#74F70B39E711A679"><b>getIntrinsicInstrCost</b></a>(Intrinsic::ID ID, llvm::Type * RetTy, ArrayRef&lt;llvm::Type *&gt; Tys, llvm::FastMathFlags FMF, unsigned int ScalarizationCostPassed = (2147483647 * 2U + 1U)) const</li><li class="is-family-code">public unsigned int  <a href="#6E951F4C6F456BCA"><b>getLoadStoreVecRegBitWidth</b></a>(unsigned int AddrSpace) const</li><li class="is-family-code">public unsigned int  <a href="#1FC5AC54470A8189"><b>getLoadVectorFactor</b></a>(unsigned int VF, unsigned int LoadSize, unsigned int ChainSizeInBytes, llvm::VectorType * VecTy) const</li><li class="is-family-code">public int  <a href="#422B9DF689C0BA4F"><b>getMaskedMemoryOpCost</b></a>(unsigned int Opcode, llvm::Type * Src, unsigned int Alignment, unsigned int AddressSpace) const</li><li class="is-family-code">public unsigned int  <a href="#1433317623F3D1DC"><b>getMaxInterleaveFactor</b></a>(unsigned int VF) const</li><li class="is-family-code">public unsigned int  <a href="#EC0ACABF58128536"><b>getMaxPrefetchIterationsAhead</b></a>() const</li><li class="is-family-code">public int  <a href="#6B33222D2A49A264"><b>getMemcpyCost</b></a>(const llvm::Instruction * I) const</li><li class="is-family-code">public llvm::Type *  <a href="#988B7BB9C840E64A"><b>getMemcpyLoopLoweringType</b></a>(llvm::LLVMContext &amp; Context, llvm::Value * Length, unsigned int SrcAlign, unsigned int DestAlign) const</li><li class="is-family-code">public void  <a href="#B060236E936DA024"><b>getMemcpyLoopResidualLoweringType</b></a>(SmallVectorImpl&lt;llvm::Type *&gt; &amp; OpsOut, llvm::LLVMContext &amp; Context, unsigned int RemainingBytes, unsigned int SrcAlign, unsigned int DestAlign) const</li><li class="is-family-code">public int  <a href="#B3DC484E24DB631A"><b>getMemoryOpCost</b></a>(unsigned int Opcode, llvm::Type * Src, llvm::MaybeAlign Alignment, unsigned int AddressSpace, const llvm::Instruction * I = nullptr) const</li><li class="is-family-code">public int  <a href="#75AD444C2A04BEEB"><b>getMinMaxReductionCost</b></a>(llvm::Type * Ty, llvm::Type * CondTy, bool IsPairwiseForm, bool IsUnsigned) const</li><li class="is-family-code">public unsigned int  <a href="#C2A70C5B23F42127"><b>getMinPrefetchStride</b></a>() const</li><li class="is-family-code">public unsigned int  <a href="#1459280368AA3970"><b>getMinVectorRegisterBitWidth</b></a>() const</li><li class="is-family-code">public unsigned int  <a href="#74BC3C8A9B7E6D27"><b>getMinimumVF</b></a>(unsigned int ElemWidth) const</li><li class="is-family-code">public unsigned int  <a href="#FD56C7D3B0CE350F"><b>getNumberOfParts</b></a>(llvm::Type * Tp) const</li><li class="is-family-code">public unsigned int  <a href="#8B89174B1442F6CB"><b>getNumberOfRegisters</b></a>(unsigned int ClassID) const</li><li class="is-family-code">public static llvm::TargetTransformInfo::OperandValueKind  <a href="#DAEF03B3C076F4DF"><b>getOperandInfo</b></a>(llvm::Value * V, llvm::TargetTransformInfo::OperandValueProperties &amp; OpProps)</li><li class="is-family-code">public unsigned int  <a href="#AB9CEFD3D4C30283"><b>getOperandsScalarizationOverhead</b></a>(ArrayRef&lt;const llvm::Value *&gt; Args, unsigned int VF) const</li><li class="is-family-code">public int  <a href="#25C1F84A26A03333"><b>getOperationCost</b></a>(unsigned int Opcode, llvm::Type * Ty, llvm::Type * OpTy = nullptr) const</li><li class="is-family-code">public llvm::Value *  <a href="#3ED3FA8DB7BEED84"><b>getOrCreateResultFromMemIntrinsic</b></a>(llvm::IntrinsicInst * Inst, llvm::Type * ExpectedType) const</li><li class="is-family-code">public llvm::TargetTransformInfo::PopcntSupportKind  <a href="#7BB76D9C68CEC858"><b>getPopcntSupport</b></a>(unsigned int IntTyWidthInBit) const</li><li class="is-family-code">public unsigned int  <a href="#2122C900E508F924"><b>getPrefetchDistance</b></a>() const</li><li class="is-family-code">public unsigned int  <a href="#BD200CC35F813AB1"><b>getRegisterBitWidth</b></a>(bool Vector) const</li><li class="is-family-code">public unsigned int  <a href="#5F28032E8382173C"><b>getRegisterClassForType</b></a>(bool Vector, llvm::Type * Ty = nullptr) const</li><li class="is-family-code">public const char *  <a href="#2719AEE9D307EB2B"><b>getRegisterClassName</b></a>(unsigned int ClassID) const</li><li class="is-family-code">public unsigned int  <a href="#EFDE153BAAA49072"><b>getScalarizationOverhead</b></a>(llvm::Type * Ty, bool Insert, bool Extract) const</li><li class="is-family-code">public int  <a href="#DCDC0DB43FDBEDBB"><b>getScalingFactorCost</b></a>(llvm::Type * Ty, llvm::GlobalValue * BaseGV, int64_t BaseOffset, bool HasBaseReg, int64_t Scale, unsigned int AddrSpace = 0) const</li><li class="is-family-code">public int  <a href="#506C7E06B0A14F57"><b>getShuffleCost</b></a>(llvm::TargetTransformInfo::ShuffleKind Kind, llvm::Type * Tp, int Index = 0, llvm::Type * SubTp = nullptr) const</li><li class="is-family-code">public unsigned int  <a href="#064D8917CA118FF4"><b>getStoreVectorFactor</b></a>(unsigned int VF, unsigned int StoreSize, unsigned int ChainSizeInBytes, llvm::VectorType * VecTy) const</li><li class="is-family-code">public bool  <a href="#5E46BAE8455B464D"><b>getTgtMemIntrinsic</b></a>(llvm::IntrinsicInst * Inst, llvm::MemIntrinsicInfo &amp; Info) const</li><li class="is-family-code">public void  <a href="#76DA373AF6DE2893"><b>getUnrollingPreferences</b></a>(llvm::Loop * L, llvm::ScalarEvolution &amp;, llvm::TargetTransformInfo::UnrollingPreferences &amp; UP) const</li><li class="is-family-code">public int  <a href="#3849F595E64B52FB"><b>getUserCost</b></a>(const llvm::User * U) const</li><li class="is-family-code">public int  <a href="#A619A4A58583DAE7"><b>getUserCost</b></a>(const llvm::User * U, ArrayRef&lt;const llvm::Value *&gt; Operands) const</li><li class="is-family-code">public int  <a href="#CAA42CDC7357C032"><b>getVectorInstrCost</b></a>(unsigned int Opcode, llvm::Type * Val, unsigned int Index = -1) const</li><li class="is-family-code">public bool  <a href="#B7DCCEF3B6DAB887"><b>hasBranchDivergence</b></a>() const</li><li class="is-family-code">public bool  <a href="#1509C06674F2D23A"><b>hasDivRemOp</b></a>(llvm::Type * DataType, bool IsSigned) const</li><li class="is-family-code">public bool  <a href="#470632B01532833B"><b>hasVolatileVariant</b></a>(llvm::Instruction * I, unsigned int AddrSpace) const</li><li class="is-family-code">public bool  <a href="#7BE509CC0102BDF2"><b>haveFastSqrt</b></a>(llvm::Type * Ty) const</li><li class="is-family-code">public bool  <a href="#65B65E7169BE129F"><b>invalidate</b></a>(llvm::Function &amp;, const llvm::PreservedAnalyses &amp;, FunctionAnalysisManager::Invalidator &amp;)</li><li class="is-family-code">public bool  <a href="#B34A8BFC88992BD7"><b>isAlwaysUniform</b></a>(const llvm::Value * V) const</li><li class="is-family-code">public bool  <a href="#5779780134073ABE"><b>isFCmpOrdCheaperThanFCmpZero</b></a>(llvm::Type * Ty) const</li><li class="is-family-code">public bool  <a href="#99BF237FA602D88F"><b>isFPVectorizationPotentiallyUnsafe</b></a>() const</li><li class="is-family-code">public bool  <a href="#800E6B299BF5B706"><b>isHardwareLoopProfitable</b></a>(llvm::Loop * L, llvm::ScalarEvolution &amp; SE, llvm::AssumptionCache &amp; AC, llvm::TargetLibraryInfo * LibInfo, llvm::HardwareLoopInfo &amp; HWLoopInfo) const</li><li class="is-family-code">public bool  <a href="#A3B3A8FA027BB25A"><b>isIndexedLoadLegal</b></a>(enum MemIndexedMode Mode, llvm::Type * Ty) const</li><li class="is-family-code">public bool  <a href="#8F0A641F9A319454"><b>isIndexedStoreLegal</b></a>(enum MemIndexedMode Mode, llvm::Type * Ty) const</li><li class="is-family-code">public bool  <a href="#9430DC915187169E"><b>isLSRCostLess</b></a>(TargetTransformInfo::LSRCost &amp; C1, TargetTransformInfo::LSRCost &amp; C2) const</li><li class="is-family-code">public bool  <a href="#0654A614522B63B7"><b>isLegalAddImmediate</b></a>(int64_t Imm) const</li><li class="is-family-code">public bool  <a href="#D59F5996B4D2FD58"><b>isLegalAddressingMode</b></a>(llvm::Type * Ty, llvm::GlobalValue * BaseGV, int64_t BaseOffset, bool HasBaseReg, int64_t Scale, unsigned int AddrSpace = 0, llvm::Instruction * I = nullptr) const</li><li class="is-family-code">public bool  <a href="#6950CEAE6E0DC126"><b>isLegalICmpImmediate</b></a>(int64_t Imm) const</li><li class="is-family-code">public bool  <a href="#C210957ADC04F8D1"><b>isLegalMaskedCompressStore</b></a>(llvm::Type * DataType) const</li><li class="is-family-code">public bool  <a href="#0CED9F210A921DBD"><b>isLegalMaskedExpandLoad</b></a>(llvm::Type * DataType) const</li><li class="is-family-code">public bool  <a href="#FAE2AE51E6AD2BF2"><b>isLegalMaskedGather</b></a>(llvm::Type * DataType, llvm::MaybeAlign Alignment) const</li><li class="is-family-code">public bool  <a href="#750F7A78A5CB8F15"><b>isLegalMaskedLoad</b></a>(llvm::Type * DataType, llvm::MaybeAlign Alignment) const</li><li class="is-family-code">public bool  <a href="#0043FD74D09213A2"><b>isLegalMaskedScatter</b></a>(llvm::Type * DataType, llvm::MaybeAlign Alignment) const</li><li class="is-family-code">public bool  <a href="#2B0B43DB9F3FAB8B"><b>isLegalMaskedStore</b></a>(llvm::Type * DataType, llvm::MaybeAlign Alignment) const</li><li class="is-family-code">public bool  <a href="#2A4FB81FD2364AC9"><b>isLegalNTLoad</b></a>(llvm::Type * DataType, llvm::Align Alignment) const</li><li class="is-family-code">public bool  <a href="#B99A7F7235D8A0F0"><b>isLegalNTStore</b></a>(llvm::Type * DataType, llvm::Align Alignment) const</li><li class="is-family-code">public bool  <a href="#9B6E99CA89AEF21B"><b>isLegalToVectorizeLoad</b></a>(llvm::LoadInst * LI) const</li><li class="is-family-code">public bool  <a href="#1577B1CAB3900E5E"><b>isLegalToVectorizeLoadChain</b></a>(unsigned int ChainSizeInBytes, unsigned int Alignment, unsigned int AddrSpace) const</li><li class="is-family-code">public bool  <a href="#BDA308B11F7AB40E"><b>isLegalToVectorizeStore</b></a>(llvm::StoreInst * SI) const</li><li class="is-family-code">public bool  <a href="#9380E6CEEA23582E"><b>isLegalToVectorizeStoreChain</b></a>(unsigned int ChainSizeInBytes, unsigned int Alignment, unsigned int AddrSpace) const</li><li class="is-family-code">public bool  <a href="#D6864AAC3F10B498"><b>isLoweredToCall</b></a>(const llvm::Function * F) const</li><li class="is-family-code">public bool  <a href="#66CE702F886C1A3A"><b>isProfitableToHoist</b></a>(llvm::Instruction * I) const</li><li class="is-family-code">public bool  <a href="#6E0182B3EEE2CBDE"><b>isSourceOfDivergence</b></a>(const llvm::Value * V) const</li><li class="is-family-code">public bool  <a href="#D2660BF64050480B"><b>isTruncateFree</b></a>(llvm::Type * Ty1, llvm::Type * Ty2) const</li><li class="is-family-code">public bool  <a href="#59A7D324CF57E12B"><b>isTypeLegal</b></a>(llvm::Type * Ty) const</li><li class="is-family-code">public bool  <a href="#152714588B7B7312"><b>preferPredicateOverEpilogue</b></a>(llvm::Loop * L, llvm::LoopInfo * LI, llvm::ScalarEvolution &amp; SE, llvm::AssumptionCache &amp; AC, llvm::TargetLibraryInfo * TLI, llvm::DominatorTree * DT, const llvm::LoopAccessInfo * LAI) const</li><li class="is-family-code">public bool  <a href="#6ADB716E1DBAE095"><b>prefersVectorizedAddressing</b></a>() const</li><li class="is-family-code">public bool  <a href="#3946D6E9A07F4BB2"><b>rewriteIntrinsicWithAddressSpace</b></a>(llvm::IntrinsicInst * II, llvm::Value * OldV, llvm::Value * NewV) const</li><li class="is-family-code">public bool  <a href="#FC9C9AB1607B3C38"><b>shouldBuildLookupTables</b></a>() const</li><li class="is-family-code">public bool  <a href="#7737D117EC575AF4"><b>shouldBuildLookupTablesForConstant</b></a>(llvm::Constant * C) const</li><li class="is-family-code">public bool  <a href="#AAAF4C1EA3B43543"><b>shouldConsiderAddressTypePromotion</b></a>(const llvm::Instruction &amp; I, bool &amp; AllowPromotionWithoutCommonHeader) const</li><li class="is-family-code">public bool  <a href="#527B858A4ECD93E0"><b>shouldExpandReduction</b></a>(const llvm::IntrinsicInst * II) const</li><li class="is-family-code">public bool  <a href="#292E6B7122CF9F33"><b>shouldFavorBackedgeIndex</b></a>(const llvm::Loop * L) const</li><li class="is-family-code">public bool  <a href="#84B02FD1957FB63D"><b>shouldFavorPostInc</b></a>() const</li><li class="is-family-code">public bool  <a href="#10D85438A1CF4BD5"><b>shouldMaximizeVectorBandwidth</b></a>(bool OptSize) const</li><li class="is-family-code">public bool  <a href="#4BF608B70FA54DA1"><b>supportsEfficientVectorElementLoadStore</b></a>() const</li><li class="is-family-code">public bool  <a href="#25F28670075C18AE"><b>useAA</b></a>() const</li><li class="is-family-code">public bool  <a href="#3DA4859DFBC79790"><b>useColdCCForColdCall</b></a>(llvm::Function &amp; F) const</li><li class="is-family-code">public bool  <a href="#B5353241DDDD768A"><b>useReductionIntrinsic</b></a>(unsigned int Opcode, llvm::Type * Ty, llvm::TargetTransformInfo::ReductionFlags Flags) const</li><li class="is-family-code">public  <a href="#B7958F2C1D035EE2"><b>~TargetTransformInfo</b></a>()</li></ul><h2>Methods</h2><h3 id="6B3A3BE5152A6CA6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6B3A3BE5152A6CA6">¶</a><code class="hdoc-function-code language-cpp">bool LSRWithInstrQueries() const</code></pre></h3><h4>Description</h4><p>Return true if the loop strength reduce pass should make Instruction* based TTI queries to isLegalAddressingMode(). This is needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned immediate offset and no index register.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L640">llvm/include/llvm/Analysis/TargetTransformInfo.h:640</a></p><h3 id="B3A99F152622AA28"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B3A99F152622AA28">¶</a><code class="hdoc-function-code language-cpp">TargetTransformInfo(
    <a href="r76DB21423DDE140B.html">llvm::TargetTransformInfo</a>&amp;&amp; Arg)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L128">llvm/include/llvm/Analysis/TargetTransformInfo.h:128</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r76DB21423DDE140B.html">llvm::TargetTransformInfo</a>&amp;&amp;<b> Arg</b></dt></dl><h3 id="615D8263D185A45A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#615D8263D185A45A">¶</a><code class="hdoc-function-code language-cpp">template &lt;typename T&gt;
TargetTransformInfo(T Impl)</code></pre></h3><h4>Description</h4><p>Construct a TTI object using a type implementing the \c Concept API below. This is used by targets to construct a TTI wrapping their target-specific implementation that encodes appropriate costs for their target.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L118">llvm/include/llvm/Analysis/TargetTransformInfo.h:118</a></p><h4>Templates</h4><dl><dt class="is-family-code"><b> T</b></dt></dl><h4>Parameters</h4><dl><dt class="is-family-code">T<b> Impl</b></dt></dl><h3 id="F8B750EB7AF8B3FE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F8B750EB7AF8B3FE">¶</a><code class="hdoc-function-code language-cpp">TargetTransformInfo(const <a href="r36886900CAFBFB15.html">llvm::DataLayout</a>&amp; DL)</code></pre></h3><h4>Description</h4><p>Construct a baseline TTI object using a minimal implementation of the \c Concept API below. The TTI implementation will reflect the information in the DataLayout provided if non-null.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L125">llvm/include/llvm/Analysis/TargetTransformInfo.h:125</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r36886900CAFBFB15.html">llvm::DataLayout</a>&amp;<b> DL</b></dt></dl><h3 id="CB1207EA2EC94EE4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CB1207EA2EC94EE4">¶</a><code class="hdoc-function-code language-cpp">bool allowsMisalignedMemoryAccesses(
    <a href="rB8F46D3CD599E2BD.html">llvm::LLVMContext</a>&amp; Context,
    unsigned int BitWidth,
    unsigned int AddressSpace = 0,
    unsigned int Alignment = 1,
    bool* Fast = nullptr) const</code></pre></h3><h4>Description</h4><p>Determine if the target supports unaligned memory accesses.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L729">llvm/include/llvm/Analysis/TargetTransformInfo.h:729</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rB8F46D3CD599E2BD.html">llvm::LLVMContext</a>&amp;<b> Context</b></dt><dt class="is-family-code">unsigned int<b> BitWidth</b></dt><dt class="is-family-code">unsigned int<b> AddressSpace</b> = 0</dt><dt class="is-family-code">unsigned int<b> Alignment</b> = 1</dt><dt class="is-family-code">bool*<b> Fast</b> = nullptr</dt></dl><h3 id="2CBBB9E2DDD26274"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2CBBB9E2DDD26274">¶</a><code class="hdoc-function-code language-cpp">bool areFunctionArgsABICompatible(
    const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* Caller,
    const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* Callee,
    <a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;llvm::Argument*&gt;&amp; Args) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1080">llvm/include/llvm/Analysis/TargetTransformInfo.h:1080</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> Caller</b></dt><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> Callee</b></dt><dt class="is-family-code"><a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;llvm::Argument*&gt;&amp;<b> Args</b></dt><dd>The list of compatible arguments.  The implementation may filter out any incompatible args from this list.</dd></dl><h4>Returns</h4><p>True if the caller and callee agree on how \p Args will be passed to the callee.</p><h3 id="704617D6EE74316D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#704617D6EE74316D">¶</a><code class="hdoc-function-code language-cpp">bool areInlineCompatible(
    const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* Caller,
    const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* Callee) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1073">llvm/include/llvm/Analysis/TargetTransformInfo.h:1073</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> Caller</b></dt><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> Callee</b></dt></dl><h4>Returns</h4><p>True if the two functions have compatible attributes for inlining purposes.</p><h3 id="DA1B40AA57B31BD8"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DA1B40AA57B31BD8">¶</a><code class="hdoc-function-code language-cpp">bool canMacroFuseCmp() const</code></pre></h3><h4>Description</h4><p>Return true if the target can fuse a compare and branch. Loop-strength-reduction (LSR) uses that knowledge to adjust its cost calculation for the instructions in a loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L573">llvm/include/llvm/Analysis/TargetTransformInfo.h:573</a></p><h3 id="4B91DCD4C207096A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4B91DCD4C207096A">¶</a><code class="hdoc-function-code language-cpp">bool canSaveCmp(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    llvm::BranchInst** BI,
    <a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>* SE,
    <a href="r289205FCE270195C.html">llvm::LoopInfo</a>* LI,
    <a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>* DT,
    <a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>* AC,
    <a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>* LibInfo) const</code></pre></h3><h4>Description</h4><p>Return true if the target can save a compare for loop count, for example hardware loop saves a compare.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L577">llvm/include/llvm/Analysis/TargetTransformInfo.h:577</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code">llvm::BranchInst**<b> BI</b></dt><dt class="is-family-code"><a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>*<b> SE</b></dt><dt class="is-family-code"><a href="r289205FCE270195C.html">llvm::LoopInfo</a>*<b> LI</b></dt><dt class="is-family-code"><a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>*<b> DT</b></dt><dt class="is-family-code"><a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>*<b> AC</b></dt><dt class="is-family-code"><a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>*<b> LibInfo</b></dt></dl><h3 id="CD462A2F7539DC30"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CD462A2F7539DC30">¶</a><code class="hdoc-function-code language-cpp">bool collectFlatAddressOperands(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;int&gt;&amp; OpIndexes,
    Intrinsic::ID IID) const</code></pre></h3><h4>Description</h4><p>Return any intrinsic address operand indexes which may be rewritten if they use a flat address space pointer.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L380">llvm/include/llvm/Analysis/TargetTransformInfo.h:380</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;int&gt;&amp;<b> OpIndexes</b></dt><dt class="is-family-code">Intrinsic::ID<b> IID</b></dt></dl><h4>Returns</h4><p>true if the intrinsic was handled.</p><h3 id="1C13CD1DA4E99524"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1C13CD1DA4E99524">¶</a><code class="hdoc-function-code language-cpp">bool enableAggressiveInterleaving(
    bool LoopHasReductions) const</code></pre></h3><h4>Description</h4><p>Don&apos;t restrict interleaved unrolling to small loops.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L679">llvm/include/llvm/Analysis/TargetTransformInfo.h:679</a></p><h4>Parameters</h4><dl><dt class="is-family-code">bool<b> LoopHasReductions</b></dt></dl><h3 id="E50E8FB5153F0C35"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E50E8FB5153F0C35">¶</a><code class="hdoc-function-code language-cpp">bool enableInterleavedAccessVectorization() const</code></pre></h3><h4>Description</h4><p>Enable matching of interleaved access groups.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L712">llvm/include/llvm/Analysis/TargetTransformInfo.h:712</a></p><h3 id="A3D3FFDAB5544AA3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A3D3FFDAB5544AA3">¶</a><code class="hdoc-function-code language-cpp">bool enableMaskedInterleavedAccessVectorization()
    const</code></pre></h3><h4>Description</h4><p>Enable matching of interleaved access groups that contain predicated accesses or gaps and therefore vectorized using masked vector loads/stores.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L717">llvm/include/llvm/Analysis/TargetTransformInfo.h:717</a></p><h3 id="B2CAD04698A2DE20"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B2CAD04698A2DE20">¶</a><code class="hdoc-function-code language-cpp"><a href="r6EFC621962468B55.html">llvm::TargetTransformInfo::MemCmpExpansionOptions</a>
enableMemCmpExpansion(bool OptSize,
                      bool IsZeroCmp) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L708">llvm/include/llvm/Analysis/TargetTransformInfo.h:708</a></p><h4>Parameters</h4><dl><dt class="is-family-code">bool<b> OptSize</b></dt><dt class="is-family-code">bool<b> IsZeroCmp</b></dt></dl><h3 id="3F8737BD6EDA7B84"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3F8737BD6EDA7B84">¶</a><code class="hdoc-function-code language-cpp">int getAddressComputationCost(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    <a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>* SE = nullptr,
    const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>* Ptr = nullptr) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1028">llvm/include/llvm/Analysis/TargetTransformInfo.h:1028</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code"><a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>*<b> SE</b> = nullptr</dt><dt class="is-family-code">const <a href="rAD2E74A85F7E4EBF.html">llvm::SCEV</a>*<b> Ptr</b> = nullptr</dt></dl><h4>Returns</h4><p>The cost of the address computation. For most targets this can be merged into the instruction indexing mode. Some targets might want to distinguish between address computation for memory operations on vector types and scalar types. Such targets should override this function. The &apos;SE&apos; parameter holds pointer for the scalar evolution object which is used in order to get the Ptr step value in case of constant stride. The &apos;Ptr&apos; parameter holds SCEV of the access pointer.</p><h3 id="6E44D5C51FF88A5B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6E44D5C51FF88A5B">¶</a><code class="hdoc-function-code language-cpp">int getArithmeticInstrCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    llvm::TargetTransformInfo::OperandValueKind
        Opd1Info = OK_AnyValue,
    llvm::TargetTransformInfo::OperandValueKind
        Opd2Info = OK_AnyValue,
    llvm::TargetTransformInfo::
        OperandValueProperties Opd1PropInfo =
            OP_None,
    llvm::TargetTransformInfo::
        OperandValueProperties Opd2PropInfo =
            OP_None,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt; Args =
        llvm::ArrayRef&lt;const llvm::Value*&gt;(),
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* CxtI = nullptr) const</code></pre></h3><h4>Description</h4><p>This is an approximation of reciprocal throughput of a math/logic op. A higher cost indicates less expected throughput. From Agner Fog&apos;s guides, reciprocal throughput is &quot;the average number of clock cycles per instruction when the instructions are not part of a limiting dependency chain.&quot; Therefore, costs should be scaled to account for multiple execution units on the target that can process this type of instruction. For example, if there are 5 scalar integer units and 2 vector integer units that can calculate an &apos;add&apos; in a single cycle, this model should indicate that the cost of the vector add instruction is 2.5 times the cost of the scalar add instruction.\p Args is an optional argument which holds the instruction operands values so the TTI can analyze those values searching for special cases or optimizations based on those values.\p CxtI is the optional original context instruction, if one exists, to provide even more information.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L906">llvm/include/llvm/Analysis/TargetTransformInfo.h:906</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code">llvm::TargetTransformInfo::OperandValueKind<b> Opd1Info</b> = OK_AnyValue</dt><dt class="is-family-code">llvm::TargetTransformInfo::OperandValueKind<b> Opd2Info</b> = OK_AnyValue</dt><dt class="is-family-code">llvm::TargetTransformInfo::OperandValueProperties<b> Opd1PropInfo</b> = OP_None</dt><dt class="is-family-code">llvm::TargetTransformInfo::OperandValueProperties<b> Opd2PropInfo</b> = OP_None</dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt;<b> Args</b> = llvm::ArrayRef&lt;const llvm::Value *&gt;()</dt><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> CxtI</b> = nullptr</dt></dl><h3 id="ECFC4187B7235650"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#ECFC4187B7235650">¶</a><code class="hdoc-function-code language-cpp">int getArithmeticReductionCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    bool IsPairwiseForm) const</code></pre></h3><h4>Description</h4><p>Calculate the cost of performing a vector reduction. This is the cost of reducing the vector value of type \p Ty to a scalar value using the operation denoted by \p Opcode. The form of the reduction can either be a pairwise reduction or a reduction that splits the vector at every reduction level. Pairwise: (v0, v1, v2, v3) ((v0+v1), (v2+v3), undef, undef) Split: (v0, v1, v2, v3) ((v0+v2), (v1+v3), undef, undef)</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L995">llvm/include/llvm/Analysis/TargetTransformInfo.h:995</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code">bool<b> IsPairwiseForm</b></dt></dl><h3 id="E4224B4C01ACE797"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E4224B4C01ACE797">¶</a><code class="hdoc-function-code language-cpp">unsigned int getAtomicMemIntrinsicMaxElementSize()
    const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1046">llvm/include/llvm/Analysis/TargetTransformInfo.h:1046</a></p><h4>Returns</h4><p>The maximum element size, in bytes, for an element unordered-atomic memory intrinsic.</p><h3 id="3D9B78A06469EA7B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3D9B78A06469EA7B">¶</a><code class="hdoc-function-code language-cpp">int getCFInstrCost(unsigned int Opcode) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L935">llvm/include/llvm/Analysis/TargetTransformInfo.h:935</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt></dl><h4>Returns</h4><p>The expected cost of control-flow related instructions such as Phi, Ret, Br.</p><h3 id="AA1B6D960B2D9CAE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AA1B6D960B2D9CAE">¶</a><code class="hdoc-function-code language-cpp"><a href="r6607998C23E31109.html">llvm::Optional</a>&lt;unsigned int&gt;
getCacheAssociativity(
    llvm::TargetTransformInfo::CacheLevel Level)
    const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L863">llvm/include/llvm/Analysis/TargetTransformInfo.h:863</a></p><h4>Parameters</h4><dl><dt class="is-family-code">llvm::TargetTransformInfo::CacheLevel<b> Level</b></dt></dl><h4>Returns</h4><p>The associativity of the cache level, if available.</p><h3 id="9FEEAC82B37D172F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9FEEAC82B37D172F">¶</a><code class="hdoc-function-code language-cpp">unsigned int getCacheLineSize() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L847">llvm/include/llvm/Analysis/TargetTransformInfo.h:847</a></p><h4>Returns</h4><p>The size of a cache line in bytes.</p><h3 id="3D818AD878744060"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3D818AD878744060">¶</a><code class="hdoc-function-code language-cpp"><a href="r6607998C23E31109.html">llvm::Optional</a>&lt;unsigned int&gt; getCacheSize(
    llvm::TargetTransformInfo::CacheLevel Level)
    const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L860">llvm/include/llvm/Analysis/TargetTransformInfo.h:860</a></p><h4>Parameters</h4><dl><dt class="is-family-code">llvm::TargetTransformInfo::CacheLevel<b> Level</b></dt></dl><h4>Returns</h4><p>The size of the cache level in bytes, if available.</p><h3 id="F37108000D8B97B3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F37108000D8B97B3">¶</a><code class="hdoc-function-code language-cpp">int getCallCost(
    const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* F,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt; Arguments,
    const <a href="r837F022AC7CDEC6A.html">llvm::User</a>* U = nullptr) const</code></pre></h3><h4>Description</h4><p>Estimate the cost of calling a specific function when lowered. This overload allows specifying a set of candidate argument values.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L258">llvm/include/llvm/Analysis/TargetTransformInfo.h:258</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> F</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt;<b> Arguments</b></dt><dt class="is-family-code">const <a href="r837F022AC7CDEC6A.html">llvm::User</a>*<b> U</b> = nullptr</dt></dl><h3 id="119CDC8A7969927D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#119CDC8A7969927D">¶</a><code class="hdoc-function-code language-cpp">int getCallCost(
    <a href="rC1FD9EFFA70C10FE.html">llvm::FunctionType</a>* FTy,
    int NumArgs = -1,
    const <a href="r837F022AC7CDEC6A.html">llvm::User</a>* U = nullptr) const</code></pre></h3><h4>Description</h4><p>Estimate the cost of a function call when lowered. The contract for this is the same as \c getOperationCost except that it supports an interface that provides extra information specific to call instructions. This is the most basic query for estimating call cost: it only knows the function type and (potentially) the number of arguments at the call site. The latter is only interesting for varargs function types.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L245">llvm/include/llvm/Analysis/TargetTransformInfo.h:245</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rC1FD9EFFA70C10FE.html">llvm::FunctionType</a>*<b> FTy</b></dt><dt class="is-family-code">int<b> NumArgs</b> = -1</dt><dt class="is-family-code">const <a href="r837F022AC7CDEC6A.html">llvm::User</a>*<b> U</b> = nullptr</dt></dl><h3 id="C38F9F9F696E2F26"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C38F9F9F696E2F26">¶</a><code class="hdoc-function-code language-cpp">int getCallCost(
    const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* F,
    int NumArgs = -1,
    const <a href="r837F022AC7CDEC6A.html">llvm::User</a>* U = nullptr) const</code></pre></h3><h4>Description</h4><p>Estimate the cost of calling a specific function when lowered. This overload adds the ability to reason about the particular function being called in the event it is a library call with special lowering.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L252">llvm/include/llvm/Analysis/TargetTransformInfo.h:252</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> F</b></dt><dt class="is-family-code">int<b> NumArgs</b> = -1</dt><dt class="is-family-code">const <a href="r837F022AC7CDEC6A.html">llvm::User</a>*<b> U</b> = nullptr</dt></dl><h3 id="400F0D58BE62B7DB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#400F0D58BE62B7DB">¶</a><code class="hdoc-function-code language-cpp">int getCallInstrCost(
    <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* F,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* RetTy,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt; Tys) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1015">llvm/include/llvm/Analysis/TargetTransformInfo.h:1015</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> F</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> RetTy</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt;<b> Tys</b></dt></dl><h4>Returns</h4><p>The cost of Call instructions.</p><h3 id="2090B707B6430DDB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2090B707B6430DDB">¶</a><code class="hdoc-function-code language-cpp">int getCastInstrCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Dst,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Src,
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I = nullptr) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L925">llvm/include/llvm/Analysis/TargetTransformInfo.h:925</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Dst</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Src</b></dt><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b> = nullptr</dt></dl><h4>Returns</h4><p>The expected cost of cast instructions, such as bitcast, trunc, zext, etc. If there is an existing instruction that holds Opcode, it may be passed in the &apos;I&apos; parameter.</p><h3 id="51023D98122FD4A4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#51023D98122FD4A4">¶</a><code class="hdoc-function-code language-cpp">int getCmpSelInstrCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* ValTy,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* CondTy = nullptr,
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I = nullptr) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L940">llvm/include/llvm/Analysis/TargetTransformInfo.h:940</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> ValTy</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> CondTy</b> = nullptr</dt><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b> = nullptr</dt></dl><h4>Returns</h4><p>The expected cost of compare and select instructions. If there is an existing instruction that holds Opcode, it may be passed in the &apos;I&apos; parameter.</p><h3 id="9BFB22324BE3494F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9BFB22324BE3494F">¶</a><code class="hdoc-function-code language-cpp">unsigned int getCostOfKeepingLiveOverCall(
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt; Tys) const</code></pre></h3><h4>Description</h4><p>Some types may require the use of register classes that do not have any callee-saved registers, so would require a spill and fill.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1036">llvm/include/llvm/Analysis/TargetTransformInfo.h:1036</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt;<b> Tys</b></dt></dl><h4>Returns</h4><p>The cost, if any, of keeping values of the given types alive over a callsite.</p><h3 id="C6C61675536AC3A0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C6C61675536AC3A0">¶</a><code class="hdoc-function-code language-cpp">unsigned int getEstimatedNumberOfCaseClusters(
    const <a href="r1A6F1C03A3F0DA37.html">llvm::SwitchInst</a>&amp; SI,
    unsigned int&amp; JTSize,
    <a href="r8A8A34C2707DD732.html">llvm::ProfileSummaryInfo</a>* PSI,
    <a href="r499F3CE9244F5224.html">llvm::BlockFrequencyInfo</a>* BFI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L302">llvm/include/llvm/Analysis/TargetTransformInfo.h:302</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r1A6F1C03A3F0DA37.html">llvm::SwitchInst</a>&amp;<b> SI</b></dt><dt class="is-family-code">unsigned int&amp;<b> JTSize</b></dt><dt class="is-family-code"><a href="r8A8A34C2707DD732.html">llvm::ProfileSummaryInfo</a>*<b> PSI</b></dt><dt class="is-family-code"><a href="r499F3CE9244F5224.html">llvm::BlockFrequencyInfo</a>*<b> BFI</b></dt></dl><h4>Returns</h4><p>The estimated number of case clusters when lowering \p &apos;SI&apos;. \p JTSize Set a jump table size only when \p SI is suitable for a jump table.</p><h3 id="A0BCBE67AA005CC5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A0BCBE67AA005CC5">¶</a><code class="hdoc-function-code language-cpp">int getExtCost(const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I,
               const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Src) const</code></pre></h3><h4>Description</h4><p>Estimate the cost of a EXT operation when lowered. The contract for this function is the same as \c getOperationCost except that it supports an interface that provides extra information specific to the EXT operation.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L234">llvm/include/llvm/Analysis/TargetTransformInfo.h:234</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Src</b></dt></dl><h3 id="68F96D6F5DAA5CA6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#68F96D6F5DAA5CA6">¶</a><code class="hdoc-function-code language-cpp">int getExtractWithExtendCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Dst,
    <a href="rBA702C5D0CD7CD0E.html">llvm::VectorType</a>* VecTy,
    unsigned int Index = -1) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L930">llvm/include/llvm/Analysis/TargetTransformInfo.h:930</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Dst</b></dt><dt class="is-family-code"><a href="rBA702C5D0CD7CD0E.html">llvm::VectorType</a>*<b> VecTy</b></dt><dt class="is-family-code">unsigned int<b> Index</b> = -1</dt></dl><h4>Returns</h4><p>The expected cost of a sign- or zero-extended vector extract. Use -1 to indicate that there is no information about the index value.</p><h3 id="54C1642AA7DAF1E6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#54C1642AA7DAF1E6">¶</a><code class="hdoc-function-code language-cpp">int getFPOpCost(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Return the expected cost of supporting the floating point operation of the specified type.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L748">llvm/include/llvm/Analysis/TargetTransformInfo.h:748</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="33996ED0A712F7DC"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#33996ED0A712F7DC">¶</a><code class="hdoc-function-code language-cpp">unsigned int getFlatAddressSpace() const</code></pre></h3><h4>Description</h4><p>This is for targets with different pointer representations which can be converted with the addrspacecast instruction. If a pointer is converted to this address space, optimizations should attempt to replace the access with the source address space.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L374">llvm/include/llvm/Analysis/TargetTransformInfo.h:374</a></p><h4>Returns</h4><p>~0u if the target does not have such a flat address space to optimize away.</p><h3 id="16D84845BF186F16"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#16D84845BF186F16">¶</a><code class="hdoc-function-code language-cpp">int getGEPCost(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* PointeeType,
    const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Ptr,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt; Operands) const</code></pre></h3><h4>Description</h4><p>Estimate the cost of a GEP operation when lowered. The contract for this function is the same as \c getOperationCost except that it supports an interface that provides extra information specific to the GEP operation.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L226">llvm/include/llvm/Analysis/TargetTransformInfo.h:226</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> PointeeType</b></dt><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Ptr</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt;<b> Operands</b></dt></dl><h3 id="2999B6BA2194D98E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2999B6BA2194D98E">¶</a><code class="hdoc-function-code language-cpp">unsigned int getGISelRematGlobalCost() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1150">llvm/include/llvm/Analysis/TargetTransformInfo.h:1150</a></p><h4>Returns</h4><p>the size cost of rematerializing a GlobalValue address relative to a stack reload.</p><h3 id="751C05AA05C4D580"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#751C05AA05C4D580">¶</a><code class="hdoc-function-code language-cpp">int getGatherScatterOpCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataTy,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Ptr,
    bool VariableMask,
    unsigned int Alignment) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L963">llvm/include/llvm/Analysis/TargetTransformInfo.h:963</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataTy</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Ptr</b></dt><dt class="is-family-code">bool<b> VariableMask</b></dt><dt class="is-family-code">unsigned int<b> Alignment</b></dt></dl><h4>Returns</h4><p>The cost of Gather or Scatter operation\p Opcode - is a type of memory access Load or Store\p DataTy - a vector type of the data to be loaded or stored\p Ptr - pointer [or vector of pointers] - address[es] in memory\p VariableMask - true when the memory access is predicated with a mask that is not a compile-time constant\p Alignment - alignment of single element</p><h3 id="655434316838039A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#655434316838039A">¶</a><code class="hdoc-function-code language-cpp">int getInlinerVectorBonusPercent() const</code></pre></h3><h4>Description</h4><p>Vector bonuses: We want to more aggressively inline vector-dense kernels and apply this bonus based on the percentage of vector instructions. A bonus is applied if the vector instructions exceed 50% and half that amount is applied if it exceeds 10%. Note that these bonuses are some what arbitrary and evolved over time by accident as much as because they are principled bonuses. FIXME: It would be nice to base the bonus values on something more scientific. A target may has no bonus on vector instructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L279">llvm/include/llvm/Analysis/TargetTransformInfo.h:279</a></p><h4>Returns</h4><p>Vector bonus in percent.</p><h3 id="04FE052E3B102863"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#04FE052E3B102863">¶</a><code class="hdoc-function-code language-cpp">unsigned int getInliningThresholdMultiplier()
    const</code></pre></h3><h4>Description</h4><p>TODO: This is a rather blunt instrument.  Perhaps altering the costs of individual classes of instructions would be better.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L267">llvm/include/llvm/Analysis/TargetTransformInfo.h:267</a></p><h4>Returns</h4><p>A value by which our inlining threshold should be multiplied. This is primarily used to bump up the inlining threshold wholesale on targets where calls are unusually expensive.</p><h3 id="6E2A625500598816"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6E2A625500598816">¶</a><code class="hdoc-function-code language-cpp">int getInstructionCost(
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I,
    enum TargetCostKind kind) const</code></pre></h3><h4>Description</h4><p>Query the cost of a specified instruction. Clients should use this interface to query the cost of an existing instruction. The instruction must have a valid parent (basic block). Note, this method does not cache the cost calculation and it can be expensive in some cases.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L167">llvm/include/llvm/Analysis/TargetTransformInfo.h:167</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt><dt class="is-family-code">enum TargetCostKind<b> kind</b></dt></dl><h3 id="ADCECDFE4075E785"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#ADCECDFE4075E785">¶</a><code class="hdoc-function-code language-cpp">int getIntImmCodeSizeCost(unsigned int Opc,
                          unsigned int Idx,
                          const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp; Imm,
                          <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Return the expected cost for the given integer when optimising for size. This is different than the other integer immediate cost functions in that it is subtarget agnostic. This is useful when you e.g. target one ISA such as Aarch32 but smaller encodings could be possible with another such as Thumb. This return value is used as a penalty when the total costs for a constant is calculated (the bigger the cost, the more beneficial constant hoisting is).</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L769">llvm/include/llvm/Analysis/TargetTransformInfo.h:769</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opc</b></dt><dt class="is-family-code">unsigned int<b> Idx</b></dt><dt class="is-family-code">const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp;<b> Imm</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="79A54799EB9CFC54"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#79A54799EB9CFC54">¶</a><code class="hdoc-function-code language-cpp">int getIntImmCost(const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp; Imm,
                  <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Return the expected cost of materializing for the given integer immediate of the specified type.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L752">llvm/include/llvm/Analysis/TargetTransformInfo.h:752</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp;<b> Imm</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="D464A9EACF6430FD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D464A9EACF6430FD">¶</a><code class="hdoc-function-code language-cpp">int getIntImmCostInst(unsigned int Opc,
                      unsigned int Idx,
                      const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp; Imm,
                      <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Return the expected cost of materialization for the given integer immediate of the specified type for a given instruction. The cost can be zero if the immediate can be folded into the specified instruction.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L757">llvm/include/llvm/Analysis/TargetTransformInfo.h:757</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opc</b></dt><dt class="is-family-code">unsigned int<b> Idx</b></dt><dt class="is-family-code">const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp;<b> Imm</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="078BE150BC26C513"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#078BE150BC26C513">¶</a><code class="hdoc-function-code language-cpp">int getIntImmCostIntrin(Intrinsic::ID IID,
                        unsigned int Idx,
                        const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp; Imm,
                        <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L759">llvm/include/llvm/Analysis/TargetTransformInfo.h:759</a></p><h4>Parameters</h4><dl><dt class="is-family-code">Intrinsic::ID<b> IID</b></dt><dt class="is-family-code">unsigned int<b> Idx</b></dt><dt class="is-family-code">const <a href="r50D306F9F4C3FD25.html">llvm::APInt</a>&amp;<b> Imm</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="E6C24FDA62493DE6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E6C24FDA62493DE6">¶</a><code class="hdoc-function-code language-cpp">int getInterleavedMemoryOpCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* VecTy,
    unsigned int Factor,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt; Indices,
    unsigned int Alignment,
    unsigned int AddressSpace,
    bool UseMaskForCond = false,
    bool UseMaskForGaps = false) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L976">llvm/include/llvm/Analysis/TargetTransformInfo.h:976</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> VecTy</b></dt><dt class="is-family-code">unsigned int<b> Factor</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;unsigned int&gt;<b> Indices</b></dt><dt class="is-family-code">unsigned int<b> Alignment</b></dt><dt class="is-family-code">unsigned int<b> AddressSpace</b></dt><dt class="is-family-code">bool<b> UseMaskForCond</b> = false</dt><dt class="is-family-code">bool<b> UseMaskForGaps</b> = false</dt></dl><h4>Returns</h4><p>The cost of the interleaved memory operation.\p Opcode is the memory operation code\p VecTy is the vector type of the interleaved access.\p Factor is the interleave factor\p Indices is the indices for interleaved load members (as interleaved load allows gaps)\p Alignment is the alignment of the memory operation\p AddressSpace is address space of the pointer.\p UseMaskForCond indicates if the memory access is predicated.\p UseMaskForGaps indicates if gaps should be masked.</p><h3 id="ACBFD7E3C3B36EEA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#ACBFD7E3C3B36EEA">¶</a><code class="hdoc-function-code language-cpp">int getIntrinsicCost(
    Intrinsic::ID IID,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* RetTy,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt; ParamTys,
    const <a href="r837F022AC7CDEC6A.html">llvm::User</a>* U = nullptr) const</code></pre></h3><h4>Description</h4><p>Estimate the cost of an intrinsic when lowered. Mirrors the \c getCallCost method but uses an intrinsic identifier.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L284">llvm/include/llvm/Analysis/TargetTransformInfo.h:284</a></p><h4>Parameters</h4><dl><dt class="is-family-code">Intrinsic::ID<b> IID</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> RetTy</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt;<b> ParamTys</b></dt><dt class="is-family-code">const <a href="r837F022AC7CDEC6A.html">llvm::User</a>*<b> U</b> = nullptr</dt></dl><h3 id="4E37569C17DF3DD1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4E37569C17DF3DD1">¶</a><code class="hdoc-function-code language-cpp">int getIntrinsicCost(
    Intrinsic::ID IID,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* RetTy,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt; Arguments,
    const <a href="r837F022AC7CDEC6A.html">llvm::User</a>* U = nullptr) const</code></pre></h3><h4>Description</h4><p>Estimate the cost of an intrinsic when lowered. Mirrors the \c getCallCost method but uses an intrinsic identifier.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L291">llvm/include/llvm/Analysis/TargetTransformInfo.h:291</a></p><h4>Parameters</h4><dl><dt class="is-family-code">Intrinsic::ID<b> IID</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> RetTy</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt;<b> Arguments</b></dt><dt class="is-family-code">const <a href="r837F022AC7CDEC6A.html">llvm::User</a>*<b> U</b> = nullptr</dt></dl><h3 id="701C63C9D08A9CD2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#701C63C9D08A9CD2">¶</a><code class="hdoc-function-code language-cpp">int getIntrinsicInstrCost(
    Intrinsic::ID ID,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* RetTy,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Value*&gt; Args,
    <a href="rB015E228FFC78DC5.html">llvm::FastMathFlags</a> FMF,
    unsigned int VF = 1) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1003">llvm/include/llvm/Analysis/TargetTransformInfo.h:1003</a></p><h4>Parameters</h4><dl><dt class="is-family-code">Intrinsic::ID<b> ID</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> RetTy</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Value*&gt;<b> Args</b></dt><dt class="is-family-code"><a href="rB015E228FFC78DC5.html">llvm::FastMathFlags</a><b> FMF</b></dt><dt class="is-family-code">unsigned int<b> VF</b> = 1</dt></dl><h4>Returns</h4><p>The cost of Intrinsic instructions. Analyses the real arguments. Three cases are handled: 1. scalar instruction 2. vector instruction 3. scalar instruction which is to be vectorized with VF.</p><h3 id="74F70B39E711A679"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#74F70B39E711A679">¶</a><code class="hdoc-function-code language-cpp">int getIntrinsicInstrCost(
    Intrinsic::ID ID,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* RetTy,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt; Tys,
    <a href="rB015E228FFC78DC5.html">llvm::FastMathFlags</a> FMF,
    unsigned int ScalarizationCostPassed =
        (2147483647 * 2U + 1U)) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1010">llvm/include/llvm/Analysis/TargetTransformInfo.h:1010</a></p><h4>Parameters</h4><dl><dt class="is-family-code">Intrinsic::ID<b> ID</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> RetTy</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Type*&gt;<b> Tys</b></dt><dt class="is-family-code"><a href="rB015E228FFC78DC5.html">llvm::FastMathFlags</a><b> FMF</b></dt><dt class="is-family-code">unsigned int<b> ScalarizationCostPassed</b> = (2147483647 * 2U + 1U)</dt></dl><h4>Returns</h4><p>The cost of Intrinsic instructions. Types analysis only. If ScalarizationCostPassed is UINT_MAX, the cost of scalarizing the arguments and the return value will be computed based on types.</p><h3 id="6E951F4C6F456BCA"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6E951F4C6F456BCA">¶</a><code class="hdoc-function-code language-cpp">unsigned int getLoadStoreVecRegBitWidth(
    unsigned int AddrSpace) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1101">llvm/include/llvm/Analysis/TargetTransformInfo.h:1101</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> AddrSpace</b></dt></dl><h4>Returns</h4><p>The bitwidth of the largest vector type that should be used to load/store in the given address space.</p><h3 id="1FC5AC54470A8189"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1FC5AC54470A8189">¶</a><code class="hdoc-function-code language-cpp">unsigned int getLoadVectorFactor(
    unsigned int VF,
    unsigned int LoadSize,
    unsigned int ChainSizeInBytes,
    <a href="rBA702C5D0CD7CD0E.html">llvm::VectorType</a>* VecTy) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1121">llvm/include/llvm/Analysis/TargetTransformInfo.h:1121</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> VF</b></dt><dt class="is-family-code">unsigned int<b> LoadSize</b></dt><dt class="is-family-code">unsigned int<b> ChainSizeInBytes</b></dt><dt class="is-family-code"><a href="rBA702C5D0CD7CD0E.html">llvm::VectorType</a>*<b> VecTy</b></dt></dl><h4>Returns</h4><p>The new vector factor value if the target doesn&apos;t support \p SizeInBytes loads or has a better vector factor.</p><h3 id="422B9DF689C0BA4F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#422B9DF689C0BA4F">¶</a><code class="hdoc-function-code language-cpp">int getMaskedMemoryOpCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Src,
    unsigned int Alignment,
    unsigned int AddressSpace) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L953">llvm/include/llvm/Analysis/TargetTransformInfo.h:953</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Src</b></dt><dt class="is-family-code">unsigned int<b> Alignment</b></dt><dt class="is-family-code">unsigned int<b> AddressSpace</b></dt></dl><h4>Returns</h4><p>The cost of masked Load and Store instructions.</p><h3 id="1433317623F3D1DC"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1433317623F3D1DC">¶</a><code class="hdoc-function-code language-cpp">unsigned int getMaxInterleaveFactor(
    unsigned int VF) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L884">llvm/include/llvm/Analysis/TargetTransformInfo.h:884</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> VF</b></dt></dl><h4>Returns</h4><p>The maximum interleave factor that any transform should try to perform for this target. This number depends on the level of parallelism and the number of execution units in the CPU.</p><h3 id="EC0ACABF58128536"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EC0ACABF58128536">¶</a><code class="hdoc-function-code language-cpp">unsigned int getMaxPrefetchIterationsAhead() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L879">llvm/include/llvm/Analysis/TargetTransformInfo.h:879</a></p><h4>Returns</h4><p>The maximum number of iterations to prefetch ahead.  If the required number of iterations is more than this number, no prefetching is performed.</p><h3 id="6B33222D2A49A264"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6B33222D2A49A264">¶</a><code class="hdoc-function-code language-cpp">int getMemcpyCost(
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L297">llvm/include/llvm/Analysis/TargetTransformInfo.h:297</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt></dl><h4>Returns</h4><p>the expected cost of a memcpy, which could e.g. depend on the source/destination type and alignment and the number of bytes copied.</p><h3 id="988B7BB9C840E64A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#988B7BB9C840E64A">¶</a><code class="hdoc-function-code language-cpp"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>* getMemcpyLoopLoweringType(
    <a href="rB8F46D3CD599E2BD.html">llvm::LLVMContext</a>&amp; Context,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Length,
    unsigned int SrcAlign,
    unsigned int DestAlign) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1056">llvm/include/llvm/Analysis/TargetTransformInfo.h:1056</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rB8F46D3CD599E2BD.html">llvm::LLVMContext</a>&amp;<b> Context</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Length</b></dt><dt class="is-family-code">unsigned int<b> SrcAlign</b></dt><dt class="is-family-code">unsigned int<b> DestAlign</b></dt></dl><h4>Returns</h4><p>The type to use in a loop expansion of a memcpy call.</p><h3 id="B060236E936DA024"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B060236E936DA024">¶</a><code class="hdoc-function-code language-cpp">void getMemcpyLoopResidualLoweringType(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::Type*&gt;&amp; OpsOut,
    <a href="rB8F46D3CD599E2BD.html">llvm::LLVMContext</a>&amp; Context,
    unsigned int RemainingBytes,
    unsigned int SrcAlign,
    unsigned int DestAlign) const</code></pre></h3><h4>Description</h4><p>Calculates the operand types to use when copying \p RemainingBytes of memory, where source and destination alignments are \p SrcAlign and\p DestAlign respectively.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1065">llvm/include/llvm/Analysis/TargetTransformInfo.h:1065</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::Type*&gt;&amp;<b> OpsOut</b></dt><dd>The operand types to copy RemainingBytes of memory.</dd><dt class="is-family-code"><a href="rB8F46D3CD599E2BD.html">llvm::LLVMContext</a>&amp;<b> Context</b></dt><dt class="is-family-code">unsigned int<b> RemainingBytes</b></dt><dd>The number of bytes to copy.</dd><dt class="is-family-code">unsigned int<b> SrcAlign</b></dt><dt class="is-family-code">unsigned int<b> DestAlign</b></dt></dl><h3 id="B3DC484E24DB631A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B3DC484E24DB631A">¶</a><code class="hdoc-function-code language-cpp">int getMemoryOpCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Src,
    <a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a> Alignment,
    unsigned int AddressSpace,
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I = nullptr) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L948">llvm/include/llvm/Analysis/TargetTransformInfo.h:948</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Src</b></dt><dt class="is-family-code"><a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a><b> Alignment</b></dt><dt class="is-family-code">unsigned int<b> AddressSpace</b></dt><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b> = nullptr</dt></dl><h4>Returns</h4><p>The cost of Load and Store instructions.</p><h3 id="75AD444C2A04BEEB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#75AD444C2A04BEEB">¶</a><code class="hdoc-function-code language-cpp">int getMinMaxReductionCost(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
                           <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* CondTy,
                           bool IsPairwiseForm,
                           bool IsUnsigned) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L997">llvm/include/llvm/Analysis/TargetTransformInfo.h:997</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> CondTy</b></dt><dt class="is-family-code">bool<b> IsPairwiseForm</b></dt><dt class="is-family-code">bool<b> IsUnsigned</b></dt></dl><h3 id="C2A70C5B23F42127"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C2A70C5B23F42127">¶</a><code class="hdoc-function-code language-cpp">unsigned int getMinPrefetchStride() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L874">llvm/include/llvm/Analysis/TargetTransformInfo.h:874</a></p><h4>Returns</h4><p>Some HW prefetchers can handle accesses up to a certain constant stride.  This is the minimum stride in bytes where it makes sense to start adding SW prefetches.  The default is 1, i.e. prefetch with any stride.</p><h3 id="1459280368AA3970"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1459280368AA3970">¶</a><code class="hdoc-function-code language-cpp">unsigned int getMinVectorRegisterBitWidth() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L825">llvm/include/llvm/Analysis/TargetTransformInfo.h:825</a></p><h4>Returns</h4><p>The width of the smallest vector register type.</p><h3 id="74BC3C8A9B7E6D27"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#74BC3C8A9B7E6D27">¶</a><code class="hdoc-function-code language-cpp">unsigned int getMinimumVF(
    unsigned int ElemWidth) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L838">llvm/include/llvm/Analysis/TargetTransformInfo.h:838</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> ElemWidth</b></dt></dl><h4>Returns</h4><p>The minimum vectorization factor for types of given element bit width, or 0 if there is no minimum VF. The returned value only applies when shouldMaximizeVectorBandwidth returns true.</p><h3 id="FD56C7D3B0CE350F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FD56C7D3B0CE350F">¶</a><code class="hdoc-function-code language-cpp">unsigned int getNumberOfParts(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Tp) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1019">llvm/include/llvm/Analysis/TargetTransformInfo.h:1019</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Tp</b></dt></dl><h4>Returns</h4><p>The number of pieces into which the provided type must be split during legalization. Zero is returned when the answer is unknown.</p><h3 id="8B89174B1442F6CB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8B89174B1442F6CB">¶</a><code class="hdoc-function-code language-cpp">unsigned int getNumberOfRegisters(
    unsigned int ClassID) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L804">llvm/include/llvm/Analysis/TargetTransformInfo.h:804</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> ClassID</b></dt></dl><h4>Returns</h4><p>the number of registers in the target-provided register class.</p><h3 id="DAEF03B3C076F4DF"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DAEF03B3C076F4DF">¶</a><code class="hdoc-function-code language-cpp">static llvm::TargetTransformInfo::OperandValueKind
getOperandInfo(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V,
    llvm::TargetTransformInfo::
        OperandValueProperties&amp; OpProps)</code></pre></h3><h4>Description</h4><p>Collect properties of V used in cost analysis, e.g. OP_PowerOf2.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L887">llvm/include/llvm/Analysis/TargetTransformInfo.h:887</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt><dt class="is-family-code">llvm::TargetTransformInfo::OperandValueProperties&amp;<b> OpProps</b></dt></dl><h3 id="AB9CEFD3D4C30283"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AB9CEFD3D4C30283">¶</a><code class="hdoc-function-code language-cpp">unsigned int getOperandsScalarizationOverhead(
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt; Args,
    unsigned int VF) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L670">llvm/include/llvm/Analysis/TargetTransformInfo.h:670</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt;<b> Args</b></dt><dt class="is-family-code">unsigned int<b> VF</b></dt></dl><h3 id="25C1F84A26A03333"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#25C1F84A26A03333">¶</a><code class="hdoc-function-code language-cpp">int getOperationCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* OpTy = nullptr) const</code></pre></h3><h4>Description</h4><p>Estimate the cost of a specific operation when lowered. Note that this is designed to work on an arbitrary synthetic opcode, and thus work for hypothetical queries before an instruction has even been formed. However, this does *not* work for GEPs, and must not be called for a GEP instruction. Instead, use the dedicated getGEPCost interface as analyzing a GEP&apos;s cost required more information. Typically only the result type is required, and the operand type can be omitted. However, if the opcode is one of the cast instructions, the operand type is required. The returned cost is defined in terms of \c TargetCostConstants, see its comments for a detailed explanation of the cost values.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L219">llvm/include/llvm/Analysis/TargetTransformInfo.h:219</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> OpTy</b> = nullptr</dt></dl><h3 id="3ED3FA8DB7BEED84"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3ED3FA8DB7BEED84">¶</a><code class="hdoc-function-code language-cpp"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>* getOrCreateResultFromMemIntrinsic(
    <a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>* Inst,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* ExpectedType) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1052">llvm/include/llvm/Analysis/TargetTransformInfo.h:1052</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>*<b> Inst</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> ExpectedType</b></dt></dl><h4>Returns</h4><p>A value which is the result of the given memory intrinsic.  New instructions may be created to extract the result from the given intrinsic memory operation.  Returns nullptr if the target cannot create a result from the given intrinsic.</p><h3 id="7BB76D9C68CEC858"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7BB76D9C68CEC858">¶</a><code class="hdoc-function-code language-cpp">llvm::TargetTransformInfo::PopcntSupportKind
getPopcntSupport(
    unsigned int IntTyWidthInBit) const</code></pre></h3><h4>Description</h4><p>Return hardware support for population count.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L735">llvm/include/llvm/Analysis/TargetTransformInfo.h:735</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> IntTyWidthInBit</b></dt></dl><h3 id="2122C900E508F924"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2122C900E508F924">¶</a><code class="hdoc-function-code language-cpp">unsigned int getPrefetchDistance() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L868">llvm/include/llvm/Analysis/TargetTransformInfo.h:868</a></p><h4>Returns</h4><p>How much before a load we should place the prefetch instruction.  This is currently measured in number of instructions.</p><h3 id="BD200CC35F813AB1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BD200CC35F813AB1">¶</a><code class="hdoc-function-code language-cpp">unsigned int getRegisterBitWidth(
    bool Vector) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L822">llvm/include/llvm/Analysis/TargetTransformInfo.h:822</a></p><h4>Parameters</h4><dl><dt class="is-family-code">bool<b> Vector</b></dt></dl><h4>Returns</h4><p>The width of the largest scalar or vector register type.</p><h3 id="5F28032E8382173C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5F28032E8382173C">¶</a><code class="hdoc-function-code language-cpp">unsigned int getRegisterClassForType(
    bool Vector,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty = nullptr) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L816">llvm/include/llvm/Analysis/TargetTransformInfo.h:816</a></p><h4>Parameters</h4><dl><dt class="is-family-code">bool<b> Vector</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b> = nullptr</dt></dl><h4>Returns</h4><p>the target-provided register class ID for the provided type, accounting for type promotion and other type-legalization techniques that the target might apply. However, it specifically does not account for the scalarization or splitting of vector types. Should a vector type require scalarization or splitting into multiple underlying vector registers, that type should be mapped to a register class containing no registers. Specifically, this is designed to provide a simple, high-level view of the register allocation later performed by the backend. These register classes don&apos;t necessarily map onto the register classes used by the backend. FIXME: It&apos;s not currently possible to determine how many registers are used by the provided type.</p><h3 id="2719AEE9D307EB2B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2719AEE9D307EB2B">¶</a><code class="hdoc-function-code language-cpp">const char* getRegisterClassName(
    unsigned int ClassID) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L819">llvm/include/llvm/Analysis/TargetTransformInfo.h:819</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> ClassID</b></dt></dl><h4>Returns</h4><p>the target-provided register class name</p><h3 id="EFDE153BAAA49072"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EFDE153BAAA49072">¶</a><code class="hdoc-function-code language-cpp">unsigned int getScalarizationOverhead(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    bool Insert,
    bool Extract) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L668">llvm/include/llvm/Analysis/TargetTransformInfo.h:668</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code">bool<b> Insert</b></dt><dt class="is-family-code">bool<b> Extract</b></dt></dl><h3 id="DCDC0DB43FDBEDBB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DCDC0DB43FDBEDBB">¶</a><code class="hdoc-function-code language-cpp">int getScalingFactorCost(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    <a href="rC19E204A1DC9E834.html">llvm::GlobalValue</a>* BaseGV,
    int64_t BaseOffset,
    bool HasBaseReg,
    int64_t Scale,
    unsigned int AddrSpace = 0) const</code></pre></h3><h4>Description</h4><p>Return the cost of the scaling factor used in the addressing mode represented by AM for this target, for a load/store of the specified type. If the AM is supported, the return value must be &gt;= 0. If the AM is not supported, it returns a negative value. TODO: Handle pre/postinc as well.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L632">llvm/include/llvm/Analysis/TargetTransformInfo.h:632</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code"><a href="rC19E204A1DC9E834.html">llvm::GlobalValue</a>*<b> BaseGV</b></dt><dt class="is-family-code">int64_t<b> BaseOffset</b></dt><dt class="is-family-code">bool<b> HasBaseReg</b></dt><dt class="is-family-code">int64_t<b> Scale</b></dt><dt class="is-family-code">unsigned int<b> AddrSpace</b> = 0</dt></dl><h3 id="506C7E06B0A14F57"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#506C7E06B0A14F57">¶</a><code class="hdoc-function-code language-cpp">int getShuffleCost(
    llvm::TargetTransformInfo::ShuffleKind Kind,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Tp,
    int Index = 0,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* SubTp = nullptr) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L919">llvm/include/llvm/Analysis/TargetTransformInfo.h:919</a></p><h4>Parameters</h4><dl><dt class="is-family-code">llvm::TargetTransformInfo::ShuffleKind<b> Kind</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Tp</b></dt><dt class="is-family-code">int<b> Index</b> = 0</dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> SubTp</b> = nullptr</dt></dl><h4>Returns</h4><p>The cost of a shuffle instruction of kind Kind and of type Tp. The index and subtype parameters are used by the subvector insertion and extraction shuffle kinds to show the insert/extract point and the type of the subvector being inserted/extracted. NOTE: For subvector extractions Tp represents the source type.</p><h3 id="064D8917CA118FF4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#064D8917CA118FF4">¶</a><code class="hdoc-function-code language-cpp">unsigned int getStoreVectorFactor(
    unsigned int VF,
    unsigned int StoreSize,
    unsigned int ChainSizeInBytes,
    <a href="rBA702C5D0CD7CD0E.html">llvm::VectorType</a>* VecTy) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1127">llvm/include/llvm/Analysis/TargetTransformInfo.h:1127</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> VF</b></dt><dt class="is-family-code">unsigned int<b> StoreSize</b></dt><dt class="is-family-code">unsigned int<b> ChainSizeInBytes</b></dt><dt class="is-family-code"><a href="rBA702C5D0CD7CD0E.html">llvm::VectorType</a>*<b> VecTy</b></dt></dl><h4>Returns</h4><p>The new vector factor value if the target doesn&apos;t support \p SizeInBytes stores or has a better vector factor.</p><h3 id="5E46BAE8455B464D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5E46BAE8455B464D">¶</a><code class="hdoc-function-code language-cpp">bool getTgtMemIntrinsic(
    <a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>* Inst,
    <a href="r1AF924387FBF574E.html">llvm::MemIntrinsicInfo</a>&amp; Info) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1042">llvm/include/llvm/Analysis/TargetTransformInfo.h:1042</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>*<b> Inst</b></dt><dt class="is-family-code"><a href="r1AF924387FBF574E.html">llvm::MemIntrinsicInfo</a>&amp;<b> Info</b></dt></dl><h4>Returns</h4><p>True if the intrinsic is a supported memory intrinsic.  Info will contain additional information - whether the intrinsic may write or read to memory, volatility and the pointer.  Info is undefined if false is returned.</p><h3 id="76DA373AF6DE2893"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#76DA373AF6DE2893">¶</a><code class="hdoc-function-code language-cpp">void getUnrollingPreferences(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>&amp;,
    llvm::TargetTransformInfo::
        UnrollingPreferences&amp; UP) const</code></pre></h3><h4>Description</h4><p>Get target-customized preferences for the generic loop unrolling transformation. The caller will initialize UP with the current target-independent defaults.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L512">llvm/include/llvm/Analysis/TargetTransformInfo.h:512</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>&amp;<b> </b></dt><dt class="is-family-code"><a href="r8A7E02D3C80E8E2E.html">llvm::TargetTransformInfo::UnrollingPreferences</a>&amp;<b> UP</b></dt></dl><h3 id="3849F595E64B52FB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3849F595E64B52FB">¶</a><code class="hdoc-function-code language-cpp">int getUserCost(const <a href="r837F022AC7CDEC6A.html">llvm::User</a>* U) const</code></pre></h3><h4>Description</h4><p>This is a helper function which calls the two-argument getUserCost with \p Operands which are the current operands U has.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L332">llvm/include/llvm/Analysis/TargetTransformInfo.h:332</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r837F022AC7CDEC6A.html">llvm::User</a>*<b> U</b></dt></dl><h3 id="A619A4A58583DAE7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A619A4A58583DAE7">¶</a><code class="hdoc-function-code language-cpp">int getUserCost(
    const <a href="r837F022AC7CDEC6A.html">llvm::User</a>* U,
    <a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt; Operands) const</code></pre></h3><h4>Description</h4><p>Estimate the cost of a given IR user when lowered. This can estimate the cost of either a ConstantExpr or Instruction when lowered. It has two primary advantages over the \c getOperationCost and\c getGEPCost above, and one significant disadvantage: it can only be used when the IR construct has already been formed. The advantages are that it can inspect the SSA use graph to reason more accurately about the cost. For example, all-constant-GEPs can often be folded into a load or other instruction, but if they are used in some other context they may not be folded. This routine can distinguish such cases. \p Operands is a list of operands which can be a result of transformations of the current operands. The number of the operands on the list must equal to the number of the current operands the IR user has. Their order on the list must be the same as the order of the current operands the IR user has. The returned cost is defined in terms of \c TargetCostConstants, see its comments for a detailed explanation of the cost values.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L328">llvm/include/llvm/Analysis/TargetTransformInfo.h:328</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r837F022AC7CDEC6A.html">llvm::User</a>*<b> U</b></dt><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;const llvm::Value*&gt;<b> Operands</b></dt></dl><h3 id="CAA42CDC7357C032"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#CAA42CDC7357C032">¶</a><code class="hdoc-function-code language-cpp">int getVectorInstrCost(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Val,
    unsigned int Index = -1) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L945">llvm/include/llvm/Analysis/TargetTransformInfo.h:945</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Val</b></dt><dt class="is-family-code">unsigned int<b> Index</b> = -1</dt></dl><h4>Returns</h4><p>The expected cost of vector Insert and Extract. Use -1 to indicate that there is no information on the index value.</p><h3 id="B7DCCEF3B6DAB887"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B7DCCEF3B6DAB887">¶</a><code class="hdoc-function-code language-cpp">bool hasBranchDivergence() const</code></pre></h3><h4>Description</h4><p>Return true if branch divergence exists. Branch divergence has a significantly negative impact on GPU performance when threads in the same wavefront take different paths due to conditional branches.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L343">llvm/include/llvm/Analysis/TargetTransformInfo.h:343</a></p><h3 id="1509C06674F2D23A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1509C06674F2D23A">¶</a><code class="hdoc-function-code language-cpp">bool hasDivRemOp(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataType,
                 bool IsSigned) const</code></pre></h3><h4>Description</h4><p>Return true if the target has a unified operation to calculate division and remainder. If so, the additional implicit multiplication and subtraction required to calculate a remainder from division are free. This can enable more aggressive transformations for division and remainder than would typically be allowed using throughput or size cost models.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L614">llvm/include/llvm/Analysis/TargetTransformInfo.h:614</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataType</b></dt><dt class="is-family-code">bool<b> IsSigned</b></dt></dl><h3 id="470632B01532833B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#470632B01532833B">¶</a><code class="hdoc-function-code language-cpp">bool hasVolatileVariant(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I,
    unsigned int AddrSpace) const</code></pre></h3><h4>Description</h4><p>Return true if the given instruction (assumed to be a memory access instruction) has a volatile variant. If that&apos;s the case then we can avoid addrspacecast to generic AS for volatile loads/stores. Default implementation returns false, which prevents address space inference for volatile loads/stores.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L621">llvm/include/llvm/Analysis/TargetTransformInfo.h:621</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt><dt class="is-family-code">unsigned int<b> AddrSpace</b></dt></dl><h3 id="7BE509CC0102BDF2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7BE509CC0102BDF2">¶</a><code class="hdoc-function-code language-cpp">bool haveFastSqrt(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Return true if the hardware has a fast square-root instruction.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L738">llvm/include/llvm/Analysis/TargetTransformInfo.h:738</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="65B65E7169BE129F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#65B65E7169BE129F">¶</a><code class="hdoc-function-code language-cpp">bool invalidate(
    <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;,
    const <a href="r9EDCE8A1E6A8CDD6.html">llvm::PreservedAnalyses</a>&amp;,
    FunctionAnalysisManager::Invalidator&amp;)</code></pre></h3><h4>Description</h4><p>Handle the invalidation of this information. When used as a result of \c TargetIRAnalysis this method will be called when the function this was computed for changes. When it returns false, the information is preserved across those changes.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L140">llvm/include/llvm/Analysis/TargetTransformInfo.h:140</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> </b></dt><dt class="is-family-code">const <a href="r9EDCE8A1E6A8CDD6.html">llvm::PreservedAnalyses</a>&amp;<b> </b></dt><dt class="is-family-code">FunctionAnalysisManager::Invalidator&amp;<b> </b></dt></dl><h3 id="B34A8BFC88992BD7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B34A8BFC88992BD7">¶</a><code class="hdoc-function-code language-cpp">bool isAlwaysUniform(const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L356">llvm/include/llvm/Analysis/TargetTransformInfo.h:356</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt></dl><h3 id="5779780134073ABE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5779780134073ABE">¶</a><code class="hdoc-function-code language-cpp">bool isFCmpOrdCheaperThanFCmpZero(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Return true if it is faster to check if a floating-point value is NaN (or not-NaN) versus a comparison against a constant FP zero value. Targets should override this if materializing a 0.0 for comparison is generally as cheap as checking for ordered/unordered.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L744">llvm/include/llvm/Analysis/TargetTransformInfo.h:744</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="99BF237FA602D88F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#99BF237FA602D88F">¶</a><code class="hdoc-function-code language-cpp">bool isFPVectorizationPotentiallyUnsafe() const</code></pre></h3><h4>Description</h4><p>Indicate that it is potentially unsafe to automatically vectorize floating-point operations because the semantics of vector and scalar floating-point semantics may differ. For example, ARM NEON v7 SIMD math does not support IEEE-754 denormal numbers, while depending on the platform, scalar floating-point math does. This applies to floating-point math operations and calls, not memory operations, shuffles, or casts.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L726">llvm/include/llvm/Analysis/TargetTransformInfo.h:726</a></p><h3 id="800E6B299BF5B706"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#800E6B299BF5B706">¶</a><code class="hdoc-function-code language-cpp">bool isHardwareLoopProfitable(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>&amp; SE,
    <a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>&amp; AC,
    <a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>* LibInfo,
    <a href="r65BA53724AAFF367.html">llvm::HardwareLoopInfo</a>&amp; HWLoopInfo) const</code></pre></h3><h4>Description</h4><p>Query the target whether it would be profitable to convert the given loop into a hardware loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L517">llvm/include/llvm/Analysis/TargetTransformInfo.h:517</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>&amp;<b> SE</b></dt><dt class="is-family-code"><a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>&amp;<b> AC</b></dt><dt class="is-family-code"><a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>*<b> LibInfo</b></dt><dt class="is-family-code"><a href="r65BA53724AAFF367.html">llvm::HardwareLoopInfo</a>&amp;<b> HWLoopInfo</b></dt></dl><h3 id="A3B3A8FA027BB25A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A3B3A8FA027BB25A">¶</a><code class="hdoc-function-code language-cpp">bool isIndexedLoadLegal(enum MemIndexedMode Mode,
                        <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1094">llvm/include/llvm/Analysis/TargetTransformInfo.h:1094</a></p><h4>Parameters</h4><dl><dt class="is-family-code">enum MemIndexedMode<b> Mode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h4>Returns</h4><p>True if the specified indexed load for the given type is legal.</p><h3 id="8F0A641F9A319454"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#8F0A641F9A319454">¶</a><code class="hdoc-function-code language-cpp">bool isIndexedStoreLegal(enum MemIndexedMode Mode,
                         <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1097">llvm/include/llvm/Analysis/TargetTransformInfo.h:1097</a></p><h4>Parameters</h4><dl><dt class="is-family-code">enum MemIndexedMode<b> Mode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h4>Returns</h4><p>True if the specified indexed store for the given type is legal.</p><h3 id="9430DC915187169E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9430DC915187169E">¶</a><code class="hdoc-function-code language-cpp">bool isLSRCostLess(
    <a href="rE4F83598F593C79F.html">TargetTransformInfo::LSRCost</a>&amp; C1,
    <a href="rE4F83598F593C79F.html">TargetTransformInfo::LSRCost</a>&amp; C2) const</code></pre></h3><h4>Description</h4><p>Return true if LSR cost of C1 is lower than C1.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L567">llvm/include/llvm/Analysis/TargetTransformInfo.h:567</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE4F83598F593C79F.html">TargetTransformInfo::LSRCost</a>&amp;<b> C1</b></dt><dt class="is-family-code"><a href="rE4F83598F593C79F.html">TargetTransformInfo::LSRCost</a>&amp;<b> C2</b></dt></dl><h3 id="0654A614522B63B7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0654A614522B63B7">¶</a><code class="hdoc-function-code language-cpp">bool isLegalAddImmediate(int64_t Imm) const</code></pre></h3><h4>Description</h4><p>Return true if the specified immediate is legal add immediate, that is the target has add instructions which can add a register with the immediate without having to materialize the immediate into a register.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L547">llvm/include/llvm/Analysis/TargetTransformInfo.h:547</a></p><h4>Parameters</h4><dl><dt class="is-family-code">int64_t<b> Imm</b></dt></dl><h3 id="D59F5996B4D2FD58"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D59F5996B4D2FD58">¶</a><code class="hdoc-function-code language-cpp">bool isLegalAddressingMode(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    <a href="rC19E204A1DC9E834.html">llvm::GlobalValue</a>* BaseGV,
    int64_t BaseOffset,
    bool HasBaseReg,
    int64_t Scale,
    unsigned int AddrSpace = 0,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I = nullptr) const</code></pre></h3><h4>Description</h4><p>Return true if the addressing mode represented by AM is legal for this target, for a load/store of the specified type. The type may be VoidTy, in which case only return true if the addressing mode is legal for a load/store of any legal type. If target returns true in LSRWithInstrQueries(), I may be valid. TODO: Handle pre/postinc as well.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L561">llvm/include/llvm/Analysis/TargetTransformInfo.h:561</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code"><a href="rC19E204A1DC9E834.html">llvm::GlobalValue</a>*<b> BaseGV</b></dt><dt class="is-family-code">int64_t<b> BaseOffset</b></dt><dt class="is-family-code">bool<b> HasBaseReg</b></dt><dt class="is-family-code">int64_t<b> Scale</b></dt><dt class="is-family-code">unsigned int<b> AddrSpace</b> = 0</dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b> = nullptr</dt></dl><h3 id="6950CEAE6E0DC126"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6950CEAE6E0DC126">¶</a><code class="hdoc-function-code language-cpp">bool isLegalICmpImmediate(int64_t Imm) const</code></pre></h3><h4>Description</h4><p>Return true if the specified immediate is legal icmp immediate, that is the target has icmp instructions which can compare a register against the immediate without having to materialize the immediate into a register.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L553">llvm/include/llvm/Analysis/TargetTransformInfo.h:553</a></p><h4>Parameters</h4><dl><dt class="is-family-code">int64_t<b> Imm</b></dt></dl><h3 id="C210957ADC04F8D1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C210957ADC04F8D1">¶</a><code class="hdoc-function-code language-cpp">bool isLegalMaskedCompressStore(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataType) const</code></pre></h3><h4>Description</h4><p>Return true if the target supports masked compress store.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L605">llvm/include/llvm/Analysis/TargetTransformInfo.h:605</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataType</b></dt></dl><h3 id="0CED9F210A921DBD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0CED9F210A921DBD">¶</a><code class="hdoc-function-code language-cpp">bool isLegalMaskedExpandLoad(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataType) const</code></pre></h3><h4>Description</h4><p>Return true if the target supports masked expand load.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L607">llvm/include/llvm/Analysis/TargetTransformInfo.h:607</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataType</b></dt></dl><h3 id="FAE2AE51E6AD2BF2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FAE2AE51E6AD2BF2">¶</a><code class="hdoc-function-code language-cpp">bool isLegalMaskedGather(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataType,
    <a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a> Alignment) const</code></pre></h3><h4>Description</h4><p>Return true if the target supports masked gather.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L602">llvm/include/llvm/Analysis/TargetTransformInfo.h:602</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataType</b></dt><dt class="is-family-code"><a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a><b> Alignment</b></dt></dl><h3 id="750F7A78A5CB8F15"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#750F7A78A5CB8F15">¶</a><code class="hdoc-function-code language-cpp">bool isLegalMaskedLoad(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataType,
    <a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a> Alignment) const</code></pre></h3><h4>Description</h4><p>Return true if the target supports masked load.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L592">llvm/include/llvm/Analysis/TargetTransformInfo.h:592</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataType</b></dt><dt class="is-family-code"><a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a><b> Alignment</b></dt></dl><h3 id="0043FD74D09213A2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0043FD74D09213A2">¶</a><code class="hdoc-function-code language-cpp">bool isLegalMaskedScatter(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataType,
    <a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a> Alignment) const</code></pre></h3><h4>Description</h4><p>Return true if the target supports masked scatter.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L600">llvm/include/llvm/Analysis/TargetTransformInfo.h:600</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataType</b></dt><dt class="is-family-code"><a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a><b> Alignment</b></dt></dl><h3 id="2B0B43DB9F3FAB8B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2B0B43DB9F3FAB8B">¶</a><code class="hdoc-function-code language-cpp">bool isLegalMaskedStore(
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataType,
    <a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a> Alignment) const</code></pre></h3><h4>Description</h4><p>Return true if the target supports masked store.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L590">llvm/include/llvm/Analysis/TargetTransformInfo.h:590</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataType</b></dt><dt class="is-family-code"><a href="rAAA41DF357B863FF.html">llvm::MaybeAlign</a><b> Alignment</b></dt></dl><h3 id="2A4FB81FD2364AC9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2A4FB81FD2364AC9">¶</a><code class="hdoc-function-code language-cpp">bool isLegalNTLoad(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataType,
                   <a href="rC036793DBF3FCD9B.html">llvm::Align</a> Alignment) const</code></pre></h3><h4>Description</h4><p>Return true if the target supports nontemporal load.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L597">llvm/include/llvm/Analysis/TargetTransformInfo.h:597</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataType</b></dt><dt class="is-family-code"><a href="rC036793DBF3FCD9B.html">llvm::Align</a><b> Alignment</b></dt></dl><h3 id="B99A7F7235D8A0F0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B99A7F7235D8A0F0">¶</a><code class="hdoc-function-code language-cpp">bool isLegalNTStore(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* DataType,
                    <a href="rC036793DBF3FCD9B.html">llvm::Align</a> Alignment) const</code></pre></h3><h4>Description</h4><p>Return true if the target supports nontemporal store.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L595">llvm/include/llvm/Analysis/TargetTransformInfo.h:595</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> DataType</b></dt><dt class="is-family-code"><a href="rC036793DBF3FCD9B.html">llvm::Align</a><b> Alignment</b></dt></dl><h3 id="9B6E99CA89AEF21B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9B6E99CA89AEF21B">¶</a><code class="hdoc-function-code language-cpp">bool isLegalToVectorizeLoad(
    <a href="r537857E9FE6D2795.html">llvm::LoadInst</a>* LI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1104">llvm/include/llvm/Analysis/TargetTransformInfo.h:1104</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r537857E9FE6D2795.html">llvm::LoadInst</a>*<b> LI</b></dt></dl><h4>Returns</h4><p>True if the load instruction is legal to vectorize.</p><h3 id="1577B1CAB3900E5E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1577B1CAB3900E5E">¶</a><code class="hdoc-function-code language-cpp">bool isLegalToVectorizeLoadChain(
    unsigned int ChainSizeInBytes,
    unsigned int Alignment,
    unsigned int AddrSpace) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1110">llvm/include/llvm/Analysis/TargetTransformInfo.h:1110</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> ChainSizeInBytes</b></dt><dt class="is-family-code">unsigned int<b> Alignment</b></dt><dt class="is-family-code">unsigned int<b> AddrSpace</b></dt></dl><h4>Returns</h4><p>True if it is legal to vectorize the given load chain.</p><h3 id="BDA308B11F7AB40E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BDA308B11F7AB40E">¶</a><code class="hdoc-function-code language-cpp">bool isLegalToVectorizeStore(
    <a href="r9139824E2B7B4B8F.html">llvm::StoreInst</a>* SI) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1107">llvm/include/llvm/Analysis/TargetTransformInfo.h:1107</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r9139824E2B7B4B8F.html">llvm::StoreInst</a>*<b> SI</b></dt></dl><h4>Returns</h4><p>True if the store instruction is legal to vectorize.</p><h3 id="9380E6CEEA23582E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9380E6CEEA23582E">¶</a><code class="hdoc-function-code language-cpp">bool isLegalToVectorizeStoreChain(
    unsigned int ChainSizeInBytes,
    unsigned int Alignment,
    unsigned int AddrSpace) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1115">llvm/include/llvm/Analysis/TargetTransformInfo.h:1115</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> ChainSizeInBytes</b></dt><dt class="is-family-code">unsigned int<b> Alignment</b></dt><dt class="is-family-code">unsigned int<b> AddrSpace</b></dt></dl><h4>Returns</h4><p>True if it is legal to vectorize the given store chain.</p><h3 id="D6864AAC3F10B498"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D6864AAC3F10B498">¶</a><code class="hdoc-function-code language-cpp">bool isLoweredToCall(
    const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>* F) const</code></pre></h3><h4>Description</h4><p>Test whether calls to a function lower to actual program function calls. The idea is to test whether the program is likely to require a &apos;call&apos; instruction or equivalent in order to call the given function. FIXME: It&apos;s not clear that this is a good or useful query API. Client&apos;s should probably move to simpler cost metrics using the above. Alternatively, we could split the cost interface into distinct code-size and execution-speed costs. This would allow modelling the core of this query more accurately as a call is a single small instruction, but incurs significant execution cost.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L402">llvm/include/llvm/Analysis/TargetTransformInfo.h:402</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>*<b> F</b></dt></dl><h3 id="66CE702F886C1A3A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#66CE702F886C1A3A">¶</a><code class="hdoc-function-code language-cpp">bool isProfitableToHoist(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I) const</code></pre></h3><h4>Description</h4><p>Return true if it is profitable to hoist instruction in the then/else to before if.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L649">llvm/include/llvm/Analysis/TargetTransformInfo.h:649</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt></dl><h3 id="6E0182B3EEE2CBDE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6E0182B3EEE2CBDE">¶</a><code class="hdoc-function-code language-cpp">bool isSourceOfDivergence(
    const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V) const</code></pre></h3><h4>Description</h4><p>Returns whether V is a source of divergence. This function provides the target-dependent information for the target-independent LegacyDivergenceAnalysis. LegacyDivergenceAnalysis first builds the dependency graph, and then runs the reachability algorithm starting with the sources of divergence.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L351">llvm/include/llvm/Analysis/TargetTransformInfo.h:351</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt></dl><h3 id="D2660BF64050480B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D2660BF64050480B">¶</a><code class="hdoc-function-code language-cpp">bool isTruncateFree(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty1,
                    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty2) const</code></pre></h3><h4>Description</h4><p>Return true if it&apos;s free to truncate a value of type Ty1 to type Ty2. e.g. On x86 it&apos;s free to truncate a i32 value in register EAX to i16 by referencing its sub-register AX.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L645">llvm/include/llvm/Analysis/TargetTransformInfo.h:645</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty1</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty2</b></dt></dl><h3 id="59A7D324CF57E12B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#59A7D324CF57E12B">¶</a><code class="hdoc-function-code language-cpp">bool isTypeLegal(<a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty) const</code></pre></h3><h4>Description</h4><p>Return true if this type is legal.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L654">llvm/include/llvm/Analysis/TargetTransformInfo.h:654</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt></dl><h3 id="152714588B7B7312"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#152714588B7B7312">¶</a><code class="hdoc-function-code language-cpp">bool preferPredicateOverEpilogue(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r289205FCE270195C.html">llvm::LoopInfo</a>* LI,
    <a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>&amp; SE,
    <a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>&amp; AC,
    <a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>* TLI,
    <a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>* DT,
    const <a href="r5C691A16B4B13AC5.html">llvm::LoopAccessInfo</a>* LAI) const</code></pre></h3><h4>Description</h4><p>Query the target whether it would be prefered to create a predicated vector loop, which can avoid the need to emit a scalar epilogue loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L524">llvm/include/llvm/Analysis/TargetTransformInfo.h:524</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r289205FCE270195C.html">llvm::LoopInfo</a>*<b> LI</b></dt><dt class="is-family-code"><a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>&amp;<b> SE</b></dt><dt class="is-family-code"><a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>&amp;<b> AC</b></dt><dt class="is-family-code"><a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>*<b> TLI</b></dt><dt class="is-family-code"><a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>*<b> DT</b></dt><dt class="is-family-code">const <a href="r5C691A16B4B13AC5.html">llvm::LoopAccessInfo</a>*<b> LAI</b></dt></dl><h3 id="6ADB716E1DBAE095"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6ADB716E1DBAE095">¶</a><code class="hdoc-function-code language-cpp">bool prefersVectorizedAddressing() const</code></pre></h3><h4>Description</h4><p>Return true if target doesn&apos;t mind addresses in vectors.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L624">llvm/include/llvm/Analysis/TargetTransformInfo.h:624</a></p><h3 id="3946D6E9A07F4BB2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3946D6E9A07F4BB2">¶</a><code class="hdoc-function-code language-cpp">bool rewriteIntrinsicWithAddressSpace(
    <a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>* II,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* OldV,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* NewV) const</code></pre></h3><h4>Description</h4><p>Rewrite intrinsic call \p II such that \p OldV will be replaced with \p NewV, which has a different address space. This should happen for every operand index that collectFlatAddressOperands returned for the intrinsic.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L387">llvm/include/llvm/Analysis/TargetTransformInfo.h:387</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>*<b> II</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> OldV</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> NewV</b></dt></dl><h4>Returns</h4><p>true if the intrinsic /// was handled.</p><h3 id="FC9C9AB1607B3C38"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FC9C9AB1607B3C38">¶</a><code class="hdoc-function-code language-cpp">bool shouldBuildLookupTables() const</code></pre></h3><h4>Description</h4><p>Return true if switches should be turned into lookup tables for the target.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L658">llvm/include/llvm/Analysis/TargetTransformInfo.h:658</a></p><h3 id="7737D117EC575AF4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7737D117EC575AF4">¶</a><code class="hdoc-function-code language-cpp">bool shouldBuildLookupTablesForConstant(
    <a href="r0CE2309DD94A32FA.html">llvm::Constant</a>* C) const</code></pre></h3><h4>Description</h4><p>Return true if switches should be turned into lookup tables containing this constant value for the target.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L662">llvm/include/llvm/Analysis/TargetTransformInfo.h:662</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r0CE2309DD94A32FA.html">llvm::Constant</a>*<b> C</b></dt></dl><h3 id="AAAF4C1EA3B43543"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AAAF4C1EA3B43543">¶</a><code class="hdoc-function-code language-cpp">bool shouldConsiderAddressTypePromotion(
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>&amp; I,
    bool&amp; AllowPromotionWithoutCommonHeader) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L843">llvm/include/llvm/Analysis/TargetTransformInfo.h:843</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>&amp;<b> I</b></dt><dt class="is-family-code">bool&amp;<b> AllowPromotionWithoutCommonHeader</b></dt></dl><h4>Returns</h4><p>True if it should be considered for address type promotion.\p AllowPromotionWithoutCommonHeader Set true if promoting \p I is profitable without finding other extensions fed by the same input.</p><h3 id="527B858A4ECD93E0"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#527B858A4ECD93E0">¶</a><code class="hdoc-function-code language-cpp">bool shouldExpandReduction(
    const <a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>* II) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1146">llvm/include/llvm/Analysis/TargetTransformInfo.h:1146</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r4D5D8AFED2D433D2.html">llvm::IntrinsicInst</a>*<b> II</b></dt></dl><h4>Returns</h4><p>True if the target wants to expand the given reduction intrinsic into a shuffle sequence.</p><h3 id="292E6B7122CF9F33"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#292E6B7122CF9F33">¶</a><code class="hdoc-function-code language-cpp">bool shouldFavorBackedgeIndex(
    const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L) const</code></pre></h3><h4>Description</h4><p>Return true if LSR should make efforts to generate indexed addressing modes that operate across loop iterations.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L587">llvm/include/llvm/Analysis/TargetTransformInfo.h:587</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt></dl><h3 id="84B02FD1957FB63D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#84B02FD1957FB63D">¶</a><code class="hdoc-function-code language-cpp">bool shouldFavorPostInc() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L583">llvm/include/llvm/Analysis/TargetTransformInfo.h:583</a></p><h4>Returns</h4><p>True is LSR should make efforts to create/preserve post-inc addressing mode expressions.</p><h3 id="10D85438A1CF4BD5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#10D85438A1CF4BD5">¶</a><code class="hdoc-function-code language-cpp">bool shouldMaximizeVectorBandwidth(
    bool OptSize) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L833">llvm/include/llvm/Analysis/TargetTransformInfo.h:833</a></p><h4>Parameters</h4><dl><dt class="is-family-code">bool<b> OptSize</b></dt></dl><h4>Returns</h4><p>True if the vectorization factor should be chosen to make the vector of the smallest element type match the size of a vector register. For wider element types, this could result in creating vectors that span multiple vector registers. If false, the vectorization factor will be chosen based on the size of the widest element type.</p><h3 id="4BF608B70FA54DA1"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4BF608B70FA54DA1">¶</a><code class="hdoc-function-code language-cpp">bool supportsEfficientVectorElementLoadStore()
    const</code></pre></h3><h4>Description</h4><p>If target has efficient vector element load/store instructions, it can return true here so that insertion/extraction costs are not added to the scalarization cost of a load/store.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L676">llvm/include/llvm/Analysis/TargetTransformInfo.h:676</a></p><h3 id="25F28670075C18AE"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#25F28670075C18AE">¶</a><code class="hdoc-function-code language-cpp">bool useAA() const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L651">llvm/include/llvm/Analysis/TargetTransformInfo.h:651</a></p><h3 id="3DA4859DFBC79790"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3DA4859DFBC79790">¶</a><code class="hdoc-function-code language-cpp">bool useColdCCForColdCall(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F) const</code></pre></h3><h4>Description</h4><p>Return true if the input function which is cold at all call sites, should use coldcc calling convention.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L666">llvm/include/llvm/Analysis/TargetTransformInfo.h:666</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt></dl><h3 id="B5353241DDDD768A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B5353241DDDD768A">¶</a><code class="hdoc-function-code language-cpp">bool useReductionIntrinsic(
    unsigned int Opcode,
    <a href="r4C0FBD0A3419362A.html">llvm::Type</a>* Ty,
    <a href="rAB17845BF86B0D61.html">llvm::TargetTransformInfo::ReductionFlags</a>
        Flags) const</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L1141">llvm/include/llvm/Analysis/TargetTransformInfo.h:1141</a></p><h4>Parameters</h4><dl><dt class="is-family-code">unsigned int<b> Opcode</b></dt><dt class="is-family-code"><a href="r4C0FBD0A3419362A.html">llvm::Type</a>*<b> Ty</b></dt><dt class="is-family-code"><a href="rAB17845BF86B0D61.html">llvm::TargetTransformInfo::ReductionFlags</a><b> Flags</b></dt></dl><h4>Returns</h4><p>True if the target wants to handle the given reduction idiom in the intrinsics form instead of the shuffle form.</p><h3 id="B7958F2C1D035EE2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B7958F2C1D035EE2">¶</a><code class="hdoc-function-code language-cpp">~TargetTransformInfo()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/TargetTransformInfo.h#L133">llvm/include/llvm/Analysis/TargetTransformInfo.h:133</a></p></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>