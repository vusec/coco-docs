<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class LazyCallGraph: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="page032268D0BE579A12"><span>class LazyCallGraph</span></a></li></ul></nav><main class="content"><h1>class LazyCallGraph</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class LazyCallGraph { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>A lazily constructed view of the call graph of a module. With the edges of this graph, the motivating constraint that we are attempting to maintain is that function-local optimization, CGSCC-local optimizations, and optimizations transforming a pair of functions connected by an edge in the graph, do not invalidate a bottom-up traversal of the SCC DAG. That is, no optimizations will delete, remove, or add an edge such that functions already visited in a bottom-up order of the SCC DAG are no longer valid to have visited, or such that functions not yet visited in a bottom-up order of the SCC DAG are not required to have already been visited. Within this constraint, the desire is to minimize the merge points of the SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points in the SCC DAG, the more independence there is in optimizing within it. There is a strong desire to enable parallelization of optimizations over the call graph, and both limited fanout and merge points will (artificially in some cases) limit the scaling of such an effort. To this end, graph represents both direct and any potential resolution to an indirect call edge. Another way to think about it is that it represents both the direct call edges and any direct call edges that might be formed through static optimizations. Specifically, it considers taking the address of a function to be an edge in the call graph because this might be forwarded to become a direct call by some subsequent function-local optimization. The result is that the graph closely follows the use-def edges for functions. Walking &quot;up&quot; the graph can be done by looking at all of the uses of a function. The roots of the call graph are the external functions and functions escaped into global variables. Those functions can be called from outside of the module or via unknowable means in the IR -- we may not be able to form even a potential call edge from a function body which may dynamically load the function and call it. This analysis still requires updates to remain valid after optimizations which could potentially change the set of potential callees. The constraints it operates under only make the traversal order remain valid. The entire analysis must be re-computed if full interprocedural optimizations run at any point. For example, globalopt completely invalidates the information in this analysis. FIXME: This class is named LazyCallGraph in a lame attempt to distinguish it from the existing CallGraph. At some point, it is expected that this will be the only call graph and it will be renamed accordingly.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L112">llvm/include/llvm/Analysis/LazyCallGraph.h:112</a></p><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#6CDDFD6A8867CA59"><b>LazyCallGraph</b></a>(llvm::LazyCallGraph &amp;&amp; G)</li><li class="is-family-code">public  <a href="#C97722DC60984B3A"><b>LazyCallGraph</b></a>(llvm::Module &amp; M, function_ref&lt;llvm::TargetLibraryInfo &amp;(llvm::Function &amp;)&gt; GetTLI)</li><li class="is-family-code">public EdgeSequence::iterator  <a href="#3E1FE1BD3475A14A"><b>begin</b></a>()</li><li class="is-family-code">public void  <a href="#A35B3B0B51AB583F"><b>buildRefSCCs</b></a>()</li><li class="is-family-code">public EdgeSequence::iterator  <a href="#6638DDEE451C1D6A"><b>end</b></a>()</li><li class="is-family-code">public llvm::LazyCallGraph::Node &amp;  <a href="#9F5A9E975A15B84B"><b>get</b></a>(llvm::Function &amp; F)</li><li class="is-family-code">public ArrayRef&lt;llvm::Function *&gt;  <a href="#6667A98EBB3E17F7"><b>getLibFunctions</b></a>() const</li><li class="is-family-code">public void  <a href="#FBEBBC0C26F8F808"><b>insertEdge</b></a>(llvm::Function &amp; Source, llvm::Function &amp; Target, Edge::Kind EK)</li><li class="is-family-code">public void  <a href="#E0FB1DC94FC3BC6B"><b>insertEdge</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN, Edge::Kind EK)</li><li class="is-family-code">public bool  <a href="#0080EB50A67840DC"><b>isLibFunction</b></a>(llvm::Function &amp; F) const</li><li class="is-family-code">public llvm::LazyCallGraph::Node *  <a href="#134E99AF3E57DE85"><b>lookup</b></a>(const llvm::Function &amp; F) const</li><li class="is-family-code">public llvm::LazyCallGraph::RefSCC *  <a href="#A21A67F1BC2F2EA2"><b>lookupRefSCC</b></a>(llvm::LazyCallGraph::Node &amp; N) const</li><li class="is-family-code">public llvm::LazyCallGraph::SCC *  <a href="#51A5C16B557F26F2"><b>lookupSCC</b></a>(llvm::LazyCallGraph::Node &amp; N) const</li><li class="is-family-code">public llvm::LazyCallGraph::postorder_ref_scc_iterator  <a href="#A79A3CB910198DB3"><b>postorder_ref_scc_begin</b></a>()</li><li class="is-family-code">public llvm::LazyCallGraph::postorder_ref_scc_iterator  <a href="#38E972A053A0578C"><b>postorder_ref_scc_end</b></a>()</li><li class="is-family-code">public iterator_range&lt;llvm::LazyCallGraph::postorder_ref_scc_iterator&gt;  <a href="#DC02FF2202150B5F"><b>postorder_ref_sccs</b></a>()</li><li class="is-family-code">public void  <a href="#778723A62F76DDF9"><b>removeDeadFunction</b></a>(llvm::Function &amp; F)</li><li class="is-family-code">public void  <a href="#E181A3E16F814D64"><b>removeEdge</b></a>(llvm::LazyCallGraph::Node &amp; SourceN, llvm::LazyCallGraph::Node &amp; TargetN)</li><li class="is-family-code">public void  <a href="#62E866793DD2E72E"><b>removeEdge</b></a>(llvm::Function &amp; Source, llvm::Function &amp; Target)</li><li class="is-family-code">public template &lt;typename CallbackT&gt;static void  <a href="#897C113D816C16BD"><b>visitReferences</b></a>(SmallVectorImpl&lt;llvm::Constant *&gt; &amp; Worklist, SmallPtrSetImpl&lt;llvm::Constant *&gt; &amp; Visited, CallbackT Callback)</li></ul><h2>Methods</h2><h3 id="6CDDFD6A8867CA59"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6CDDFD6A8867CA59">¶</a><code class="hdoc-function-code language-cpp">LazyCallGraph(<a href="r032268D0BE579A12.html">llvm::LazyCallGraph</a>&amp;&amp; G)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L937">llvm/include/llvm/Analysis/LazyCallGraph.h:937</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r032268D0BE579A12.html">llvm::LazyCallGraph</a>&amp;&amp;<b> G</b></dt></dl><h3 id="C97722DC60984B3A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C97722DC60984B3A">¶</a><code class="hdoc-function-code language-cpp">LazyCallGraph(
    <a href="r1428BC327E1751C3.html">llvm::Module</a>&amp; M,
    function_ref&lt;llvm::TargetLibraryInfo&amp;(
        llvm::Function&amp;)&gt; GetTLI)</code></pre></h3><h4>Description</h4><p>Construct a graph for the given module. This sets up the graph and computes all of the entry points of the graph. No function definitions are scanned until their nodes in the graph are requested during traversal.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L934">llvm/include/llvm/Analysis/LazyCallGraph.h:934</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r1428BC327E1751C3.html">llvm::Module</a>&amp;<b> M</b></dt><dt class="is-family-code">function_ref&lt;llvm::TargetLibraryInfo&amp;(
    llvm::Function&amp;)&gt;<b> GetTLI</b></dt></dl><h3 id="3E1FE1BD3475A14A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3E1FE1BD3475A14A">¶</a><code class="hdoc-function-code language-cpp"><a href="r697B7C56B2F86E65.html">EdgeSequence::iterator</a> begin()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L940">llvm/include/llvm/Analysis/LazyCallGraph.h:940</a></p><h3 id="A35B3B0B51AB583F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A35B3B0B51AB583F">¶</a><code class="hdoc-function-code language-cpp">void buildRefSCCs()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L943">llvm/include/llvm/Analysis/LazyCallGraph.h:943</a></p><h3 id="6638DDEE451C1D6A"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6638DDEE451C1D6A">¶</a><code class="hdoc-function-code language-cpp"><a href="r697B7C56B2F86E65.html">EdgeSequence::iterator</a> end()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L941">llvm/include/llvm/Analysis/LazyCallGraph.h:941</a></p><h3 id="9F5A9E975A15B84B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#9F5A9E975A15B84B">¶</a><code class="hdoc-function-code language-cpp"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; get(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F)</code></pre></h3><h4>Description</h4><p>Get a graph node for a given function, scanning it to populate the graph data as necessary.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L985">llvm/include/llvm/Analysis/LazyCallGraph.h:985</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt></dl><h3 id="6667A98EBB3E17F7"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6667A98EBB3E17F7">¶</a><code class="hdoc-function-code language-cpp"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Function*&gt; getLibFunctions() const</code></pre></h3><h4>Description</h4><p>Get the sequence of known and defined library functions. These functions, because they are known to LLVM, can have calls introduced out of thin air from arbitrary IR.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L997">llvm/include/llvm/Analysis/LazyCallGraph.h:997</a></p><h3 id="FBEBBC0C26F8F808"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FBEBBC0C26F8F808">¶</a><code class="hdoc-function-code language-cpp">void insertEdge(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; Source,
                <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; Target,
                Edge::Kind EK)</code></pre></h3><h4>Description</h4><p>Update the call graph after inserting a new edge.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L1024">llvm/include/llvm/Analysis/LazyCallGraph.h:1024</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> Source</b></dt><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> Target</b></dt><dt class="is-family-code">Edge::Kind<b> EK</b></dt></dl><h3 id="E0FB1DC94FC3BC6B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E0FB1DC94FC3BC6B">¶</a><code class="hdoc-function-code language-cpp">void insertEdge(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN,
    Edge::Kind EK)</code></pre></h3><h4>Description</h4><p>Update the call graph after inserting a new edge.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L1021">llvm/include/llvm/Analysis/LazyCallGraph.h:1021</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt><dt class="is-family-code">Edge::Kind<b> EK</b></dt></dl><h3 id="0080EB50A67840DC"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0080EB50A67840DC">¶</a><code class="hdoc-function-code language-cpp">bool isLibFunction(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F) const</code></pre></h3><h4>Description</h4><p>Test whether a function is a known and defined library function tracked by the call graph. Because these functions are known to LLVM they are specially modeled in the call graph and even when all IR-level references have been removed remain active and reachable.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L1007">llvm/include/llvm/Analysis/LazyCallGraph.h:1007</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt></dl><h3 id="134E99AF3E57DE85"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#134E99AF3E57DE85">¶</a><code class="hdoc-function-code language-cpp"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>* lookup(
    const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F) const</code></pre></h3><h4>Description</h4><p>Lookup a function in the graph which has already been scanned and added.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L964">llvm/include/llvm/Analysis/LazyCallGraph.h:964</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt></dl><h3 id="A21A67F1BC2F2EA2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A21A67F1BC2F2EA2">¶</a><code class="hdoc-function-code language-cpp"><a href="r7A805890ACA79BD5.html">llvm::LazyCallGraph::RefSCC</a>* lookupRefSCC(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; N) const</code></pre></h3><h4>Description</h4><p>Lookup a function&apos;s RefSCC in the graph.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L976">llvm/include/llvm/Analysis/LazyCallGraph.h:976</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> N</b></dt></dl><h4>Returns</h4><p>null if the function hasn&apos;t been assigned a RefSCC via the RefSCC iterator walk.</p><h3 id="51A5C16B557F26F2"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#51A5C16B557F26F2">¶</a><code class="hdoc-function-code language-cpp"><a href="rF98C323CFA756C9F.html">llvm::LazyCallGraph::SCC</a>* lookupSCC(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; N) const</code></pre></h3><h4>Description</h4><p>Lookup a function&apos;s SCC in the graph.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L970">llvm/include/llvm/Analysis/LazyCallGraph.h:970</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> N</b></dt></dl><h4>Returns</h4><p>null if the function hasn&apos;t been assigned an SCC via the RefSCC iterator walk.</p><h3 id="A79A3CB910198DB3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A79A3CB910198DB3">¶</a><code class="hdoc-function-code language-cpp"><a href="r8C148C945D13F504.html">llvm::LazyCallGraph::postorder_ref_scc_iterator</a>
postorder_ref_scc_begin()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L945">llvm/include/llvm/Analysis/LazyCallGraph.h:945</a></p><h3 id="38E972A053A0578C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#38E972A053A0578C">¶</a><code class="hdoc-function-code language-cpp"><a href="r8C148C945D13F504.html">llvm::LazyCallGraph::postorder_ref_scc_iterator</a>
postorder_ref_scc_end()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L951">llvm/include/llvm/Analysis/LazyCallGraph.h:951</a></p><h3 id="DC02FF2202150B5F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DC02FF2202150B5F">¶</a><code class="hdoc-function-code language-cpp"><a href="rB51FEED19D352440.html">iterator_range</a>&lt;llvm::LazyCallGraph::
                   postorder_ref_scc_iterator&gt;
postorder_ref_sccs()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L959">llvm/include/llvm/Analysis/LazyCallGraph.h:959</a></p><h3 id="778723A62F76DDF9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#778723A62F76DDF9">¶</a><code class="hdoc-function-code language-cpp">void removeDeadFunction(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; F)</code></pre></h3><h4>Description</h4><p>Remove a dead function from the call graph (typically to delete it). Note that the function must have an empty use list, and the call graph must be up-to-date prior to calling this. That means it is by itself in a maximal SCC which is by itself in a maximal RefSCC, etc. No structural changes result from calling this routine other than potentially removing entry points into the call graph. If SCC formation has begun, this function must not be part of the current DFS in order to call this safely. Typically, the function will have been fully visited by the DFS prior to calling this routine.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L1056">llvm/include/llvm/Analysis/LazyCallGraph.h:1056</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> F</b></dt></dl><h3 id="E181A3E16F814D64"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E181A3E16F814D64">¶</a><code class="hdoc-function-code language-cpp">void removeEdge(
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; SourceN,
    <a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp; TargetN)</code></pre></h3><h4>Description</h4><p>Update the call graph after deleting an edge.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L1029">llvm/include/llvm/Analysis/LazyCallGraph.h:1029</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> SourceN</b></dt><dt class="is-family-code"><a href="rA0AA8AF1C5CF99AD.html">llvm::LazyCallGraph::Node</a>&amp;<b> TargetN</b></dt></dl><h3 id="62E866793DD2E72E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#62E866793DD2E72E">¶</a><code class="hdoc-function-code language-cpp">void removeEdge(<a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; Source,
                <a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp; Target)</code></pre></h3><h4>Description</h4><p>Update the call graph after deleting an edge.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L1032">llvm/include/llvm/Analysis/LazyCallGraph.h:1032</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> Source</b></dt><dt class="is-family-code"><a href="rADBA2A8E0906EC47.html">llvm::Function</a>&amp;<b> Target</b></dt></dl><h3 id="897C113D816C16BD"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#897C113D816C16BD">¶</a><code class="hdoc-function-code language-cpp">template &lt;typename CallbackT&gt;
static void visitReferences(
    <a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::Constant*&gt;&amp; Worklist,
    <a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;llvm::Constant*&gt;&amp; Visited,
    CallbackT Callback)</code></pre></h3><h4>Description</h4><p>Recursively visits the defined functions whose address is reachable from every constant in the \p Worklist. Doesn&apos;t recurse through any constants already in the \p Visited set, and updates that set with every constant visited. For each defined function, calls \p Callback with that function.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/include/llvm/Analysis/LazyCallGraph.h#L1075">llvm/include/llvm/Analysis/LazyCallGraph.h:1075</a></p><h4>Templates</h4><dl><dt class="is-family-code"><b> CallbackT</b></dt></dl><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r6CBD92E95A65634C.html">SmallVectorImpl</a>&lt;llvm::Constant*&gt;&amp;<b> Worklist</b></dt><dt class="is-family-code"><a href="r5A4001D054664098.html">SmallPtrSetImpl</a>&lt;llvm::Constant*&gt;&amp;<b> Visited</b></dt><dt class="is-family-code">CallbackT<b> Callback</b></dt></dl></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>