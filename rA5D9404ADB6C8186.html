<!DOCTYPE html><html><head><meta charset="utf-8"></meta><meta content="width=device-width, initial-scale=1" name="viewport"></meta><title>class InnerLoopVectorizer: LLVM 10.0.0 documentation</title><link href="styles.css" rel="stylesheet"></link><script src="highlight.min.js"></script><script>hljs.highlightAll();</script><link href="katex.min.css" rel="stylesheet"></link><script src="katex.min.js"></script><script src="auto-render.min.js"></script><script>
    document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false},
        ],
      });
    });
  </script><link href="apple-touch-icon.png" sizes="180x180" rel="apple-touch-icon"></link><link href="favicon-32x32.png" sizes="32x32" type="image/png" rel="icon"></link><link href="favicon-16x16.png" sizes="16x16" type="image/png" rel="icon"></link></head><body><div id="wrapper"><section class="section"><div class="container"><div class="columns"><aside class="column is-one-fifth"><ul class="menu-list"><p class="is-size-4">LLVM 10.0.0</p><p class="menu-label">Navigation</p><li><a href="index.html">Home</a></li><li><a href="search.html">Search</a></li><li><a href="https://github.com/llvm/llvm-project/">Repository</a></li><li><a href="https://hdoc.io">Made with hdoc</a></li><p class="menu-label">API Documentation</p><li><a href="functions.html">Functions</a></li><li><a href="records.html">Records</a></li><li><a href="enums.html">Enums</a></li><li><a href="namespaces.html">Namespaces</a></li></ul></aside><div class="column" style="overflow-x: auto"><nav class="breadcrumb has-arrow-separator" aria-label="breadcrumbs"><ul><li><a href="namespaces.html#00A4DA910CC17C2D"><span>namespace llvm</span></a></li><li class="is-active"><a aria-current="pageA5D9404ADB6C8186"><span>class InnerLoopVectorizer</span></a></li></ul></nav><main class="content"><h1>class InnerLoopVectorizer</h1><h2>Declaration</h2><pre class="p-0"><code class="hdoc-record-code language-cpp">class InnerLoopVectorizer { /* full declaration omitted */ };</code></pre><h2>Description</h2><p>InnerLoopVectorizer vectorizes loops which contain only one basic block to a specified vectorization factor (VF). This class performs the widening of scalars into vectors, or multiple scalars. This class also implements the following features: * It inserts an epilogue loop for handling loops that don&apos;t have iteration counts that are known to be a multiple of the vectorization factor. * It handles the code generation for reduction variables. * Scalarization (implementation using scalars) of un-vectorizable instructions. InnerLoopVectorizer does not perform any vectorization-legality checks, and relies on the caller to check for the different legality aspects. The InnerLoopVectorizer relies on the LoopVectorizationLegality class to provide information about the induction and reduction variables that were found to a given vectorization factor.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L398">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:398</a></p><h2>Member Variables</h2><dl><dt class="is-family-code" id="var_OrigLoop">protected  <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* <b>OrigLoop</b></dt><dd>The original loop.</dd><dt class="is-family-code" id="var_PSE">protected  <a href="rB18B275B6D5D599D.html">llvm::PredicatedScalarEvolution</a>&amp; <b>PSE</b></dt><dd>A wrapper around ScalarEvolution used to add runtime SCEV checks. Applies dynamic knowledge to simplify SCEV expressions and converts them to a more usable form.</dd><dt class="is-family-code" id="var_LI">protected  <a href="r289205FCE270195C.html">llvm::LoopInfo</a>* <b>LI</b></dt><dd>Loop Info.</dd><dt class="is-family-code" id="var_DT">protected  <a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>* <b>DT</b></dt><dd>Dominator Tree.</dd><dt class="is-family-code" id="var_AA">protected  <a href="rCA1ED98E6FDF5F7E.html">llvm::AliasAnalysis</a>* <b>AA</b></dt><dd>Alias Analysis.</dd><dt class="is-family-code" id="var_TLI">protected  const <a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>* <b>TLI</b></dt><dd>Target Library Info.</dd><dt class="is-family-code" id="var_TTI">protected  const <a href="r76DB21423DDE140B.html">llvm::TargetTransformInfo</a>* <b>TTI</b></dt><dd>Target Transform Info.</dd><dt class="is-family-code" id="var_AC">protected  <a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>* <b>AC</b></dt><dd>Assumption Cache.</dd><dt class="is-family-code" id="var_ORE">protected  <a href="r30BFE297D838EDE4.html">llvm::OptimizationRemarkEmitter</a>* <b>ORE</b></dt><dd>Interface to emit optimization remarks.</dd><dt class="is-family-code" id="var_LVer">protected  <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr">std::unique_ptr</a>&lt;LoopVersioning&gt; <b>LVer</b></dt><dd>This is currently only used to add no-alias metadata based on the memchecks.  The actually versioning is performed manually.</dd><dt class="is-family-code" id="var_VF">protected  unsigned int <b>VF</b></dt><dd>The vectorization SIMD factor to use. Each vector will have this many vector elements.</dd><dt class="is-family-code" id="var_UF">protected  unsigned int <b>UF</b></dt><dd>The vectorization unroll factor to use. Each scalar is vectorized to this many different vector instructions.</dd><dt class="is-family-code" id="var_Builder">protected  <a href="rB252D65A795AFC3C.html">IRBuilder</a>&lt;&gt; <b>Builder</b></dt><dd>The builder that we use</dd><dt class="is-family-code" id="var_LoopVectorPreHeader">protected  <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* <b>LoopVectorPreHeader</b></dt><dd>The vector-loop preheader.</dd><dt class="is-family-code" id="var_LoopScalarPreHeader">protected  <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* <b>LoopScalarPreHeader</b></dt><dd>The scalar-loop preheader.</dd><dt class="is-family-code" id="var_LoopMiddleBlock">protected  <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* <b>LoopMiddleBlock</b></dt><dd>Middle Block between the vector and the scalar.</dd><dt class="is-family-code" id="var_LoopExitBlock">protected  <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* <b>LoopExitBlock</b></dt><dd>The ExitBlock of the scalar loop.</dd><dt class="is-family-code" id="var_LoopVectorBody">protected  <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* <b>LoopVectorBody</b></dt><dd>The vector loop body.</dd><dt class="is-family-code" id="var_LoopScalarBody">protected  <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* <b>LoopScalarBody</b></dt><dd>The scalar loop body.</dd><dt class="is-family-code" id="var_LoopBypassBlocks">protected  <a href="r62CD0592E97953B6.html">SmallVector</a>&lt;llvm::BasicBlock*, 4&gt; <b>LoopBypassBlocks</b></dt><dd>A list of all bypass blocks. The first block is the entry of the loop.</dd><dt class="is-family-code" id="var_Induction">protected  <a href="r33A490E798BA8C33.html">llvm::PHINode</a>* <b>Induction</b> = nullptr</dt><dd>The new Induction variable which was added to the new block.</dd><dt class="is-family-code" id="var_OldInduction">protected  <a href="r33A490E798BA8C33.html">llvm::PHINode</a>* <b>OldInduction</b> = nullptr</dt><dd>The induction variable of the old basic block.</dd><dt class="is-family-code" id="var_VectorLoopValueMap">protected  <a href="rD5BBB72A7DF912DE.html">llvm::VectorizerValueMap</a> <b>VectorLoopValueMap</b></dt><dd>Maps values from the original loop to their corresponding values in the vectorized loop. A key value can map to either vector values, scalar values or both kinds of values, depending on whether the key was vectorized and scalarized.</dd><dt class="is-family-code" id="var_PredicatedInstructions">protected  <a href="r62CD0592E97953B6.html">SmallVector</a>&lt;llvm::Instruction*, 4&gt; <b>PredicatedInstructions</b></dt><dd>Store instructions that were predicated.</dd><dt class="is-family-code" id="var_TripCount">protected  <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* <b>TripCount</b> = nullptr</dt><dd>Trip count of the original loop.</dd><dt class="is-family-code" id="var_VectorTripCount">protected  <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* <b>VectorTripCount</b> = nullptr</dt><dd>Trip count of the widened loop (TripCount - TripCount % (VF*UF))</dd><dt class="is-family-code" id="var_Legal">protected  <a href="r34A790BE0D292910.html">llvm::LoopVectorizationLegality</a>* <b>Legal</b></dt><dd>The legality analysis.</dd><dt class="is-family-code" id="var_Cost">protected  <a href="rD478F0D4DBC4BB42.html">llvm::LoopVectorizationCostModel</a>* <b>Cost</b></dt><dd>The profitablity analysis.</dd><dt class="is-family-code" id="var_AddedSafetyChecks">protected  bool <b>AddedSafetyChecks</b> = false</dt><dt class="is-family-code" id="var_IVEndValues">protected  <a href="rC2880C7E8E458B54.html">DenseMap</a>&lt;llvm::PHINode*, llvm::Value*&gt; <b>IVEndValues</b></dt><dt class="is-family-code" id="var_OrigPHIsToFix">protected  <a href="r62CD0592E97953B6.html">SmallVector</a>&lt;llvm::PHINode*, 8&gt; <b>OrigPHIsToFix</b></dt></dl><h2>Method Overview</h2><ul><li class="is-family-code">public  <a href="#6A2F203C807D8390"><b>InnerLoopVectorizer</b></a>(llvm::Loop * OrigLoop, llvm::PredicatedScalarEvolution &amp; PSE, llvm::LoopInfo * LI, llvm::DominatorTree * DT, const llvm::TargetLibraryInfo * TLI, const llvm::TargetTransformInfo * TTI, llvm::AssumptionCache * AC, llvm::OptimizationRemarkEmitter * ORE, unsigned int VecWidth, unsigned int UnrollFactor, llvm::LoopVectorizationLegality * LVL, llvm::LoopVectorizationCostModel * CM)</li><li class="is-family-code">protected void  <a href="#7C5DD98D1B809D75"><b>addMetadata</b></a>(ArrayRef&lt;llvm::Value *&gt; To, llvm::Instruction * From)</li><li class="is-family-code">protected void  <a href="#4082467DE1DF8DF5"><b>addMetadata</b></a>(llvm::Instruction * To, llvm::Instruction * From)</li><li class="is-family-code">protected void  <a href="#7C8939B4DD2C770B"><b>addNewMetadata</b></a>(llvm::Instruction * To, const llvm::Instruction * Orig)</li><li class="is-family-code">public bool  <a href="#E3C9997B18088D72"><b>areSafetyChecksAdded</b></a>()</li><li class="is-family-code">protected void  <a href="#DAAEBC7F29752EB4"><b>buildScalarSteps</b></a>(llvm::Value * ScalarIV, llvm::Value * Step, llvm::Instruction * EntryVal, const llvm::InductionDescriptor &amp; ID)</li><li class="is-family-code">protected void  <a href="#631C54D46979353F"><b>clearReductionWrapFlags</b></a>(llvm::RecurrenceDescriptor &amp; RdxDesc)</li><li class="is-family-code">protected llvm::Value *  <a href="#C7D66FE08CA78423"><b>createBitOrPointerCast</b></a>(llvm::Value * V, llvm::VectorType * DstVTy, const llvm::DataLayout &amp; DL)</li><li class="is-family-code">protected llvm::PHINode *  <a href="#96B4CCF23363B749"><b>createInductionVariable</b></a>(llvm::Loop * L, llvm::Value * Start, llvm::Value * End, llvm::Value * Step, llvm::Instruction * DL)</li><li class="is-family-code">protected void  <a href="#35561EBD58207084"><b>createVectorIntOrFpInductionPHI</b></a>(const llvm::InductionDescriptor &amp; II, llvm::Value * Step, llvm::Instruction * EntryVal)</li><li class="is-family-code">public llvm::BasicBlock *  <a href="#40B61E566B5DF872"><b>createVectorizedLoopSkeleton</b></a>()</li><li class="is-family-code">protected void  <a href="#1BBDA1107D5B62CB"><b>emitMemRuntimeChecks</b></a>(llvm::Loop * L, llvm::BasicBlock * Bypass)</li><li class="is-family-code">protected void  <a href="#F13D9821A611565E"><b>emitMinimumIterationCountCheck</b></a>(llvm::Loop * L, llvm::BasicBlock * Bypass)</li><li class="is-family-code">protected void  <a href="#AD3D3C2371A7353C"><b>emitSCEVChecks</b></a>(llvm::Loop * L, llvm::BasicBlock * Bypass)</li><li class="is-family-code">protected llvm::Value *  <a href="#75C55964C75BD2A3"><b>emitTransformedIndex</b></a>(IRBuilder&lt;&gt; &amp; B, llvm::Value * Index, llvm::ScalarEvolution * SE, const llvm::DataLayout &amp; DL, const llvm::InductionDescriptor &amp; ID) const</li><li class="is-family-code">protected void  <a href="#95F7446BE07F29FC"><b>fixCrossIterationPHIs</b></a>()</li><li class="is-family-code">protected void  <a href="#26718C546B3DB602"><b>fixFirstOrderRecurrence</b></a>(llvm::PHINode * Phi)</li><li class="is-family-code">protected void  <a href="#5DFBA44E6042C7EC"><b>fixLCSSAPHIs</b></a>()</li><li class="is-family-code">public void  <a href="#7BABD36C01344F8C"><b>fixNonInductionPHIs</b></a>()</li><li class="is-family-code">protected void  <a href="#E00A902F5CAEB896"><b>fixReduction</b></a>(llvm::PHINode * Phi)</li><li class="is-family-code">public void  <a href="#96AA5C0553295D4D"><b>fixVectorizedLoop</b></a>()</li><li class="is-family-code">protected void  <a href="#D853EA1630922974"><b>fixupIVUsers</b></a>(llvm::PHINode * OrigPhi, const llvm::InductionDescriptor &amp; II, llvm::Value * CountRoundDown, llvm::Value * EndValue, llvm::BasicBlock * MiddleBlock)</li><li class="is-family-code">protected virtual llvm::Value *  <a href="#54BAB49D3423C093"><b>getBroadcastInstrs</b></a>(llvm::Value * V)</li><li class="is-family-code">public llvm::Value *  <a href="#2CC8D151A0E6FD14"><b>getOrCreateScalarValue</b></a>(llvm::Value * V, const llvm::VPIteration &amp; Instance)</li><li class="is-family-code">protected llvm::Value *  <a href="#31CEAE776B6917C6"><b>getOrCreateTripCount</b></a>(llvm::Loop * NewLoop)</li><li class="is-family-code">protected llvm::Value *  <a href="#3794D41A2C64A34F"><b>getOrCreateVectorTripCount</b></a>(llvm::Loop * NewLoop)</li><li class="is-family-code">public llvm::Value *  <a href="#EE55480020C6E736"><b>getOrCreateVectorValue</b></a>(llvm::Value * V, unsigned int Part)</li><li class="is-family-code">protected virtual llvm::Value *  <a href="#A3CC810EBE7C9D0D"><b>getStepVector</b></a>(llvm::Value * Val, int StartIdx, llvm::Value * Step, Instruction::BinaryOps Opcode = Instruction::BinaryOpsEnd)</li><li class="is-family-code">protected bool  <a href="#05AFAA89292D5804"><b>needsScalarInduction</b></a>(llvm::Instruction * IV) const</li><li class="is-family-code">public void  <a href="#F0E416D5ABA50556"><b>packScalarIntoVectorValue</b></a>(llvm::Value * V, const llvm::VPIteration &amp; Instance)</li><li class="is-family-code">protected void  <a href="#7BCF1B7F79E10226"><b>recordVectorLoopValueForInductionCast</b></a>(const llvm::InductionDescriptor &amp; ID, const llvm::Instruction * EntryVal, llvm::Value * VectorLoopValue, unsigned int Part, unsigned int Lane = (2147483647 * 2U + 1U))</li><li class="is-family-code">protected virtual llvm::Value *  <a href="#120E95871BE01989"><b>reverseVector</b></a>(llvm::Value * Vec)</li><li class="is-family-code">public void  <a href="#2A1686508270BAD4"><b>scalarizeInstruction</b></a>(llvm::Instruction * Instr, const llvm::VPIteration &amp; Instance, bool IfPredicateInstr)</li><li class="is-family-code">public void  <a href="#FE709CC171570F2B"><b>setDebugLocFromInst</b></a>(IRBuilder&lt;&gt; &amp; B, const llvm::Value * Ptr)</li><li class="is-family-code">protected bool  <a href="#B6BEC39BCC15F35E"><b>shouldScalarizeInstruction</b></a>(llvm::Instruction * I) const</li><li class="is-family-code">protected void  <a href="#500FBC3A2995AE67"><b>sinkScalarOperands</b></a>(llvm::Instruction * PredInst)</li><li class="is-family-code">protected void  <a href="#685FA03A3E1A7898"><b>truncateToMinimalBitwidths</b></a>()</li><li class="is-family-code">public void  <a href="#DD017F28F7D53C5D"><b>vectorizeInterleaveGroup</b></a>(llvm::Instruction * Instr, llvm::VPTransformState &amp; State, llvm::VPValue * Addr, llvm::VPValue * BlockInMask = nullptr)</li><li class="is-family-code">public void  <a href="#BEE268F0266A93C9"><b>vectorizeMemoryInstruction</b></a>(llvm::Instruction * Instr, llvm::VPTransformState &amp; State, llvm::VPValue * Addr, llvm::VPValue * BlockInMask = nullptr)</li><li class="is-family-code">public void  <a href="#195B10269C6B3712"><b>widenGEP</b></a>(llvm::GetElementPtrInst * GEP, unsigned int UF, unsigned int VF, bool IsPtrLoopInvariant, llvm::SmallBitVector &amp; IsIndexLoopInvariant)</li><li class="is-family-code">public void  <a href="#26DDDFA127A09AB4"><b>widenInstruction</b></a>(llvm::Instruction &amp; I)</li><li class="is-family-code">public void  <a href="#00D8000152703282"><b>widenIntOrFpInduction</b></a>(llvm::PHINode * IV, llvm::TruncInst * Trunc = nullptr)</li><li class="is-family-code">public void  <a href="#D2030BB5C3C7B0F6"><b>widenPHIInstruction</b></a>(llvm::Instruction * PN, unsigned int UF, unsigned int VF)</li><li class="is-family-code">public virtual  <a href="#0A65B5A9F2A00109"><b>~InnerLoopVectorizer</b></a>()</li></ul><h2>Methods</h2><h3 id="6A2F203C807D8390"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#6A2F203C807D8390">¶</a><code class="hdoc-function-code language-cpp">InnerLoopVectorizer(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* OrigLoop,
    <a href="rB18B275B6D5D599D.html">llvm::PredicatedScalarEvolution</a>&amp; PSE,
    <a href="r289205FCE270195C.html">llvm::LoopInfo</a>* LI,
    <a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>* DT,
    const <a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>* TLI,
    const <a href="r76DB21423DDE140B.html">llvm::TargetTransformInfo</a>* TTI,
    <a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>* AC,
    <a href="r30BFE297D838EDE4.html">llvm::OptimizationRemarkEmitter</a>* ORE,
    unsigned int VecWidth,
    unsigned int UnrollFactor,
    <a href="r34A790BE0D292910.html">llvm::LoopVectorizationLegality</a>* LVL,
    <a href="rD478F0D4DBC4BB42.html">llvm::LoopVectorizationCostModel</a>* CM)</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L400">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:400</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> OrigLoop</b></dt><dt class="is-family-code"><a href="rB18B275B6D5D599D.html">llvm::PredicatedScalarEvolution</a>&amp;<b> PSE</b></dt><dt class="is-family-code"><a href="r289205FCE270195C.html">llvm::LoopInfo</a>*<b> LI</b></dt><dt class="is-family-code"><a href="r597D5CB55B73E338.html">llvm::DominatorTree</a>*<b> DT</b></dt><dt class="is-family-code">const <a href="r8801A6B76136C2E2.html">llvm::TargetLibraryInfo</a>*<b> TLI</b></dt><dt class="is-family-code">const <a href="r76DB21423DDE140B.html">llvm::TargetTransformInfo</a>*<b> TTI</b></dt><dt class="is-family-code"><a href="r53E6B995390ACBF6.html">llvm::AssumptionCache</a>*<b> AC</b></dt><dt class="is-family-code"><a href="r30BFE297D838EDE4.html">llvm::OptimizationRemarkEmitter</a>*<b> ORE</b></dt><dt class="is-family-code">unsigned int<b> VecWidth</b></dt><dt class="is-family-code">unsigned int<b> UnrollFactor</b></dt><dt class="is-family-code"><a href="r34A790BE0D292910.html">llvm::LoopVectorizationLegality</a>*<b> LVL</b></dt><dt class="is-family-code"><a href="rD478F0D4DBC4BB42.html">llvm::LoopVectorizationCostModel</a>*<b> CM</b></dt></dl><h3 id="7C5DD98D1B809D75"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7C5DD98D1B809D75">¶</a><code class="hdoc-function-code language-cpp">void addMetadata(<a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Value*&gt; To,
                 <a href="rE266D8602316BABC.html">llvm::Instruction</a>* From)</code></pre></h3><h4>Description</h4><p>Similar to the previous function but it adds the metadata to a vector of instructions.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L668">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:668</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r88137505AF2B6C74.html">ArrayRef</a>&lt;llvm::Value*&gt;<b> To</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> From</b></dt></dl><h3 id="4082467DE1DF8DF5"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#4082467DE1DF8DF5">¶</a><code class="hdoc-function-code language-cpp">void addMetadata(<a href="rE266D8602316BABC.html">llvm::Instruction</a>* To,
                 <a href="rE266D8602316BABC.html">llvm::Instruction</a>* From)</code></pre></h3><h4>Description</h4><p>Add metadata from one instruction to another. This includes both the original MDs from \p From and additional ones (</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L664">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:664</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> To</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> From</b></dt></dl><h3 id="7C8939B4DD2C770B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7C8939B4DD2C770B">¶</a><code class="hdoc-function-code language-cpp">void addNewMetadata(<a href="rE266D8602316BABC.html">llvm::Instruction</a>* To,
                    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* Orig)</code></pre></h3><h4>Description</h4><p>Add additional metadata to \p To that was not present on \p Orig. Currently this is used to add the noalias annotations based on the inserted memchecks.  Use this for instructions that are *cloned* into the vector loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L657">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:657</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> To</b></dt><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> Orig</b></dt></dl><h3 id="E3C9997B18088D72"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E3C9997B18088D72">¶</a><code class="hdoc-function-code language-cpp">bool areSafetyChecksAdded()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L424">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:424</a></p><h3 id="DAAEBC7F29752EB4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DAAEBC7F29752EB4">¶</a><code class="hdoc-function-code language-cpp">void buildScalarSteps(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* ScalarIV,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Step,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* EntryVal,
    const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp; ID)</code></pre></h3><h4>Description</h4><p>Compute scalar induction steps. \p ScalarIV is the scalar induction variable on which to base the steps, \p Step is the size of the step, and\p EntryVal is the value from the original loop that maps to the steps. Note that \p EntryVal doesn&apos;t have to be an induction variable - it can also be a truncate instruction.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L575">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:575</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> ScalarIV</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Step</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> EntryVal</b></dt><dt class="is-family-code">const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp;<b> ID</b></dt></dl><h3 id="631C54D46979353F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#631C54D46979353F">¶</a><code class="hdoc-function-code language-cpp">void clearReductionWrapFlags(
    <a href="rD86CE1DD4C44E9C4.html">llvm::RecurrenceDescriptor</a>&amp; RdxDesc)</code></pre></h3><h4>Description</h4><p>Clear NSW/NUW flags from reduction instructions if necessary.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L540">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:540</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rD86CE1DD4C44E9C4.html">llvm::RecurrenceDescriptor</a>&amp;<b> RdxDesc</b></dt></dl><h3 id="C7D66FE08CA78423"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#C7D66FE08CA78423">¶</a><code class="hdoc-function-code language-cpp"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>* createBitOrPointerCast(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V,
    <a href="rBA702C5D0CD7CD0E.html">llvm::VectorType</a>* DstVTy,
    const <a href="r36886900CAFBFB15.html">llvm::DataLayout</a>&amp; DL)</code></pre></h3><h4>Description</h4><p>Returns a bitcasted value to the requested vector type. Also handles bitcasts of vector &lt;float &gt;  &lt; -&gt; vector &lt;pointer &gt; types.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L628">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:628</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt><dt class="is-family-code"><a href="rBA702C5D0CD7CD0E.html">llvm::VectorType</a>*<b> DstVTy</b></dt><dt class="is-family-code">const <a href="r36886900CAFBFB15.html">llvm::DataLayout</a>&amp;<b> DL</b></dt></dl><h3 id="96B4CCF23363B749"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#96B4CCF23363B749">¶</a><code class="hdoc-function-code language-cpp"><a href="r33A490E798BA8C33.html">llvm::PHINode</a>* createInductionVariable(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Start,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* End,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Step,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* DL)</code></pre></h3><h4>Description</h4><p>Create a new induction variable inside L.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L525">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:525</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Start</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> End</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Step</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> DL</b></dt></dl><h3 id="35561EBD58207084"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#35561EBD58207084">¶</a><code class="hdoc-function-code language-cpp">void createVectorIntOrFpInductionPHI(
    const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp; II,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Step,
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* EntryVal)</code></pre></h3><h4>Description</h4><p>Create a vector induction phi node based on an existing scalar one. \p EntryVal is the value from the original loop that maps to the vector phi node, and \p Step is the loop-invariant step. If \p EntryVal is a truncate instruction, instead of widening the original IV, we widen a version of the IV truncated to \p EntryVal&apos;s type.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L583">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:583</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp;<b> II</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Step</b></dt><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> EntryVal</b></dt></dl><h3 id="40B61E566B5DF872"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#40B61E566B5DF872">¶</a><code class="hdoc-function-code language-cpp"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* createVectorizedLoopSkeleton()</code></pre></h3><h4>Description</h4><p>Create a new empty loop. Unlink the old loop and connect the new one. Return the pre-header block of the new loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L415">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:415</a></p><h3 id="1BBDA1107D5B62CB"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#1BBDA1107D5B62CB">¶</a><code class="hdoc-function-code language-cpp">void emitMemRuntimeChecks(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* Bypass)</code></pre></h3><h4>Description</h4><p>Emit bypass checks to check any memory assumptions we may have made.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L640">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:640</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> Bypass</b></dt></dl><h3 id="F13D9821A611565E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F13D9821A611565E">¶</a><code class="hdoc-function-code language-cpp">void emitMinimumIterationCountCheck(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* Bypass)</code></pre></h3><h4>Description</h4><p>Emit a bypass check to see if the vector trip count is zero, including if it overflows.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L633">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:633</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> Bypass</b></dt></dl><h3 id="AD3D3C2371A7353C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#AD3D3C2371A7353C">¶</a><code class="hdoc-function-code language-cpp">void emitSCEVChecks(<a href="r210AF08D1E341AC3.html">llvm::Loop</a>* L,
                    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* Bypass)</code></pre></h3><h4>Description</h4><p>Emit a bypass check to see if all of the SCEV assumptions we&apos;ve had to make are correct.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L637">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:637</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> L</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> Bypass</b></dt></dl><h3 id="75C55964C75BD2A3"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#75C55964C75BD2A3">¶</a><code class="hdoc-function-code language-cpp"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>* emitTransformedIndex(
    <a href="rB252D65A795AFC3C.html">IRBuilder</a>&lt;&gt;&amp; B,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Index,
    <a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>* SE,
    const <a href="r36886900CAFBFB15.html">llvm::DataLayout</a>&amp; DL,
    const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp; ID) const</code></pre></h3><h4>Description</h4><p>Compute the transformed value of Index at offset StartValue using step StepValue. For integer induction, returns StartValue + Index * StepValue. For pointer induction, returns StartValue[Index * StepValue]. FIXME: The newly created binary instructions should contain nsw/nuw flags, which can be found from the original scalar operations.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L648">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:648</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rB252D65A795AFC3C.html">IRBuilder</a>&lt;&gt;&amp;<b> B</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Index</b></dt><dt class="is-family-code"><a href="r0D901B7ED6429B0A.html">llvm::ScalarEvolution</a>*<b> SE</b></dt><dt class="is-family-code">const <a href="r36886900CAFBFB15.html">llvm::DataLayout</a>&amp;<b> DL</b></dt><dt class="is-family-code">const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp;<b> ID</b></dt></dl><h3 id="95F7446BE07F29FC"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#95F7446BE07F29FC">¶</a><code class="hdoc-function-code language-cpp">void fixCrossIterationPHIs()</code></pre></h3><h4>Description</h4><p>Handle all cross-iteration phis in the header.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L529">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:529</a></p><h3 id="26718C546B3DB602"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#26718C546B3DB602">¶</a><code class="hdoc-function-code language-cpp">void fixFirstOrderRecurrence(<a href="r33A490E798BA8C33.html">llvm::PHINode</a>* Phi)</code></pre></h3><h4>Description</h4><p>Fix a first-order recurrence. This is the second phase of vectorizing this phi node.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L533">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:533</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r33A490E798BA8C33.html">llvm::PHINode</a>*<b> Phi</b></dt></dl><h3 id="5DFBA44E6042C7EC"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#5DFBA44E6042C7EC">¶</a><code class="hdoc-function-code language-cpp">void fixLCSSAPHIs()</code></pre></h3><h4>Description</h4><p>The Loop exit block may have single value PHI nodes with some incoming value. While vectorizing we only handled real values that were defined inside the loop and we should have one value for each predecessor of its parent basic block. See PR14725.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L546">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:546</a></p><h3 id="7BABD36C01344F8C"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7BABD36C01344F8C">¶</a><code class="hdoc-function-code language-cpp">void fixNonInductionPHIs()</code></pre></h3><h4>Description</h4><p>Fix the non-induction PHIs in the OrigPHIsToFix vector.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L505">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:505</a></p><h3 id="E00A902F5CAEB896"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#E00A902F5CAEB896">¶</a><code class="hdoc-function-code language-cpp">void fixReduction(<a href="r33A490E798BA8C33.html">llvm::PHINode</a>* Phi)</code></pre></h3><h4>Description</h4><p>Fix a reduction cross-iteration phi. This is the second phase of vectorizing this phi node.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L537">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:537</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r33A490E798BA8C33.html">llvm::PHINode</a>*<b> Phi</b></dt></dl><h3 id="96AA5C0553295D4D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#96AA5C0553295D4D">¶</a><code class="hdoc-function-code language-cpp">void fixVectorizedLoop()</code></pre></h3><h4>Description</h4><p>Fix the vectorized code, taking care of header phi&apos;s, live-outs, and more.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L421">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:421</a></p><h3 id="D853EA1630922974"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D853EA1630922974">¶</a><code class="hdoc-function-code language-cpp">void fixupIVUsers(
    <a href="r33A490E798BA8C33.html">llvm::PHINode</a>* OrigPhi,
    const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp; II,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* CountRoundDown,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* EndValue,
    <a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>* MiddleBlock)</code></pre></h3><h4>Description</h4><p>Set up the values of the IVs correctly when exiting the vector loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L520">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:520</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r33A490E798BA8C33.html">llvm::PHINode</a>*<b> OrigPhi</b></dt><dt class="is-family-code">const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp;<b> II</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> CountRoundDown</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> EndValue</b></dt><dt class="is-family-code"><a href="r5F23A6FBCC3A87BD.html">llvm::BasicBlock</a>*<b> MiddleBlock</b></dt></dl><h3 id="54BAB49D3423C093"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#54BAB49D3423C093">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* getBroadcastInstrs(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V)</code></pre></h3><h4>Description</h4><p>Create a broadcast instruction. This method generates a broadcast instruction (shuffle) for loop invariant values and for the induction value. If this is the induction variable then we extend it to N, N+1, ... this is needed because each iteration in the loop corresponds to a SIMD element.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L561">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:561</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt></dl><h3 id="2CC8D151A0E6FD14"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2CC8D151A0E6FD14">¶</a><code class="hdoc-function-code language-cpp"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>* getOrCreateScalarValue(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V,
    const <a href="r4C6F81A3088B6500.html">llvm::VPIteration</a>&amp; Instance)</code></pre></h3><h4>Description</h4><p>Return a value in the new loop corresponding to \p V from the original loop at unroll and vector indices \p Instance. If the value has been vectorized but not scalarized, the necessary extractelement instruction will be generated.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L480">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:480</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt><dt class="is-family-code">const <a href="r4C6F81A3088B6500.html">llvm::VPIteration</a>&amp;<b> Instance</b></dt></dl><h3 id="31CEAE776B6917C6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#31CEAE776B6917C6">¶</a><code class="hdoc-function-code language-cpp"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>* getOrCreateTripCount(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* NewLoop)</code></pre></h3><h4>Description</h4><p>Returns (and creates if needed) the original loop trip count.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L621">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:621</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> NewLoop</b></dt></dl><h3 id="3794D41A2C64A34F"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#3794D41A2C64A34F">¶</a><code class="hdoc-function-code language-cpp"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>* getOrCreateVectorTripCount(
    <a href="r210AF08D1E341AC3.html">llvm::Loop</a>* NewLoop)</code></pre></h3><h4>Description</h4><p>Returns (and creates if needed) the trip count of the widened loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L624">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:624</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r210AF08D1E341AC3.html">llvm::Loop</a>*<b> NewLoop</b></dt></dl><h3 id="EE55480020C6E736"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#EE55480020C6E736">¶</a><code class="hdoc-function-code language-cpp"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>* getOrCreateVectorValue(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V,
    unsigned int Part)</code></pre></h3><h4>Description</h4><p>getOrCreateVectorValue and getOrCreateScalarValue coordinate to generate a vector or scalar value on-demand if one is not yet available. When vectorizing a loop, we visit the definition of an instruction before its uses. When visiting the definition, we either vectorize or scalarize the instruction, creating an entry for it in the corresponding map. (In some cases, such as induction variables, we will create both vector and scalar entries.) Then, as we encounter uses of the definition, we derive values for each scalar or vector use unless such a value is already available. For example, if we scalarize a definition and one of its uses is vector, we build the required vector on-demand with an insertelement sequence when visiting the use. Otherwise, if the use is scalar, we can use the existing scalar definition. Return a value in the new loop corresponding to \p V from the original loop at unroll index \p Part. If the value has already been vectorized, the corresponding vector entry in VectorLoopValueMap is returned. If, however, the value has a scalar entry in VectorLoopValueMap, we construct a new vector value on-demand by inserting the scalar values into a vector with an insertelement sequence. If the value has been neither vectorized nor scalarized, it must be loop invariant, so we simply broadcast the value into a vector.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L474">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:474</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt><dt class="is-family-code">unsigned int<b> Part</b></dt></dl><h3 id="A3CC810EBE7C9D0D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#A3CC810EBE7C9D0D">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* getStepVector(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Val,
    int StartIdx,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Step,
    Instruction::BinaryOps Opcode =
        Instruction::BinaryOpsEnd)</code></pre></h3><h4>Description</h4><p>This function adds (StartIdx, StartIdx + Step, StartIdx + 2*Step, ...) to each vector element of Val. The sequence starts at StartIndex.\p Opcode is relevant for FP induction variable.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L566">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:566</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Val</b></dt><dt class="is-family-code">int<b> StartIdx</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Step</b></dt><dt class="is-family-code">Instruction::BinaryOps<b> Opcode</b> = Instruction::BinaryOpsEnd</dt></dl><h3 id="05AFAA89292D5804"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#05AFAA89292D5804">¶</a><code class="hdoc-function-code language-cpp">bool needsScalarInduction(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* IV) const</code></pre></h3><h4>Description</h4><p>Returns true if we should generate a scalar version of \p IV.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L591">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:591</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> IV</b></dt></dl><h3 id="F0E416D5ABA50556"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#F0E416D5ABA50556">¶</a><code class="hdoc-function-code language-cpp">void packScalarIntoVectorValue(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* V,
    const <a href="r4C6F81A3088B6500.html">llvm::VPIteration</a>&amp; Instance)</code></pre></h3><h4>Description</h4><p>Construct the vector value of a scalarized value \p V one lane at a time.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L483">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:483</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> V</b></dt><dt class="is-family-code">const <a href="r4C6F81A3088B6500.html">llvm::VPIteration</a>&amp;<b> Instance</b></dt></dl><h3 id="7BCF1B7F79E10226"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#7BCF1B7F79E10226">¶</a><code class="hdoc-function-code language-cpp">void recordVectorLoopValueForInductionCast(
    const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp; ID,
    const <a href="rE266D8602316BABC.html">llvm::Instruction</a>* EntryVal,
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* VectorLoopValue,
    unsigned int Part,
    unsigned int Lane = (2147483647 * 2U + 1U))</code></pre></h3><h4>Description</h4><p>If there is a cast involved in the induction variable \p ID, which should be ignored in the vectorized loop body, this function records the VectorLoopValue of the respective Phi also as the VectorLoopValue of the cast. We had already proved that the casted Phi is equal to the uncasted Phi in the vectorized loop (under a runtime guard), and therefore there is no need to vectorize the cast - the same value can be used in the vector loop for both the Phi and the cast. If \p VectorLoopValue is a scalarized value, \p Lane is also specified, Otherwise, \p VectorLoopValue is a widened/vectorized value. \p EntryVal is the value from the original loop that maps to the vector phi node and is used to distinguish what is the IV currently being processed - original one (if \p EntryVal is a phi corresponding to the original IV) or the &quot;newly-created&quot; one based on the proof mentioned above (see also buildScalarSteps() and createVectorIntOrFPInductionPHI()). In the latter case \p EntryVal is a TruncInst and we must not record anything for that IV, but it&apos;s error-prone to expect callers of this routine to care about that, hence this explicit parameter.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L611">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:611</a></p><h4>Parameters</h4><dl><dt class="is-family-code">const <a href="r8C5CB01A7D5D901A.html">llvm::InductionDescriptor</a>&amp;<b> ID</b></dt><dt class="is-family-code">const <a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> EntryVal</b></dt><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> VectorLoopValue</b></dt><dt class="is-family-code">unsigned int<b> Part</b></dt><dt class="is-family-code">unsigned int<b> Lane</b> = (2147483647 * 2U + 1U)</dt></dl><h3 id="120E95871BE01989"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#120E95871BE01989">¶</a><code class="hdoc-function-code language-cpp">virtual <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* reverseVector(
    <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Vec)</code></pre></h3><h4>Description</h4><p>Generate a shuffle sequence that will reverse the vector Vec.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L618">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:618</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Vec</b></dt></dl><h3 id="2A1686508270BAD4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#2A1686508270BAD4">¶</a><code class="hdoc-function-code language-cpp">void scalarizeInstruction(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* Instr,
    const <a href="r4C6F81A3088B6500.html">llvm::VPIteration</a>&amp; Instance,
    bool IfPredicateInstr)</code></pre></h3><h4>Description</h4><p>A helper function to scalarize a single Instruction in the innermost loop. Generates a sequence of scalar instances for each lane between \p MinLane and \p MaxLane, times each part between \p MinPart and \p MaxPart, inclusive..</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L445">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:445</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> Instr</b></dt><dt class="is-family-code">const <a href="r4C6F81A3088B6500.html">llvm::VPIteration</a>&amp;<b> Instance</b></dt><dt class="is-family-code">bool<b> IfPredicateInstr</b></dt></dl><h3 id="FE709CC171570F2B"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#FE709CC171570F2B">¶</a><code class="hdoc-function-code language-cpp">void setDebugLocFromInst(<a href="rB252D65A795AFC3C.html">IRBuilder</a>&lt;&gt;&amp; B,
                         const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>* Ptr)</code></pre></h3><h4>Description</h4><p>Set the debug location in the builder using the debug location in the instruction.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L502">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:502</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rB252D65A795AFC3C.html">IRBuilder</a>&lt;&gt;&amp;<b> B</b></dt><dt class="is-family-code">const <a href="r4EC65655F3BC4E59.html">llvm::Value</a>*<b> Ptr</b></dt></dl><h3 id="B6BEC39BCC15F35E"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#B6BEC39BCC15F35E">¶</a><code class="hdoc-function-code language-cpp">bool shouldScalarizeInstruction(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* I) const</code></pre></h3><h4>Description</h4><p>Returns true if an instruction \p I should be scalarized instead of vectorized for the chosen vectorization factor.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L588">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:588</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> I</b></dt></dl><h3 id="500FBC3A2995AE67"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#500FBC3A2995AE67">¶</a><code class="hdoc-function-code language-cpp">void sinkScalarOperands(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* PredInst)</code></pre></h3><h4>Description</h4><p>Iteratively sink the scalarized operands of a predicated instruction into the block that was created for it.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L550">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:550</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> PredInst</b></dt></dl><h3 id="685FA03A3E1A7898"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#685FA03A3E1A7898">¶</a><code class="hdoc-function-code language-cpp">void truncateToMinimalBitwidths()</code></pre></h3><h4>Description</h4><p>Shrinks vector element sizes to the smallest bitwidth they can be legally represented as.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L554">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:554</a></p><h3 id="DD017F28F7D53C5D"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#DD017F28F7D53C5D">¶</a><code class="hdoc-function-code language-cpp">void vectorizeInterleaveGroup(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* Instr,
    <a href="rDFF94A5A707DCD55.html">llvm::VPTransformState</a>&amp; State,
    <a href="r5387BDC129002C87.html">llvm::VPValue</a>* Addr,
    <a href="r5387BDC129002C87.html">llvm::VPValue</a>* BlockInMask = nullptr)</code></pre></h3><h4>Description</h4><p>Try to vectorize the interleaved access group that \p Instr belongs to with the base address given in \p Addr, optionally masking the vector operations if \p BlockInMask is non-null. Use \p State to translate given VPValues to IR values in the vectorized loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L489">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:489</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> Instr</b></dt><dt class="is-family-code"><a href="rDFF94A5A707DCD55.html">llvm::VPTransformState</a>&amp;<b> State</b></dt><dt class="is-family-code"><a href="r5387BDC129002C87.html">llvm::VPValue</a>*<b> Addr</b></dt><dt class="is-family-code"><a href="r5387BDC129002C87.html">llvm::VPValue</a>*<b> BlockInMask</b> = nullptr</dt></dl><h3 id="BEE268F0266A93C9"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#BEE268F0266A93C9">¶</a><code class="hdoc-function-code language-cpp">void vectorizeMemoryInstruction(
    <a href="rE266D8602316BABC.html">llvm::Instruction</a>* Instr,
    <a href="rDFF94A5A707DCD55.html">llvm::VPTransformState</a>&amp; State,
    <a href="r5387BDC129002C87.html">llvm::VPValue</a>* Addr,
    <a href="r5387BDC129002C87.html">llvm::VPValue</a>* BlockInMask = nullptr)</code></pre></h3><h4>Description</h4><p>Vectorize Load and Store instructions with the base address given in \p Addr, optionally masking the vector operations if \p BlockInMask is non-null. Use \p State to translate given VPValues to IR values in the vectorized loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L496">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:496</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> Instr</b></dt><dt class="is-family-code"><a href="rDFF94A5A707DCD55.html">llvm::VPTransformState</a>&amp;<b> State</b></dt><dt class="is-family-code"><a href="r5387BDC129002C87.html">llvm::VPValue</a>*<b> Addr</b></dt><dt class="is-family-code"><a href="r5387BDC129002C87.html">llvm::VPValue</a>*<b> BlockInMask</b> = nullptr</dt></dl><h3 id="195B10269C6B3712"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#195B10269C6B3712">¶</a><code class="hdoc-function-code language-cpp">void widenGEP(
    <a href="r3F5681CF2722A4CA.html">llvm::GetElementPtrInst</a>* GEP,
    unsigned int UF,
    unsigned int VF,
    bool IsPtrLoopInvariant,
    <a href="r314DAD2882B08277.html">llvm::SmallBitVector</a>&amp; IsIndexLoopInvariant)</code></pre></h3><h4>Description</h4><p>Vectorize a single GetElementPtrInst based on information gathered and decisions taken during planning.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L433">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:433</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r3F5681CF2722A4CA.html">llvm::GetElementPtrInst</a>*<b> GEP</b></dt><dt class="is-family-code">unsigned int<b> UF</b></dt><dt class="is-family-code">unsigned int<b> VF</b></dt><dt class="is-family-code">bool<b> IsPtrLoopInvariant</b></dt><dt class="is-family-code"><a href="r314DAD2882B08277.html">llvm::SmallBitVector</a>&amp;<b> IsIndexLoopInvariant</b></dt></dl><h3 id="26DDDFA127A09AB4"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#26DDDFA127A09AB4">¶</a><code class="hdoc-function-code language-cpp">void widenInstruction(<a href="rE266D8602316BABC.html">llvm::Instruction</a>&amp; I)</code></pre></h3><h4>Description</h4><p>Widen a single instruction within the innermost loop.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L418">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:418</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>&amp;<b> I</b></dt></dl><h3 id="00D8000152703282"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#00D8000152703282">¶</a><code class="hdoc-function-code language-cpp">void widenIntOrFpInduction(
    <a href="r33A490E798BA8C33.html">llvm::PHINode</a>* IV,
    <a href="r3E3EEEB035C8E6B0.html">llvm::TruncInst</a>* Trunc = nullptr)</code></pre></h3><h4>Description</h4><p>Widen an integer or floating-point induction variable \p IV. If \p Trunc is provided, the integer induction variable will first be truncated to the corresponding type.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L451">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:451</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="r33A490E798BA8C33.html">llvm::PHINode</a>*<b> IV</b></dt><dt class="is-family-code"><a href="r3E3EEEB035C8E6B0.html">llvm::TruncInst</a>*<b> Trunc</b> = nullptr</dt></dl><h3 id="D2030BB5C3C7B0F6"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#D2030BB5C3C7B0F6">¶</a><code class="hdoc-function-code language-cpp">void widenPHIInstruction(<a href="rE266D8602316BABC.html">llvm::Instruction</a>* PN,
                         unsigned int UF,
                         unsigned int VF)</code></pre></h3><h4>Description</h4><p>Vectorize a single PHINode in a block. This method handles the induction variable canonicalization. It supports both VF = 1 for unrolled loops and arbitrary length vectors.</p><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L439">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:439</a></p><h4>Parameters</h4><dl><dt class="is-family-code"><a href="rE266D8602316BABC.html">llvm::Instruction</a>*<b> PN</b></dt><dt class="is-family-code">unsigned int<b> UF</b></dt><dt class="is-family-code">unsigned int<b> VF</b></dt></dl><h3 id="0A65B5A9F2A00109"><pre class="p-0 hdoc-pre-parent"><a class="hdoc-permalink-icon" href="#0A65B5A9F2A00109">¶</a><code class="hdoc-function-code language-cpp">virtual ~InnerLoopVectorizer()</code></pre></h3><p>Declared at: <a class="is-family-code" href="https://github.com/llvm/llvm-project/blob/release/10.x/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp#L411">llvm/lib/Transforms/Vectorize/LoopVectorize.cpp:411</a></p></main></div></div></div></section></div><footer class="footer"><p>Documentation for LLVM 10.0.0.</p><p>Generated by <a href="https://hdoc.io/">hdoc</a> version 1.4.0-hdocInternal on 2022-12-14T09:44:14 UTC.</p><p class="has-text-grey-light">19AD43E11B2996</p></footer></body></html>